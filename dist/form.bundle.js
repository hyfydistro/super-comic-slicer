(self.webpackChunksuper_comic_slicer=self.webpackChunksuper_comic_slicer||[]).push([[680],{352:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(294);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(935);\n// EXTERNAL MODULE: ./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js\nvar react_beautiful_dnd_esm = __webpack_require__(948);\n;// CONCATENATED MODULE: ./src/scripts/libs/convertBytes.js\nfunction returnFileSize(number) {\n  if (number < 1024) {\n    return number + \'bytes\';\n  } else if (number >= 1024 && number < 1048576) {\n    return (number / 1024).toFixed(1) + \'KB\';\n  } else if (number >= 1048576) {\n    return (number / 1048576).toFixed(1) + \'MB\';\n  }\n}\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(893);\n;// CONCATENATED MODULE: ./src/scripts/components/FormUpload.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n // libs\n\n // TODO: FEATURE (NEXT UPDATE)\n// "Rotate" button in Preview thumb\n// Also see in \'Form.js\'\n// ? bullet point guidelines instead of one line paragraph\n\n\n\n\nfunction Thumbnails(props) {\n  var files = props.inputField;\n  var previewThumbnailElements;\n\n  if (files) {\n    previewThumbnailElements = files.map(function (file, index) {\n      var reader = new FileReader();\n      reader.readAsDataURL(file.fileRead);\n      reader.addEventListener("load", getDataURL);\n\n      function getDataURL() {\n        var currentElement = document.querySelectorAll(".preview__thumbnail-container")[index].lastElementChild.firstElementChild;\n        currentElement.src = reader.result;\n      }\n\n      return /*#__PURE__*/(0,jsx_runtime.jsx)(react_beautiful_dnd_esm/* Draggable */._l, {\n        draggableId: file.id.toString(),\n        index: index,\n        children: function children(provided) {\n          return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", _objectSpread(_objectSpread(_objectSpread({\n            className: "preview__thumbnail-container",\n            "data-label": JSON.stringify(file.fileRead.name),\n            ref: provided.innerRef\n          }, provided.draggableProps), provided.dragHandleProps), {}, {\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)("button", {\n              className: "close-btn",\n              onClick: function onClick(e) {\n                return props.onRemoveSelf(e);\n              },\n              children: /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n                class: "icon-remove",\n                children: [/*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n                  class: "path1"\n                }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n                  class: "path2"\n                }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n                  class: "path3"\n                })]\n              })\n            }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n              className: "preview__thumbnail",\n              children: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n                alt: ""\n              })\n            })]\n          }));\n        }\n      }, file.id);\n    });\n  }\n\n  return previewThumbnailElements;\n}\n\nfunction Preview(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: props.togglePreviewWrapperClass,\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: "preview-container",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(react_beautiful_dnd_esm/* DragDropContext */.Z5, {\n        onDragEnd: props.onhandleDragEnd,\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(react_beautiful_dnd_esm/* Droppable */.bK, {\n          droppableId: "preview",\n          direction: "horizontal",\n          children: function children(provided) {\n            return /*#__PURE__*/(0,jsx_runtime.jsxs)("div", _objectSpread(_objectSpread({\n              className: "preview"\n            }, provided.droppableProps), {}, {\n              ref: provided.innerRef,\n              children: [/*#__PURE__*/(0,jsx_runtime.jsx)(Thumbnails, {\n                inputField: props.inputField,\n                onRemoveSelf: props.onRemoveSelf\n              }), provided.placeholder]\n            }));\n          }\n        })\n      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n        className: "preview__clear-btn-container",\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: "file-size__container",\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n            className: "file-size-text",\n            children: ["Total File Size: ", returnFileSize(props.getTotalFileSize)]\n          })\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("button", {\n          className: "preview__clear-btn",\n          onClick: props.onHandleClickToRemoveAll,\n          children: "Clear Files"\n        })]\n      })]\n    })\n  });\n}\n\nfunction Dropzone(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n    className: "dropzone-container",\n    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: props.toggleDropzoneBordersClass,\n      onDragOver: function onDragOver(e) {\n        return props.onHandleDrag(e);\n      },\n      onDragEnter: function onDragEnter(e) {\n        return props.onHandleDrag(e);\n      },\n      onDragEnd: function onDragEnd(e) {\n        return props.onHandleDragLeave(e);\n      },\n      onDragLeave: function onDragLeave(e) {\n        return props.onHandleDragLeave(e);\n      },\n      onDrop: function onDrop(e) {\n        return props.onHandleFileDrop(e);\n      },\n      onClick: props.onHandleClickToUpload,\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("i", {\n        className: "dropzone__upload-icon icon-upload"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n        children: "Drag & Drop or Click here"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n        className: "text-small",\n        children: "to upload your files (max. 20MB)"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("input", {\n        onChange: function onChange(e) {\n          return props.onHandleInputChange(e);\n        },\n        className: "dropzone__input",\n        type: "file",\n        accept: "image/png, image/jpeg",\n        multiple: true\n      })]\n    })\n  });\n}\n\nfunction FormUpload(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("section", {\n    className: "form-upload",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h3", {\n      children: "1. Upload"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n      children: "Currently, PNG and JPEG (including JPG) are accepted. If width of image is larger than height, it will be returned as is unless Options Squash chosen."\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)(Dropzone // EVENTS\n    , {\n      onHandleDrag: props.onHandleDrag,\n      onHandleDragLeave: function onHandleDragLeave(e) {\n        return props.onHandleDragLeave(e);\n      },\n      onHandleFileDrop: function onHandleFileDrop(e) {\n        return props.onHandleFileDrop(e);\n      },\n      onHandleInputChange: function onHandleInputChange(e) {\n        return props.onHandleInputChange(e);\n      },\n      onHandleClickToUpload: props.onHandleClickToUpload,\n      onHandleChange: props.onHandleChange // STYLE EVENTS\n      ,\n      toggleDropzoneBordersClass: props.toggleDropzoneBordersClass\n    }), props.isAlertMessageError === true ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: "alert-message--error",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("i", {\n        className: "alert-icon alert-icon--error icon-warning"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "alert-message-text--error",\n        children: props.getAlertErrorText\n      })]\n    }) : null, props.isAlertMessageSuccess === true ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: "alert-message--success",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("i", {\n        className: "alert-icon alert-icon--success icon-check"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "alert-message-text--success",\n        children: props.getAlertSuccessText\n      })]\n    }) : null, props.isAlertMessageWarning === true ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: "alert-message--warning",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("i", {\n        className: "alert-icon alert-icon--warning icon-warning"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "alert-message-text--warning",\n        children: props.getAlertWarningText\n      })]\n    }) : null, props.inputField.length !== 0 ? /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n      children: "If you have more than one image file, you may drag and re-order."\n    }) : null, props.inputField.length !== 0 ? /*#__PURE__*/(0,jsx_runtime.jsx)(Preview, {\n      inputField: props.inputField,\n      onhandleDragEnd: props.onhandleDragEnd,\n      onRemoveSelf: props.onRemoveSelf,\n      togglePreviewWrapperClass: props.togglePreviewWrapperClass,\n      onHandleClickToRemoveAll: props.onHandleClickToRemoveAll,\n      getTotalFileSize: props.getTotalFileSize\n    }) : null]\n  });\n}\n;// CONCATENATED MODULE: ./src/scripts/components/FormSelect.js\n\n\n\nfunction WebcomicsOptions(props) {\n  var webcomicsList = props.getWebcomicsModel.map(function (currentWebcomic, tabindex) {\n    if (currentWebcomic.disabled) {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: "select-option",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("label", {\n          htmlFor: currentWebcomic.htmlLabel,\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n            className: "select-label--wrapper",\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", {\n              type: "checkbox",\n              id: currentWebcomic.htmlLabel,\n              disabled: true\n            }), /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n              className: "select-label",\n              children: [/*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n                className: "select-icon",\n                src: currentWebcomic.imageSource,\n                alt: currentWebcomic.htmlAlt\n              }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n                className: "select-text",\n                children: currentWebcomic.text\n              })]\n            })]\n          })\n        })\n      }, tabindex);\n    } else {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: "select-option",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)("label", {\n          htmlFor: currentWebcomic.htmlLabel,\n          children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n            className: "select-label--wrapper",\n            children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", {\n              type: "checkbox",\n              id: currentWebcomic.htmlLabel,\n              value: currentWebcomic.htmlLabel,\n              onClick: function onClick(e) {\n                return props.onHandleSelectedWebcomic(e);\n              }\n            }), /*#__PURE__*/(0,jsx_runtime.jsxs)("span", {\n              className: "select-label",\n              children: [/*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n                className: "select-icon",\n                src: currentWebcomic.imageSource,\n                alt: currentWebcomic.htmlAlt\n              }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n                className: "select-text",\n                children: currentWebcomic.text\n              })]\n            })]\n          })\n        })\n      }, tabindex);\n    }\n  });\n  return webcomicsList;\n}\n\nfunction FormSelect(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("section", {\n    className: "form-select",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h3", {\n      children: "2. Select"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n      children: "Select webcomic platform to base slicing ratio. You may select more than one. *Currently, Webtoon is only available."\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "select-container",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(WebcomicsOptions, {\n        getWebcomicsModel: props.getWebcomicsModel,\n        onHandleSelectedWebcomic: props.onHandleSelectedWebcomic\n      })\n    }), props.isAlertMessageSelectFormError === true ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n      className: "alert-message--error",\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("i", {\n        className: "alert-icon alert-icon--error icon-warning"\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n        className: "alert-message-text--error",\n        children: props.getAlertMessageSelectFormText\n      })]\n    }) : null]\n  });\n}\n;// CONCATENATED MODULE: ./src/scripts/components/FormOptions.js\n\n\n\nfunction SquashOptions(props) {\n  var squashLevelList = props.getSquashLevelModel.map(function (currentSquashLevel, index) {\n    if (props.getSquashLevelModel[0] == currentSquashLevel) {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: "radio-option",\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("label", {\n          htmlFor: currentSquashLevel.htmlLabel,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", {\n            defaultChecked: true,\n            type: "radio",\n            name: "squash",\n            value: currentSquashLevel.pixelValue,\n            id: currentSquashLevel.htmlLabel,\n            onClick: function onClick(e) {\n              return props.onHandleOptionsSquashLevel(e);\n            }\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: "select-text",\n            children: currentSquashLevel.text\n          })]\n        })\n      }, index);\n    } else {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: "radio-option",\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("label", {\n          htmlFor: currentSquashLevel.htmlLabel,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", {\n            type: "radio",\n            name: "squash",\n            value: currentSquashLevel.pixelValue,\n            id: currentSquashLevel.htmlLabel,\n            onClick: function onClick(e) {\n              return props.onHandleOptionsSquashLevel(e);\n            }\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: "select-text",\n            children: currentSquashLevel.text\n          })]\n        })\n      }, index);\n    }\n  });\n  return squashLevelList;\n}\n\nfunction FileExtensionOptions(props) {\n  var fileExtensionsList = props.getFilExtensionsModel.map(function (fileExtObj, index) {\n    if (props.getFilExtensionsModel[0] === fileExtObj) {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: "radio-option",\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("label", {\n          htmlFor: fileExtObj.htmlLabel,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", {\n            defaultChecked: true,\n            type: "radio",\n            name: "filetype",\n            value: fileExtObj.htmlLabel,\n            id: fileExtObj.htmlLabel,\n            onClick: function onClick(e) {\n              return props.onHandleOptionsFileExtenions(e);\n            }\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: "select-text",\n            children: fileExtObj.text\n          })]\n        })\n      }, index);\n    } else {\n      return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: "radio-option",\n        children: /*#__PURE__*/(0,jsx_runtime.jsxs)("label", {\n          htmlFor: fileExtObj.htmlLabel,\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("input", {\n            type: "radio",\n            name: "filetype",\n            value: fileExtObj.htmlLabel,\n            id: fileExtObj.htmlLabel,\n            onClick: function onClick(e) {\n              return props.onHandleOptionsFileExtenions(e);\n            }\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: "select-text",\n            children: fileExtObj.text\n          })]\n        })\n      }, index);\n    }\n  });\n  return fileExtensionsList;\n}\n\nfunction FormOptions(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("section", {\n    className: "form-options",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h3", {\n      children: "3. Options"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n      className: "text-bold header-four",\n      children: "File Extensions"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "radio-container-filetype",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(FileExtensionOptions, {\n        getFilExtensionsModel: props.getFilExtensionsModel,\n        onHandleOptionsFileExtenions: props.onHandleOptionsFileExtenions\n      })\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n      className: "text-bold header-four",\n      children: "Squash"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n      className: "margin-fix",\n      children: "Squash scale down image file size."\n    }), /*#__PURE__*/(0,jsx_runtime.jsxs)("ul", {\n      children: [/*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n        children: "If your file size is big enough it may refine illustrations. Slicing ratio will not be affected - it will produce the same page division."\n      }), /*#__PURE__*/(0,jsx_runtime.jsx)("li", {\n        children: "if your file is smaller than the selected squash option, it will expand your image and attempt to produce to the same aspect ratio of your chosen webcomic platform."\n      })]\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "radio-container-squash",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)(SquashOptions, {\n        getSquashLevelModel: props.getSquashLevelModel,\n        onHandleOptionsSquashLevel: props.onHandleOptionsSquashLevel\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./src/scripts/components/FormResults.js\n\n\n\n// TODO: FEATURE (NEXT UPDATE)\n// adjust to webcomic platform ratio for display\nfunction Product(props) {\n  // INJECT image blob\n  var processedImageFIles = props.getImageData.map(function (imgData, index) {\n    return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "product__image-block",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("img", {\n        src: imgData\n      })\n    }, index);\n  });\n  return processedImageFIles;\n}\n\nfunction FormResults(props) {\n  return /*#__PURE__*/(0,jsx_runtime.jsxs)("section", {\n    className: "form-results",\n    children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h3", {\n      children: "Results"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {\n      children: "For each webcomic platform selected, a zip file will be automatically downloaded after slicing process completed."\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("canvas", {\n      id: "canvas"\n    }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n      className: "product-container",\n      children: /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n        className: "product",\n        children: /*#__PURE__*/(0,jsx_runtime.jsx)(Product, {\n          getImageData: props.getImageData\n        })\n      })\n    })]\n  });\n}\n;// CONCATENATED MODULE: ./src/scripts/libs/createId.js\nfunction generateUniqueId() {\n  if (window.crypto && window.crypto.getRandomValues) {\n    return window.crypto.getRandomValues(new Uint32Array(1))[0];\n  } else {\n    return Math.random();\n  }\n}\n;// CONCATENATED MODULE: ./src/scripts/components/Form.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n // libs\n\n // TODO: FEATURE (NEXT UPDATE)\n// "Rotate" button in Preview thumb\n// Also see in \'FormUpload.js\'\n\n\n\n\nvar alertMessages = {\n  onSuccess: {\n    filesRemoved: "Files were cleared.",\n    completedProcess: "Process completed!"\n  },\n  onError: {\n    unacceptableFileType: "File extensions not supported! Only PNG and JPEG (or JPG) allowed.",\n    overMaxFileSize: "Total file size is over maximum. Remove some files to continue.",\n    noFilesFound: "No images found to process. Upload some images to \'Begin Slice\'!",\n    selectFormMandatory: "Please check at least one webcomic platform under \'2. Select\'.",\n    selectFormMandatoryTarget: "Check at least one in order to continue."\n  },\n  onWarning: {\n    nearMaxFileSize: "Total file size is near maximum!"\n  }\n};\nvar webcomicsModel = [{\n  htmlLabel: "webtoon",\n  imageSource: "images/webtoon-icon.svg",\n  htmlAlt: "webtoon icon",\n  text: "Webtoon",\n  disabled: false\n}, {\n  htmlLabel: "tapas",\n  imageSource: "images/tapas-icon.png",\n  htmlAlt: "tapas icon",\n  text: "Tapas",\n  disabled: true\n}]; // RADIO OPTIONS\n// Default CHECKED: filExtensionsModel[0]\n\nvar filExtensionsModel = [{\n  htmlLabel: "jpeg",\n  text: "JPEG"\n}, {\n  htmlLabel: "png",\n  text: "PNG"\n}]; // RADIO OPTIONS\n// Default CHECKED: squashLevelModel[0]\n\nvar squashLevelModel = [{\n  htmlLabel: "none",\n  pixelValue: 0,\n  text: "none"\n}, {\n  htmlLabel: "400",\n  pixelValue: 400,\n  text: "400 width pixels"\n}, {\n  htmlLabel: "500",\n  pixelValue: 500,\n  text: "500 width pixels"\n}, {\n  htmlLabel: "600",\n  pixelValue: 600,\n  text: "600 width pixels"\n}, {\n  htmlLabel: "700",\n  pixelValue: 700,\n  text: "700 width pixels"\n}]; // Accepted file types\n\nvar fileTypes = [\'image/jpeg\', \'image/jpg\', \'image/png\'];\n\nfunction validFileType(file) {\n  return fileTypes.includes(file);\n}\n\nvar Form = /*#__PURE__*/function (_Component) {\n  _inherits(Form, _Component);\n\n  var _super = _createSuper(Form);\n\n  function Form(props) {\n    var _this;\n\n    _classCallCheck(this, Form);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      // # STYLES EVENT\n      // EVENT: onDragOver\n      isDragOver: false,\n      dropzoneBordersClass: {\n        highlight: "dropzone dropzone--over",\n        default: "dropzone"\n      },\n      inputDataAvailable: false,\n      // EVENT: onClick\n      // "Begin Slice!" button\n      sliceText: "slice-btn",\n      // EVENT: conditional\n      // div class "preview-wrapper"\n      previewWrapperClass: {\n        visible: "preview-wrapper",\n        invisible: "preview-wrapper hidden"\n      },\n      // # ALERT MESSAGES AND STATE\n      // Success\n      isAlertMessageSuccess: false,\n      alertMessageSuccess: "",\n      // Error\n      isAlertMessageError: false,\n      alertMessageError: "",\n      // Warning\n      isAlertMessageWarning: false,\n      alertMessageWarning: "",\n      // Error on "Begin Slice!"\n      isAlertMessageErrorOnBeginSliceBtn: false,\n      alertMessageErrorOnBeginSliceBtn: "",\n      // Success on "Begin Slice!"\n      isAlertMessageSuccessOnBeginSliceBtn: false,\n      alertMessageSuccessOnBeginSliceBtn: "",\n      // Error on none webcomic platform selected\n      isAlertMessageErrorOnSelectForm: false,\n      alertMessageErrorOnSelectForm: "",\n      // # DATA\n      processedFileData: [],\n      inputField: [],\n      // inputField: [\n      //     {\n      //         fileRead: [<obj>],\n      //         id: <number>\n      //         fileSize: <number>\n      //     }\n      // ]\n      totalFileSize: 0,\n      // Byte measurement\n      selectedWebcomics: [],\n      selectedFileExtension: "jpeg",\n      // default value\n      selectedSquashLevel: "none"\n    }; // # METHODS\n\n    _this.handleDrag = _this.handleDrag.bind(_assertThisInitialized(_this));\n    _this.handleDragLeave = _this.handleDragLeave.bind(_assertThisInitialized(_this));\n    _this.handleFileDrop = _this.handleFileDrop.bind(_assertThisInitialized(_this));\n    _this.processResults = _this.processResults.bind(_assertThisInitialized(_this));\n    _this.handleBeginSlicBtn = _this.handleBeginSlicBtn.bind(_assertThisInitialized(_this)); // TOGGLE CLASS\n\n    _this.toggleBeginSliceText = _this.toggleBeginSliceText.bind(_assertThisInitialized(_this));\n    _this.handleDragEnd = _this.handleDragEnd.bind(_assertThisInitialized(_this)); // DATA MANAGEMENT\n    // DELETE Data\n\n    _this.handleRemoveSelf = _this.handleRemoveSelf.bind(_assertThisInitialized(_this));\n    _this.handleClickToRemoveAll = _this.handleClickToRemoveAll.bind(_assertThisInitialized(_this)); // SET file data\n\n    _this.setFilesData = _this.setFilesData.bind(_assertThisInitialized(_this)); // GET total file size\n\n    _this.checkTotalFileSize = _this.checkTotalFileSize.bind(_assertThisInitialized(_this)); // UPLOAD on file browse\n\n    _this.handleInputChange = _this.handleInputChange.bind(_assertThisInitialized(_this));\n    _this.handleSelectedWebcomic = _this.handleSelectedWebcomic.bind(_assertThisInitialized(_this));\n    _this.handleOptionsFileExtenions = _this.handleOptionsFileExtenions.bind(_assertThisInitialized(_this));\n    _this.handleOptionsSquashLevel = _this.handleOptionsSquashLevel.bind(_assertThisInitialized(_this));\n    return _this;\n  } // ===============\n  // # REACT METHODS\n  // ===============\n  // componentWillUnmount() {\n  //     console.log("UNMOUNTING...");\n  // }\n  // componentDidMount() {\n  //     console.log("MOUNTING...");\n  // }\n  // componentDidUpdate() {\n  //     console.log("COMPONENT UPDATING...");\n  // }\n  // ========\n  // # EVENTS\n  // ========\n  // event: drag\n\n\n  _createClass(Form, [{\n    key: "handleDrag",\n    value: function handleDrag(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      this.setState({\n        isDragOver: true\n      });\n    } // event: drag\n\n  }, {\n    key: "handleDragLeave",\n    value: function handleDragLeave(e) {\n      e.preventDefault(e);\n      e.stopPropagation();\n      this.setState({\n        isDragOver: false\n      });\n    } // event: drag\n    // Reorder files\n\n  }, {\n    key: "handleDragEnd",\n    value: function handleDragEnd(result) {\n      // CREATE shallow copy\n      var items = Array.from(this.state.inputField); // EXTRACT targeted item\n\n      var _items$splice = items.splice(result.source.index, 1),\n          _items$splice2 = _slicedToArray(_items$splice, 1),\n          reorderedItem = _items$splice2[0]; // PUSH targeted item into new order\n\n\n      items.splice(result.destination.index, 0, reorderedItem);\n      this.setState({\n        inputField: items\n      });\n    } // event: click\n    // Open browser for files\n\n  }, {\n    key: "handleClickToUpload",\n    value: function handleClickToUpload() {\n      var dropzoneInput = document.querySelector(".dropzone__input"); // EMULATE HTML input CLICK event\n\n      dropzoneInput.click();\n    } // event: click\n    // UPDATE state \'selectedFileExtension\'\n\n  }, {\n    key: "handleOptionsFileExtenions",\n    value: function handleOptionsFileExtenions(e) {\n      var newSelectedFileExtension = e.target.value;\n      this.setState({\n        selectedFileExtension: newSelectedFileExtension\n      });\n    } // event: click\n    // UPDATE state \'selectedSquashLevel\'\n\n  }, {\n    key: "handleOptionsSquashLevel",\n    value: function handleOptionsSquashLevel(e) {\n      var newSelectedSquashLevel = parseInt(e.target.value, 10);\n\n      if (newSelectedSquashLevel == 0) {\n        this.setState({\n          selectedSquashLevel: "none"\n        });\n      } else {\n        this.setState({\n          selectedSquashLevel: newSelectedSquashLevel\n        });\n      }\n    } // event: click\n    // "Begin Slice!" button\n\n  }, {\n    key: "handleBeginSlicBtn",\n    value: function handleBeginSlicBtn(e) {\n      var _this2 = this;\n\n      e.preventDefault();\n\n      if (this.state.inputField.length === 0) {\n        // ALERT MESSAGE\n        // No data (or image file) found\n        this.setState({\n          isAlertMessageErrorOnBeginSliceBtn: true,\n          alertMessageErrorOnBeginSliceBtn: alertMessages.onError.noFilesFound\n        });\n        setTimeout(function () {\n          _this2.setState({\n            isAlertMessageErrorOnBeginSliceBtn: false,\n            alertMessageErrorOnBeginSliceBtn: ""\n          });\n        }, 8000);\n      } else {\n        if (this.state.selectedWebcomics.length === 0) {\n          // ALERT MESSAGE (PERSIST)\n          // No webcomic platform selected\n          this.setState({\n            isAlertMessageErrorOnBeginSliceBtn: true,\n            alertMessageErrorOnBeginSliceBtn: alertMessages.onError.selectFormMandatory,\n            isAlertMessageErrorOnSelectForm: true,\n            alertMessageErrorOnSelectForm: alertMessages.onError.selectFormMandatoryTarget\n          });\n        } else {\n          // ALERT MESSAGE (PERSIST -> REMOVED)\n          this.setState({\n            isAlertMessageErrorOnBeginSliceBtn: false,\n            alertMessageErrorOnBeginSliceBtn: "",\n            isAlertMessageErrorOnSelectForm: false,\n            alertMessageErrorOnSelectForm: ""\n          });\n          this.processResults(); // ANIMATION\n\n          this.toggleBeginSliceText();\n          setTimeout(function () {\n            _this2.toggleBeginSliceText();\n          }, 1500);\n        }\n      }\n    } // event: click\n    // "X" button\n    // REMOVE current thumb UI\n    // REMOVE current thumb data\n\n  }, {\n    key: "handleRemoveSelf",\n    value: function handleRemoveSelf(e) {\n      e.preventDefault(); // GRAB all list\n\n      var sourceThumbnails = document.querySelectorAll(".preview__thumbnail-container"); // TRANSFORM node into JavaScript objects (array)\n\n      var arrThumbnails = Array.from(sourceThumbnails); // CREATE shallow copy\n\n      var items = Array.from(this.state.inputField); // GET index of targeted item\n\n      var removeItemIndex = arrThumbnails.indexOf(e.target.parentElement); // UPDATE state totalFileSize\n\n      this.setState(function (currentState) {\n        // GET data\n        var sourceInputField = Array.from(currentState.inputField); // GET data \'fileSize\'\n\n        var fileSizesArr = sourceInputField.map(function (file) {\n          return file.fileSize;\n        }); // SUM all data \'fileSize\'\n\n        var totalFileByte = fileSizesArr.reduce(function (accumulator, currentValue) {\n          return accumulator + currentValue;\n        }); // EXTRACT targeted item \'fileSize\'\n\n        var removedItemFileSize = sourceInputField[removeItemIndex]["fileSize"]; // SUBTRACT \'totalFileSize\' - targeted item \'fileSize\'\n\n        var newTotalFileSize = totalFileByte - removedItemFileSize;\n        return {\n          totalFileSize: newTotalFileSize\n        }; // UPDATE UI\n      }, this.checkTotalFileSize()); // REMOVE targeted item\n\n      items.splice(removeItemIndex, 1); // UPDATE data\n\n      this.setState({\n        inputField: items\n      });\n    } // event: click\n    // EMPTY state "inputField"\n    // "Clear Files" button\n\n  }, {\n    key: "handleClickToRemoveAll",\n    value: function handleClickToRemoveAll() {\n      var _this3 = this;\n\n      // ALERT MESSAGE\n      // UPDATE data\n      this.setState({\n        inputField: [],\n        inputDataAvailable: false,\n        isAlertMessageSuccess: true,\n        alertMessageSuccess: alertMessages.onSuccess.filesRemoved\n      });\n      setTimeout(function () {\n        _this3.setState({\n          isAlertMessageSuccess: false,\n          alertMessageSuccess: ""\n        });\n      }, 8000);\n    } // event: change\n    // LIStEN to user on CLICK to upload file\n    // if user selects file(s), proceed to process image files methods\n\n  }, {\n    key: "handleInputChange",\n    value: function handleInputChange(e) {\n      var files = e.target.files;\n      this.setFilesData(files); // UPDATE UI on CONDITION\n\n      if (this.state.inputField) {\n        this.setState({\n          inputDataAvailable: true\n        });\n      }\n    } // event: click\n    // UPDATE state \'selectedWebcomics\'\n\n  }, {\n    key: "handleSelectedWebcomic",\n    value: function handleSelectedWebcomic(e) {\n      var selectedWebcomicValue = e.target.value;\n      var currentSelectedWebcomics = this.state.selectedWebcomics;\n\n      if (currentSelectedWebcomics.includes(selectedWebcomicValue)) {\n        // UNCHECK\n        var removeItemIndex = currentSelectedWebcomics.indexOf(selectedWebcomicValue);\n        currentSelectedWebcomics.splice(removeItemIndex, 1);\n        this.setState({\n          selectedWebcomics: currentSelectedWebcomics\n        });\n      } else {\n        // CHECK\n        this.setState(function (currentState) {\n          return {\n            selectedWebcomics: [].concat(_toConsumableArray(currentState.selectedWebcomics), [selectedWebcomicValue])\n          };\n        });\n      }\n    } // =========\n    // # METHODS\n    // =========\n    // TOGGLE\n    // "Begin Slice" Text\n\n  }, {\n    key: "toggleBeginSliceText",\n    value: function toggleBeginSliceText() {\n      if (this.state.sliceText === "slice-btn") {\n        this.setState({\n          sliceText: "icon-spinner8 animate-spin"\n        });\n      } else if (this.state.sliceText === "icon-spinner8 animate-spin") {\n        this.setState({\n          sliceText: "slice-btn"\n        });\n      }\n    } // FETCHING FILE READ\n    // - VALIDATE file on upload\n    // - UPDATE state "inputField"\n    // - TOGGLE class\n\n  }, {\n    key: "handleFileDrop",\n    value: function handleFileDrop(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      var files = e.dataTransfer.files;\n      this.setFilesData(files); // UPDATE data boolean (for other chain reactions)\n\n      if (this.state.inputField) {\n        this.setState({\n          inputDataAvailable: true\n        });\n      }\n\n      this.setState({\n        isDragOver: false\n      });\n    }\n  }, {\n    key: "setFilesData",\n    value: function setFilesData(files) {\n      var _this4 = this;\n\n      Object.values(files).forEach(function (obj) {\n        // VALIDATE\n        if (!validFileType(obj.type)) {\n          // ALERT MESSAGE\n          // User attempted to upload unacceptable files\n          _this4.setState({\n            alertMessageError: alertMessages.onError.unacceptableFileType,\n            isAlertMessageError: true\n          });\n\n          setTimeout(function () {\n            _this4.setState({\n              alertMessageError: "",\n              isAlertMessageError: false\n            });\n          }, 8000);\n        } else {\n          // CREATE image file data preview container\n          _this4.setState(function (currentState) {\n            return {\n              inputField: [].concat(_toConsumableArray(currentState.inputField), [{\n                fileRead: obj,\n                id: generateUniqueId(),\n                fileSize: obj.size\n              }])\n            };\n          }); // UPDATE state \'totalFileSize\'\n\n\n          _this4.setState(function (currentState) {\n            // GET main data\n            var sourceInputField = currentState.inputField; // GET main data \'fileSize\'\n\n            var fileSizesArr = sourceInputField.map(function (file) {\n              return file.fileSize;\n            }); // TOTAL main data \'fileSize\'\n\n            var totalFileByte = fileSizesArr.reduce(function (accumulator, currentValue) {\n              return accumulator + currentValue;\n            });\n            return {\n              totalFileSize: totalFileByte\n            }; // CHECK CONDITION\n          }, _this4.checkTotalFileSize());\n        }\n      });\n    } // CHECK CONDITION\n    // UPDATE UI if CONDITION are met\n\n  }, {\n    key: "checkTotalFileSize",\n    value: function checkTotalFileSize() {\n      // ALERT MESSAGE\n      // CONDITION\n      // near max, pass 18MB\n      if (this.state.totalFileSize >= 18874368) {\n        this.setState({\n          isAlertMessageWarning: true,\n          alertMessageWarning: alertMessages.onWarning.nearMaxFileSize\n        });\n      } // ALERT MESSAGE\n      // CONDITION\n      // over max, pass 20MB\n\n\n      if (this.state.totalFileSize >= 20971520) {\n        this.setState({\n          isAlertMessageError: true,\n          alertMessageError: alertMessages.onError.overMaxFileSize\n        });\n      }\n    } // PROCESS IMAGE FILES\n\n  }, {\n    key: "processResults",\n    value: function processResults() {\n      var _this5 = this;\n\n      // GET all image file elements\n      var sourceImagesRaw = document.querySelectorAll(".preview__thumbnail img"); // REFERENCE the canvas\n\n      var canvas = document.querySelector("#canvas");\n      var context = canvas.getContext("2d"); // TRANSFORM node into JavaScript objects (array)\n\n      var sourceImages = Array.from(sourceImagesRaw); // GET user selected webcomic platform(s) from SELECT form component\n\n      var Selectedwebcomics = this.state.selectedWebcomics; // # (1) SELECT form\n      // PROCESS files for all selected webcomic platform applied\n\n      var _loop = function _loop(i) {\n        var processImages = []; // PROCESS image file\n\n        sourceImages.forEach(function (img) {\n          var imgWidth = img.naturalWidth;\n          var imgHeight = img.naturalHeight; // * CONDITION: image width > image height\n          // ROTATE image\n\n          if (imgWidth > imgHeight) {\n            // NOTE:\n            // Bottom surface would be pointed left, and\n            // Top surface would be pointed right\n            canvas.width = imgHeight;\n            canvas.height = imgWidth;\n            context.rotate(Math.PI / 2);\n            context.drawImage(img, 0, -imgHeight);\n          }\n\n          var maxHeight = imgHeight;\n          var width = imgWidth;\n          var scaleWidth; // # (2) OPTIONS form - "SQUASH"\n\n          switch (_this5.state.selectedSquashLevel) {\n            case "none":\n              scaleWidth = width;\n              break;\n\n            case 400:\n              scaleWidth = 400;\n              break;\n\n            case 500:\n              scaleWidth = 500;\n              break;\n\n            case 600:\n              scaleWidth = 600;\n              break;\n\n            case 700:\n              scaleWidth = 700;\n              break;\n          }\n\n          var webcomicMaxWidth;\n          var webcomicMaxHeight; // TODO: FEATURE (NEXT UPDATE)\n          // Find out normal tapas ratio\n          // Current Webcomic Platform Available...\n          // ! tapas in the works... (WIP)\n\n          switch (Selectedwebcomics[i]) {\n            case "webtoon":\n              webcomicMaxWidth = 800;\n              webcomicMaxHeight = 1280;\n              break;\n\n            case "tapas":\n              webcomicMaxWidth = 960;\n              webcomicMaxHeight = 1440;\n              break;\n          }\n\n          var aspectRatio = webcomicMaxWidth / webcomicMaxHeight; // based on aspect ratio, what the height should be...\n\n          var determinedeHeight = width / aspectRatio;\n          var scaleDeterminedeHeight = determinedeHeight;\n\n          if (scaleWidth !== width) {\n            scaleDeterminedeHeight = scaleWidth / aspectRatio;\n          } // * CONDITION:\n          // If file image naturalHeight is shorter than determinedHeight,\n          // return as is... unless Options scale applied\n\n\n          if (determinedeHeight > maxHeight) {\n            var scaleMaxHeight = scaleWidth / (width / maxHeight);\n            canvas.width = scaleWidth;\n            canvas.height = scaleMaxHeight;\n            context.drawImage(img, 0, 0, scaleWidth, scaleMaxHeight);\n            var result = canvas.toDataURL();\n            processImages.push(result);\n          } else {\n            var timesToSlice = Math.floor(maxHeight / determinedeHeight);\n            var currentSlice = 0;\n            var newYPosition = 0;\n            var slicedImages = []; // * CONDITION: Longer length (height) images\n\n            while (timesToSlice > currentSlice) {\n              newYPosition = determinedeHeight * currentSlice;\n              canvas.width = scaleWidth;\n              canvas.height = scaleDeterminedeHeight;\n              context.drawImage(img, 0, newYPosition, width, determinedeHeight, 0, 0, scaleWidth, scaleDeterminedeHeight);\n              slicedImages.push(canvas.toDataURL());\n              currentSlice++;\n            } // * CONDTION: Odd number remaining\n            // GET last coordinate\n            // GET remaining height\n\n\n            var remainCoordinateY = timesToSlice * determinedeHeight;\n            var remainHeight = maxHeight - remainCoordinateY; // OPTIONS Squash - if available\n\n            var scaleRemaineHeight = remainHeight;\n\n            if (scaleWidth !== width) {\n              scaleRemaineHeight = scaleWidth / (width / remainHeight);\n            }\n\n            if (remainHeight !== 0) {\n              newYPosition = remainCoordinateY; // ? Refactor to a function\n\n              canvas.width = scaleWidth;\n              canvas.height = scaleRemaineHeight;\n              context.drawImage(img, 0, newYPosition, width, remainHeight, 0, 0, scaleWidth, scaleRemaineHeight);\n              slicedImages.push(canvas.toDataURL());\n            }\n\n            processImages.push.apply(processImages, slicedImages);\n          }\n        }); // CREATE Zip folder\n        // NAME images with padded zero if under 10s\n        // GET user file extension prefernce from Options form - File Extensions\n        // PUSH images to Zip folder\n        // DOWNLOAD to user\'s PC\n\n        var zip = new JSZip();\n        var selectedFileExt = _this5.state.selectedFileExtension; // NOTE: Naming is padded with zero of tens\n        // Over tens are unavailable\n\n        for (var _i2 = 0; _i2 < processImages.length; _i2++) {\n          var fileName = void 0;\n\n          if (_i2 > 10) {\n            fileName = "".concat(_i2, ".").concat(selectedFileExt);\n          } else {\n            fileName = "".concat(_i2.toString().padStart(2, "0"), ".").concat(selectedFileExt);\n          }\n\n          zip.file(fileName, processImages[_i2].substr(processImages[_i2].indexOf(\',\') + 1), {\n            base64: true\n          });\n        }\n\n        zip.generateAsync({\n          type: "blob",\n          mimeType: "image/jpeg"\n        }).then(function (blob) {\n          saveAs(blob, "".concat(Selectedwebcomics[i], ".zip"));\n        }); // ADD image \'data:\' url arr of processed image files\n        // RESPONDS to display in Result form\n\n        _this5.setState({\n          processedFileData: processImages\n        });\n      };\n\n      for (var i = 0; i < Selectedwebcomics.length; i++) {\n        _loop(i);\n      } // ALERT MESSAGE\n      // Process completed\n\n\n      this.setState({\n        isAlertMessageSuccessOnBeginSliceBtn: true,\n        alertMessageSuccessOnBeginSliceBtn: alertMessages.onSuccess.completedProcess\n      });\n      setTimeout(function () {\n        _this5.setState({\n          isAlertMessageSuccessOnBeginSliceBtn: false,\n          alertMessageSuccessOnBeginSliceBtn: ""\n        });\n      }, 8000);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return /*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h2", {\n          children: "Start Here"\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FormUpload // EVENTS\n        , {\n          onHandleDrag: this.handleDrag,\n          onHandleDragLeave: this.handleDragLeave,\n          onHandleFileDrop: this.handleFileDrop,\n          onRemoveSelf: this.handleRemoveSelf,\n          onhandleDragEnd: this.handleDragEnd,\n          onHandleClickToUpload: this.handleClickToUpload,\n          onHandleInputChange: this.handleInputChange,\n          onHandleClickToRemoveAll: this.handleClickToRemoveAll // STYLED EVENTS\n          ,\n          toggleDropzoneBordersClass: this.state.isDragOver ? this.state.dropzoneBordersClass.highlight : this.state.dropzoneBordersClass.default,\n          togglePreviewWrapperClass: this.state.inputDataAvailable ? this.state.previewWrapperClass.visible : this.state.previewWrapperClass.invisible // ALERT MESSAGES\n          ,\n          getAlertErrorText: this.state.alertMessageError,\n          isAlertMessageError: this.state.isAlertMessageError,\n          getAlertSuccessText: this.state.alertMessageSuccess,\n          isAlertMessageSuccess: this.state.isAlertMessageSuccess,\n          isAlertMessageWarning: this.state.isAlertMessageWarning,\n          getAlertWarningText: this.state.alertMessageWarning // DATAS\n          ,\n          inputField: this.state.inputField,\n          getTotalFileSize: this.state.totalFileSize\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FormSelect, {\n          getWebcomicsModel: webcomicsModel,\n          onHandleSelectedWebcomic: this.handleSelectedWebcomic,\n          isAlertMessageSelectFormError: this.state.isAlertMessageErrorOnSelectForm,\n          getAlertMessageSelectFormText: this.state.alertMessageErrorOnSelectForm\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)(FormOptions, {\n          getFilExtensionsModel: filExtensionsModel,\n          onHandleOptionsFileExtenions: this.handleOptionsFileExtenions,\n          getSquashLevelModel: squashLevelModel,\n          onHandleOptionsSquashLevel: this.handleOptionsSquashLevel\n        }), /*#__PURE__*/(0,jsx_runtime.jsx)("div", {\n          className: "slice-btn-container",\n          children: /*#__PURE__*/(0,jsx_runtime.jsx)("a", {\n            className: "slice-btn",\n            onClick: this.handleBeginSlicBtn,\n            children: /*#__PURE__*/(0,jsx_runtime.jsx)("h3", {\n              children: this.state.sliceText === "slice-btn" ? "Begin Slice!" : /*#__PURE__*/(0,jsx_runtime.jsx)("i", {\n                className: "icon-spinner8 animate-spin"\n              })\n            })\n          })\n        }), this.state.isAlertMessageErrorOnBeginSliceBtn === true ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: "alert-message--error",\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("i", {\n            className: "alert-icon alert-icon--error icon-warning"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: "alert-message-text--error",\n            children: this.state.alertMessageErrorOnBeginSliceBtn\n          })]\n        }) : null, this.state.isAlertMessageSuccessOnBeginSliceBtn === true ? /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {\n          className: "alert-message--success",\n          children: [/*#__PURE__*/(0,jsx_runtime.jsx)("i", {\n            className: "alert-icon alert-icon--success icon-check"\n          }), /*#__PURE__*/(0,jsx_runtime.jsx)("span", {\n            className: "alert-message-text--success",\n            children: this.state.alertMessageSuccessOnBeginSliceBtn\n          })]\n        }) : null, /*#__PURE__*/(0,jsx_runtime.jsx)(FormResults, {\n          getImageData: this.state.processedFileData\n        })]\n      });\n    }\n  }]);\n\n  return Form;\n}(react.Component);\n\n\n;// CONCATENATED MODULE: ./src/form.js\n\n\n\n\nreact_dom.render( /*#__PURE__*/(0,jsx_runtime.jsx)(Form, {}), document.querySelector("main"));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9zcmMvc2NyaXB0cy9saWJzL2NvbnZlcnRCeXRlcy5qcz9kMGI1Iiwid2VicGFjazovL3N1cGVyLWNvbWljLXNsaWNlci8uL3NyYy9zY3JpcHRzL2NvbXBvbmVudHMvRm9ybVVwbG9hZC5qcz8wODAwIiwid2VicGFjazovL3N1cGVyLWNvbWljLXNsaWNlci8uL3NyYy9zY3JpcHRzL2NvbXBvbmVudHMvRm9ybVNlbGVjdC5qcz82MjE0Iiwid2VicGFjazovL3N1cGVyLWNvbWljLXNsaWNlci8uL3NyYy9zY3JpcHRzL2NvbXBvbmVudHMvRm9ybU9wdGlvbnMuanM/MWY5OCIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9zcmMvc2NyaXB0cy9jb21wb25lbnRzL0Zvcm1SZXN1bHRzLmpzPzg4ZmYiLCJ3ZWJwYWNrOi8vc3VwZXItY29taWMtc2xpY2VyLy4vc3JjL3NjcmlwdHMvbGlicy9jcmVhdGVJZC5qcz8zN2RkIiwid2VicGFjazovL3N1cGVyLWNvbWljLXNsaWNlci8uL3NyYy9zY3JpcHRzL2NvbXBvbmVudHMvRm9ybS5qcz80MzMwIiwid2VicGFjazovL3N1cGVyLWNvbWljLXNsaWNlci8uL3NyYy9mb3JtLmpzPzc2YjMiXSwibmFtZXMiOlsicmV0dXJuRmlsZVNpemUiLCJudW1iZXIiLCJ0b0ZpeGVkIiwiVGh1bWJuYWlscyIsInByb3BzIiwiZmlsZXMiLCJpbnB1dEZpZWxkIiwicHJldmlld1RodW1ibmFpbEVsZW1lbnRzIiwibWFwIiwiZmlsZSIsImluZGV4IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0RhdGFVUkwiLCJmaWxlUmVhZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXREYXRhVVJMIiwiY3VycmVudEVsZW1lbnQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsYXN0RWxlbWVudENoaWxkIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJzcmMiLCJyZXN1bHQiLCJpZCIsInRvU3RyaW5nIiwicHJvdmlkZWQiLCJKU09OIiwic3RyaW5naWZ5IiwibmFtZSIsImlubmVyUmVmIiwiZHJhZ2dhYmxlUHJvcHMiLCJkcmFnSGFuZGxlUHJvcHMiLCJlIiwib25SZW1vdmVTZWxmIiwiUHJldmlldyIsInRvZ2dsZVByZXZpZXdXcmFwcGVyQ2xhc3MiLCJvbmhhbmRsZURyYWdFbmQiLCJkcm9wcGFibGVQcm9wcyIsInBsYWNlaG9sZGVyIiwiY29udmVydEJ5dGVzIiwiZ2V0VG90YWxGaWxlU2l6ZSIsIm9uSGFuZGxlQ2xpY2tUb1JlbW92ZUFsbCIsIkRyb3B6b25lIiwidG9nZ2xlRHJvcHpvbmVCb3JkZXJzQ2xhc3MiLCJvbkhhbmRsZURyYWciLCJvbkhhbmRsZURyYWdMZWF2ZSIsIm9uSGFuZGxlRmlsZURyb3AiLCJvbkhhbmRsZUNsaWNrVG9VcGxvYWQiLCJvbkhhbmRsZUlucHV0Q2hhbmdlIiwiRm9ybVVwbG9hZCIsIm9uSGFuZGxlQ2hhbmdlIiwiaXNBbGVydE1lc3NhZ2VFcnJvciIsImdldEFsZXJ0RXJyb3JUZXh0IiwiaXNBbGVydE1lc3NhZ2VTdWNjZXNzIiwiZ2V0QWxlcnRTdWNjZXNzVGV4dCIsImlzQWxlcnRNZXNzYWdlV2FybmluZyIsImdldEFsZXJ0V2FybmluZ1RleHQiLCJsZW5ndGgiLCJXZWJjb21pY3NPcHRpb25zIiwid2ViY29taWNzTGlzdCIsImdldFdlYmNvbWljc01vZGVsIiwiY3VycmVudFdlYmNvbWljIiwidGFiaW5kZXgiLCJkaXNhYmxlZCIsImh0bWxMYWJlbCIsImltYWdlU291cmNlIiwiaHRtbEFsdCIsInRleHQiLCJvbkhhbmRsZVNlbGVjdGVkV2ViY29taWMiLCJGb3JtU2VsZWN0IiwiaXNBbGVydE1lc3NhZ2VTZWxlY3RGb3JtRXJyb3IiLCJnZXRBbGVydE1lc3NhZ2VTZWxlY3RGb3JtVGV4dCIsIlNxdWFzaE9wdGlvbnMiLCJzcXVhc2hMZXZlbExpc3QiLCJnZXRTcXVhc2hMZXZlbE1vZGVsIiwiY3VycmVudFNxdWFzaExldmVsIiwicGl4ZWxWYWx1ZSIsIm9uSGFuZGxlT3B0aW9uc1NxdWFzaExldmVsIiwiRmlsZUV4dGVuc2lvbk9wdGlvbnMiLCJmaWxlRXh0ZW5zaW9uc0xpc3QiLCJnZXRGaWxFeHRlbnNpb25zTW9kZWwiLCJmaWxlRXh0T2JqIiwib25IYW5kbGVPcHRpb25zRmlsZUV4dGVuaW9ucyIsIkZvcm1PcHRpb25zIiwiUHJvZHVjdCIsInByb2Nlc3NlZEltYWdlRklsZXMiLCJnZXRJbWFnZURhdGEiLCJpbWdEYXRhIiwiRm9ybVJlc3VsdHMiLCJnZW5lcmF0ZVVuaXF1ZUlkIiwid2luZG93IiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiVWludDMyQXJyYXkiLCJNYXRoIiwicmFuZG9tIiwiYWxlcnRNZXNzYWdlcyIsIm9uU3VjY2VzcyIsImZpbGVzUmVtb3ZlZCIsImNvbXBsZXRlZFByb2Nlc3MiLCJvbkVycm9yIiwidW5hY2NlcHRhYmxlRmlsZVR5cGUiLCJvdmVyTWF4RmlsZVNpemUiLCJub0ZpbGVzRm91bmQiLCJzZWxlY3RGb3JtTWFuZGF0b3J5Iiwic2VsZWN0Rm9ybU1hbmRhdG9yeVRhcmdldCIsIm9uV2FybmluZyIsIm5lYXJNYXhGaWxlU2l6ZSIsIndlYmNvbWljc01vZGVsIiwiZmlsRXh0ZW5zaW9uc01vZGVsIiwic3F1YXNoTGV2ZWxNb2RlbCIsImZpbGVUeXBlcyIsInZhbGlkRmlsZVR5cGUiLCJpbmNsdWRlcyIsIkZvcm0iLCJzdGF0ZSIsImlzRHJhZ092ZXIiLCJkcm9wem9uZUJvcmRlcnNDbGFzcyIsImhpZ2hsaWdodCIsImRlZmF1bHQiLCJpbnB1dERhdGFBdmFpbGFibGUiLCJzbGljZVRleHQiLCJwcmV2aWV3V3JhcHBlckNsYXNzIiwidmlzaWJsZSIsImludmlzaWJsZSIsImFsZXJ0TWVzc2FnZVN1Y2Nlc3MiLCJhbGVydE1lc3NhZ2VFcnJvciIsImFsZXJ0TWVzc2FnZVdhcm5pbmciLCJpc0FsZXJ0TWVzc2FnZUVycm9yT25CZWdpblNsaWNlQnRuIiwiYWxlcnRNZXNzYWdlRXJyb3JPbkJlZ2luU2xpY2VCdG4iLCJpc0FsZXJ0TWVzc2FnZVN1Y2Nlc3NPbkJlZ2luU2xpY2VCdG4iLCJhbGVydE1lc3NhZ2VTdWNjZXNzT25CZWdpblNsaWNlQnRuIiwiaXNBbGVydE1lc3NhZ2VFcnJvck9uU2VsZWN0Rm9ybSIsImFsZXJ0TWVzc2FnZUVycm9yT25TZWxlY3RGb3JtIiwicHJvY2Vzc2VkRmlsZURhdGEiLCJ0b3RhbEZpbGVTaXplIiwic2VsZWN0ZWRXZWJjb21pY3MiLCJzZWxlY3RlZEZpbGVFeHRlbnNpb24iLCJzZWxlY3RlZFNxdWFzaExldmVsIiwiaGFuZGxlRHJhZyIsImJpbmQiLCJoYW5kbGVEcmFnTGVhdmUiLCJoYW5kbGVGaWxlRHJvcCIsInByb2Nlc3NSZXN1bHRzIiwiaGFuZGxlQmVnaW5TbGljQnRuIiwidG9nZ2xlQmVnaW5TbGljZVRleHQiLCJoYW5kbGVEcmFnRW5kIiwiaGFuZGxlUmVtb3ZlU2VsZiIsImhhbmRsZUNsaWNrVG9SZW1vdmVBbGwiLCJzZXRGaWxlc0RhdGEiLCJjaGVja1RvdGFsRmlsZVNpemUiLCJoYW5kbGVJbnB1dENoYW5nZSIsImhhbmRsZVNlbGVjdGVkV2ViY29taWMiLCJoYW5kbGVPcHRpb25zRmlsZUV4dGVuaW9ucyIsImhhbmRsZU9wdGlvbnNTcXVhc2hMZXZlbCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwic2V0U3RhdGUiLCJpdGVtcyIsIkFycmF5IiwiZnJvbSIsInNwbGljZSIsInNvdXJjZSIsInJlb3JkZXJlZEl0ZW0iLCJkZXN0aW5hdGlvbiIsImRyb3B6b25lSW5wdXQiLCJxdWVyeVNlbGVjdG9yIiwiY2xpY2siLCJuZXdTZWxlY3RlZEZpbGVFeHRlbnNpb24iLCJ0YXJnZXQiLCJ2YWx1ZSIsIm5ld1NlbGVjdGVkU3F1YXNoTGV2ZWwiLCJwYXJzZUludCIsInNldFRpbWVvdXQiLCJzb3VyY2VUaHVtYm5haWxzIiwiYXJyVGh1bWJuYWlscyIsInJlbW92ZUl0ZW1JbmRleCIsImluZGV4T2YiLCJwYXJlbnRFbGVtZW50IiwiY3VycmVudFN0YXRlIiwic291cmNlSW5wdXRGaWVsZCIsImZpbGVTaXplc0FyciIsImZpbGVTaXplIiwidG90YWxGaWxlQnl0ZSIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwicmVtb3ZlZEl0ZW1GaWxlU2l6ZSIsIm5ld1RvdGFsRmlsZVNpemUiLCJzZWxlY3RlZFdlYmNvbWljVmFsdWUiLCJjdXJyZW50U2VsZWN0ZWRXZWJjb21pY3MiLCJkYXRhVHJhbnNmZXIiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwib2JqIiwidHlwZSIsImNyZWF0ZUlkIiwic2l6ZSIsInNvdXJjZUltYWdlc1JhdyIsImNhbnZhcyIsImNvbnRleHQiLCJnZXRDb250ZXh0Iiwic291cmNlSW1hZ2VzIiwiU2VsZWN0ZWR3ZWJjb21pY3MiLCJpIiwicHJvY2Vzc0ltYWdlcyIsImltZyIsImltZ1dpZHRoIiwibmF0dXJhbFdpZHRoIiwiaW1nSGVpZ2h0IiwibmF0dXJhbEhlaWdodCIsIndpZHRoIiwiaGVpZ2h0Iiwicm90YXRlIiwiUEkiLCJkcmF3SW1hZ2UiLCJtYXhIZWlnaHQiLCJzY2FsZVdpZHRoIiwid2ViY29taWNNYXhXaWR0aCIsIndlYmNvbWljTWF4SGVpZ2h0IiwiYXNwZWN0UmF0aW8iLCJkZXRlcm1pbmVkZUhlaWdodCIsInNjYWxlRGV0ZXJtaW5lZGVIZWlnaHQiLCJzY2FsZU1heEhlaWdodCIsInRvRGF0YVVSTCIsInB1c2giLCJ0aW1lc1RvU2xpY2UiLCJmbG9vciIsImN1cnJlbnRTbGljZSIsIm5ld1lQb3NpdGlvbiIsInNsaWNlZEltYWdlcyIsInJlbWFpbkNvb3JkaW5hdGVZIiwicmVtYWluSGVpZ2h0Iiwic2NhbGVSZW1haW5lSGVpZ2h0IiwiemlwIiwiSlNaaXAiLCJzZWxlY3RlZEZpbGVFeHQiLCJmaWxlTmFtZSIsInBhZFN0YXJ0Iiwic3Vic3RyIiwiYmFzZTY0IiwiZ2VuZXJhdGVBc3luYyIsIm1pbWVUeXBlIiwidGhlbiIsImJsb2IiLCJzYXZlQXMiLCJoYW5kbGVD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QU9LLElBbEVWLGVBbUVJLG9CQUFDLFdBQUQ7QUFDSSxzQkFBWSxFQUFFLEtBQUtoQixLQUFMLENBQVdtQjtBQUQ3QixVQW5FSjtBQUFBLFFBREo7QUF5RUg7Ozs7RUFsdkI2QmtILGU7Ozs7QUN0R2xDO0FBQ0E7QUFDQTs7QUFFQUMsZ0JBQUEsZUFDSSxvQkFBQyxJQUFELEtBREosRUFFSXhPLFFBQVEsQ0FBQ3FKLGFBQVQsQ0FBdUIsTUFBdkIsQ0FGSiIsImZpbGUiOiIzNTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXR1cm5GaWxlU2l6ZShudW1iZXIpIHtcclxuICAgIGlmIChudW1iZXIgPCAxMDI0KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdieXRlcyc7XHJcbiAgICB9IGVsc2UgaWYgKG51bWJlciA+PSAxMDI0ICYmIG51bWJlciA8IDEwNDg1NzYpIHtcclxuICAgICAgICByZXR1cm4gKG51bWJlciAvIDEwMjQpLnRvRml4ZWQoMSkgKyAnS0InO1xyXG4gICAgfSBlbHNlIGlmIChudW1iZXIgPj0gMTA0ODU3Nikge1xyXG4gICAgICAgIHJldHVybiAobnVtYmVyIC8gMTA0ODU3NikudG9GaXhlZCgxKSArICdNQic7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBEcmFnRHJvcENvbnRleHQsIERyb3BwYWJsZSwgRHJhZ2dhYmxlIH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XHJcbi8vIGxpYnNcclxuaW1wb3J0IGNvbnZlcnRCeXRlcyBmcm9tICcuLi9saWJzL2NvbnZlcnRCeXRlcyc7XHJcblxyXG4vLyBUT0RPOiBGRUFUVVJFIChORVhUIFVQREFURSlcclxuLy8gXCJSb3RhdGVcIiBidXR0b24gaW4gUHJldmlldyB0aHVtYlxyXG4vLyBBbHNvIHNlZSBpbiAnRm9ybS5qcydcclxuLy8gPyBidWxsZXQgcG9pbnQgZ3VpZGVsaW5lcyBpbnN0ZWFkIG9mIG9uZSBsaW5lIHBhcmFncmFwaFxyXG5cclxuZnVuY3Rpb24gVGh1bWJuYWlscyhwcm9wcykge1xyXG4gICAgY29uc3QgZmlsZXMgPSBwcm9wcy5pbnB1dEZpZWxkO1xyXG5cclxuICAgIGxldCBwcmV2aWV3VGh1bWJuYWlsRWxlbWVudHM7XHJcblxyXG4gICAgaWYgKGZpbGVzKSB7XHJcblxyXG4gICAgICAgIHByZXZpZXdUaHVtYm5haWxFbGVtZW50cyA9IGZpbGVzLm1hcCgoZmlsZSwgaW5kZXgpID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUuZmlsZVJlYWQpO1xyXG4gICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZ2V0RGF0YVVSTClcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldERhdGFVUkwoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIucHJldmlld19fdGh1bWJuYWlsLWNvbnRhaW5lclwiKVtpbmRleF0ubGFzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZDtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudC5zcmMgPSByZWFkZXIucmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPERyYWdnYWJsZSBrZXk9e2ZpbGUuaWR9IGRyYWdnYWJsZUlkPXtmaWxlLmlkLnRvU3RyaW5nKCl9IGluZGV4PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvdmlkZWQpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwcmV2aWV3X190aHVtYm5haWwtY29udGFpbmVyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWxhYmVsPXtKU09OLnN0cmluZ2lmeShmaWxlLmZpbGVSZWFkLm5hbWUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdnYWJsZVByb3BzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5wcm92aWRlZC5kcmFnSGFuZGxlUHJvcHN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJjbG9zZS1idG5cIiBvbkNsaWNrPXsoZSkgPT4gcHJvcHMub25SZW1vdmVTZWxmKGUpfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uLXJlbW92ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwYXRoMVwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGF0aDJcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBhdGgzXCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcmV2aWV3X190aHVtYm5haWxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBhbHQ9XCJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcmV2aWV3VGh1bWJuYWlsRWxlbWVudHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFByZXZpZXcocHJvcHMpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3Byb3BzLnRvZ2dsZVByZXZpZXdXcmFwcGVyQ2xhc3N9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInByZXZpZXctY29udGFpbmVyXCI+XHJcblxyXG4gICAgICAgICAgICAgICAgPERyYWdEcm9wQ29udGV4dCBvbkRyYWdFbmQ9e3Byb3BzLm9uaGFuZGxlRHJhZ0VuZH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPERyb3BwYWJsZSBkcm9wcGFibGVJZD1cInByZXZpZXdcIiBkaXJlY3Rpb249XCJob3Jpem9udGFsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsocHJvdmlkZWQpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJldmlld1wiIHsuLi5wcm92aWRlZC5kcm9wcGFibGVQcm9wc30gcmVmPXtwcm92aWRlZC5pbm5lclJlZn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRodW1ibmFpbHMgaW5wdXRGaWVsZD17cHJvcHMuaW5wdXRGaWVsZH0gb25SZW1vdmVTZWxmPXtwcm9wcy5vblJlbW92ZVNlbGZ9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9Ecm9wcGFibGU+XHJcbiAgICAgICAgICAgICAgICA8L0RyYWdEcm9wQ29udGV4dD5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJldmlld19fY2xlYXItYnRuLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmlsZS1zaXplX19jb250YWluZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmlsZS1zaXplLXRleHRcIj5Ub3RhbCBGaWxlIFNpemU6IHtjb252ZXJ0Qnl0ZXMocHJvcHMuZ2V0VG90YWxGaWxlU2l6ZSl9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwicHJldmlld19fY2xlYXItYnRuXCIgb25DbGljaz17cHJvcHMub25IYW5kbGVDbGlja1RvUmVtb3ZlQWxsfT5DbGVhciBGaWxlczwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBEcm9wem9uZShwcm9wcykge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRyb3B6b25lLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3Byb3BzLnRvZ2dsZURyb3B6b25lQm9yZGVyc0NsYXNzfVxyXG4gICAgICAgICAgICAgICAgb25EcmFnT3Zlcj17KGUpID0+IHByb3BzLm9uSGFuZGxlRHJhZyhlKX1cclxuICAgICAgICAgICAgICAgIG9uRHJhZ0VudGVyPXsoZSkgPT4gcHJvcHMub25IYW5kbGVEcmFnKGUpfVxyXG4gICAgICAgICAgICAgICAgb25EcmFnRW5kPXsoZSkgPT4gcHJvcHMub25IYW5kbGVEcmFnTGVhdmUoZSl9XHJcbiAgICAgICAgICAgICAgICBvbkRyYWdMZWF2ZT17KGUpID0+IHByb3BzLm9uSGFuZGxlRHJhZ0xlYXZlKGUpfVxyXG4gICAgICAgICAgICAgICAgb25Ecm9wPXsoZSkgPT4gcHJvcHMub25IYW5kbGVGaWxlRHJvcChlKX1cclxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLm9uSGFuZGxlQ2xpY2tUb1VwbG9hZH1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZHJvcHpvbmVfX3VwbG9hZC1pY29uIGljb24tdXBsb2FkXCI+PC9pPlxyXG5cclxuICAgICAgICAgICAgICAgIDxwPkRyYWcgJiBEcm9wIG9yIENsaWNrIGhlcmU8L3A+XHJcbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtYWxsXCI+dG8gdXBsb2FkIHlvdXIgZmlsZXMgKG1heC4gMjBNQik8L3A+XHJcblxyXG4gICAgICAgICAgICAgICAgPGlucHV0IG9uQ2hhbmdlPXsoZSkgPT4gcHJvcHMub25IYW5kbGVJbnB1dENoYW5nZShlKX0gY2xhc3NOYW1lPVwiZHJvcHpvbmVfX2lucHV0XCIgdHlwZT1cImZpbGVcIiBhY2NlcHQ9XCJpbWFnZS9wbmcsIGltYWdlL2pwZWdcIiBtdWx0aXBsZSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZvcm1VcGxvYWQocHJvcHMpIHtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImZvcm0tdXBsb2FkXCI+XHJcblxyXG4gICAgICAgICAgICA8aDM+MS4gVXBsb2FkPC9oMz5cclxuXHJcbiAgICAgICAgICAgIDxwPkN1cnJlbnRseSwgUE5HIGFuZCBKUEVHIChpbmNsdWRpbmcgSlBHKSBhcmUgYWNjZXB0ZWQuIElmIHdpZHRoIG9mIGltYWdlIGlzIGxhcmdlciB0aGFuIGhlaWdodCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBpcyB1bmxlc3MgT3B0aW9ucyBTcXVhc2ggY2hvc2VuLjwvcD5cclxuXHJcbiAgICAgICAgICAgIDxEcm9wem9uZVxyXG4gICAgICAgICAgICAgICAgLy8gRVZFTlRTXHJcbiAgICAgICAgICAgICAgICBvbkhhbmRsZURyYWc9e3Byb3BzLm9uSGFuZGxlRHJhZ31cclxuICAgICAgICAgICAgICAgIG9uSGFuZGxlRHJhZ0xlYXZlPXsoZSkgPT4gcHJvcHMub25IYW5kbGVEcmFnTGVhdmUoZSl9XHJcbiAgICAgICAgICAgICAgICBvbkhhbmRsZUZpbGVEcm9wPXsoZSkgPT4gcHJvcHMub25IYW5kbGVGaWxlRHJvcChlKX1cclxuICAgICAgICAgICAgICAgIG9uSGFuZGxlSW5wdXRDaGFuZ2U9eyhlKSA9PiBwcm9wcy5vbkhhbmRsZUlucHV0Q2hhbmdlKGUpfVxyXG4gICAgICAgICAgICAgICAgb25IYW5kbGVDbGlja1RvVXBsb2FkPXtwcm9wcy5vbkhhbmRsZUNsaWNrVG9VcGxvYWR9XHJcbiAgICAgICAgICAgICAgICBvbkhhbmRsZUNoYW5nZT17cHJvcHMub25IYW5kbGVDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAvLyBTVFlMRSBFVkVOVFNcclxuICAgICAgICAgICAgICAgIHRvZ2dsZURyb3B6b25lQm9yZGVyc0NsYXNzPXtwcm9wcy50b2dnbGVEcm9wem9uZUJvcmRlcnNDbGFzc31cclxuICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgIHtwcm9wcy5pc0FsZXJ0TWVzc2FnZUVycm9yID09PSB0cnVlXHJcbiAgICAgICAgICAgICAgICA/IDxkaXYgY2xhc3NOYW1lPVwiYWxlcnQtbWVzc2FnZS0tZXJyb3JcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJhbGVydC1pY29uIGFsZXJ0LWljb24tLWVycm9yIGljb24td2FybmluZ1wiPjwvaT5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhbGVydC1tZXNzYWdlLXRleHQtLWVycm9yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtwcm9wcy5nZXRBbGVydEVycm9yVGV4dH1cclxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDogbnVsbH1cclxuXHJcbiAgICAgICAgICAgIHtwcm9wcy5pc0FsZXJ0TWVzc2FnZVN1Y2Nlc3MgPT09IHRydWVcclxuICAgICAgICAgICAgICAgID8gPGRpdiBjbGFzc05hbWU9XCJhbGVydC1tZXNzYWdlLS1zdWNjZXNzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiYWxlcnQtaWNvbiBhbGVydC1pY29uLS1zdWNjZXNzIGljb24tY2hlY2tcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWxlcnQtbWVzc2FnZS10ZXh0LS1zdWNjZXNzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtwcm9wcy5nZXRBbGVydFN1Y2Nlc3NUZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgOiBudWxsfVxyXG5cclxuICAgICAgICAgICAge3Byb3BzLmlzQWxlcnRNZXNzYWdlV2FybmluZyA9PT0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgPyA8ZGl2IGNsYXNzTmFtZT1cImFsZXJ0LW1lc3NhZ2UtLXdhcm5pbmdcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJhbGVydC1pY29uIGFsZXJ0LWljb24tLXdhcm5pbmcgaWNvbi13YXJuaW5nXCI+PC9pPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFsZXJ0LW1lc3NhZ2UtdGV4dC0td2FybmluZ1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7cHJvcHMuZ2V0QWxlcnRXYXJuaW5nVGV4dH1cclxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDogbnVsbH1cclxuXHJcbiAgICAgICAgICAgIHtwcm9wcy5pbnB1dEZpZWxkLmxlbmd0aCAhPT0gMFxyXG4gICAgICAgICAgICAgICAgPyA8cD5JZiB5b3UgaGF2ZSBtb3JlIHRoYW4gb25lIGltYWdlIGZpbGUsIHlvdSBtYXkgZHJhZyBhbmQgcmUtb3JkZXIuPC9wPlxyXG4gICAgICAgICAgICAgICAgOiBudWxsfVxyXG5cclxuICAgICAgICAgICAge3Byb3BzLmlucHV0RmllbGQubGVuZ3RoICE9PSAwXHJcbiAgICAgICAgICAgICAgICA/IDxQcmV2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRGaWVsZD17cHJvcHMuaW5wdXRGaWVsZH1cclxuICAgICAgICAgICAgICAgICAgICBvbmhhbmRsZURyYWdFbmQ9e3Byb3BzLm9uaGFuZGxlRHJhZ0VuZH1cclxuICAgICAgICAgICAgICAgICAgICBvblJlbW92ZVNlbGY9e3Byb3BzLm9uUmVtb3ZlU2VsZn1cclxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVQcmV2aWV3V3JhcHBlckNsYXNzPXtwcm9wcy50b2dnbGVQcmV2aWV3V3JhcHBlckNsYXNzfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlQ2xpY2tUb1JlbW92ZUFsbD17cHJvcHMub25IYW5kbGVDbGlja1RvUmVtb3ZlQWxsfVxyXG4gICAgICAgICAgICAgICAgICAgIGdldFRvdGFsRmlsZVNpemU9e3Byb3BzLmdldFRvdGFsRmlsZVNpemV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgOiBudWxsfVxyXG5cclxuICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICApXHJcbn0iLCJmdW5jdGlvbiBXZWJjb21pY3NPcHRpb25zKHByb3BzKSB7XHJcblxyXG4gICAgY29uc3Qgd2ViY29taWNzTGlzdCA9IHByb3BzLmdldFdlYmNvbWljc01vZGVsLm1hcCgoY3VycmVudFdlYmNvbWljLCB0YWJpbmRleCkgPT4ge1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudFdlYmNvbWljLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNlbGVjdC1vcHRpb25cIiBrZXk9e3RhYmluZGV4fT5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17Y3VycmVudFdlYmNvbWljLmh0bWxMYWJlbH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VsZWN0LWxhYmVsLS13cmFwcGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9e2N1cnJlbnRXZWJjb21pYy5odG1sTGFiZWx9IGRpc2FibGVkIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzZWxlY3QtbGFiZWxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzTmFtZT1cInNlbGVjdC1pY29uXCIgc3JjPXtjdXJyZW50V2ViY29taWMuaW1hZ2VTb3VyY2V9IGFsdD17Y3VycmVudFdlYmNvbWljLmh0bWxBbHR9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic2VsZWN0LXRleHRcIj57Y3VycmVudFdlYmNvbWljLnRleHR9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzZWxlY3Qtb3B0aW9uXCIga2V5PXt0YWJpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2N1cnJlbnRXZWJjb21pYy5odG1sTGFiZWx9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNlbGVjdC1sYWJlbC0td3JhcHBlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD17Y3VycmVudFdlYmNvbWljLmh0bWxMYWJlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y3VycmVudFdlYmNvbWljLmh0bWxMYWJlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoZSkgPT4gcHJvcHMub25IYW5kbGVTZWxlY3RlZFdlYmNvbWljKGUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNlbGVjdC1sYWJlbFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPVwic2VsZWN0LWljb25cIiBzcmM9e2N1cnJlbnRXZWJjb21pYy5pbWFnZVNvdXJjZX0gYWx0PXtjdXJyZW50V2ViY29taWMuaHRtbEFsdH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzZWxlY3QtdGV4dFwiPntjdXJyZW50V2ViY29taWMudGV4dH08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB3ZWJjb21pY3NMaXN0O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGb3JtU2VsZWN0KHByb3BzKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImZvcm0tc2VsZWN0XCI+XHJcbiAgICAgICAgICAgIDxoMz4yLiBTZWxlY3Q8L2gzPlxyXG4gICAgICAgICAgICA8cD5TZWxlY3Qgd2ViY29taWMgcGxhdGZvcm0gdG8gYmFzZSBzbGljaW5nIHJhdGlvLiBZb3UgbWF5IHNlbGVjdCBtb3JlIHRoYW4gb25lLlxyXG4gICAgICAgICAgICAqQ3VycmVudGx5LCBXZWJ0b29uIGlzIG9ubHkgYXZhaWxhYmxlLjwvcD5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VsZWN0LWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgPFdlYmNvbWljc09wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBnZXRXZWJjb21pY3NNb2RlbD17cHJvcHMuZ2V0V2ViY29taWNzTW9kZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVTZWxlY3RlZFdlYmNvbWljPXtwcm9wcy5vbkhhbmRsZVNlbGVjdGVkV2ViY29taWN9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHsvKiBDT05ESVRJT04gKi99XHJcbiAgICAgICAgICAgIHtwcm9wcy5pc0FsZXJ0TWVzc2FnZVNlbGVjdEZvcm1FcnJvciA9PT0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgPyA8ZGl2IGNsYXNzTmFtZT1cImFsZXJ0LW1lc3NhZ2UtLWVycm9yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiYWxlcnQtaWNvbiBhbGVydC1pY29uLS1lcnJvciBpY29uLXdhcm5pbmdcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWxlcnQtbWVzc2FnZS10ZXh0LS1lcnJvclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7cHJvcHMuZ2V0QWxlcnRNZXNzYWdlU2VsZWN0Rm9ybVRleHR9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA6IG51bGx9XHJcbiAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgKVxyXG59IiwiZnVuY3Rpb24gU3F1YXNoT3B0aW9ucyhwcm9wcykge1xyXG5cclxuICAgIGNvbnN0IHNxdWFzaExldmVsTGlzdCA9IHByb3BzLmdldFNxdWFzaExldmVsTW9kZWwubWFwKChjdXJyZW50U3F1YXNoTGV2ZWwsIGluZGV4KSA9PiB7XHJcblxyXG4gICAgICAgIGlmIChwcm9wcy5nZXRTcXVhc2hMZXZlbE1vZGVsWzBdID09IGN1cnJlbnRTcXVhc2hMZXZlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYWRpby1vcHRpb25cIiBrZXk9e2luZGV4fT5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17Y3VycmVudFNxdWFzaExldmVsLmh0bWxMYWJlbH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwic3F1YXNoXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtjdXJyZW50U3F1YXNoTGV2ZWwucGl4ZWxWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPXtjdXJyZW50U3F1YXNoTGV2ZWwuaHRtbExhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHByb3BzLm9uSGFuZGxlT3B0aW9uc1NxdWFzaExldmVsKGUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzZWxlY3QtdGV4dFwiPntjdXJyZW50U3F1YXNoTGV2ZWwudGV4dH08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW8tb3B0aW9uXCIga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2N1cnJlbnRTcXVhc2hMZXZlbC5odG1sTGFiZWx9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwic3F1YXNoXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtjdXJyZW50U3F1YXNoTGV2ZWwucGl4ZWxWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPXtjdXJyZW50U3F1YXNoTGV2ZWwuaHRtbExhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHByb3BzLm9uSGFuZGxlT3B0aW9uc1NxdWFzaExldmVsKGUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzZWxlY3QtdGV4dFwiPntjdXJyZW50U3F1YXNoTGV2ZWwudGV4dH08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHNxdWFzaExldmVsTGlzdDtcclxufVxyXG5cclxuZnVuY3Rpb24gRmlsZUV4dGVuc2lvbk9wdGlvbnMocHJvcHMpIHtcclxuXHJcbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uc0xpc3QgPSBwcm9wcy5nZXRGaWxFeHRlbnNpb25zTW9kZWwubWFwKChmaWxlRXh0T2JqLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGlmIChwcm9wcy5nZXRGaWxFeHRlbnNpb25zTW9kZWxbMF0gPT09IGZpbGVFeHRPYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW8tb3B0aW9uXCIga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2ZpbGVFeHRPYmouaHRtbExhYmVsfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJmaWxldHlwZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmlsZUV4dE9iai5odG1sTGFiZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD17ZmlsZUV4dE9iai5odG1sTGFiZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoZSkgPT4gcHJvcHMub25IYW5kbGVPcHRpb25zRmlsZUV4dGVuaW9ucyhlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic2VsZWN0LXRleHRcIj57ZmlsZUV4dE9iai50ZXh0fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYWRpby1vcHRpb25cIiBrZXk9e2luZGV4fT5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17ZmlsZUV4dE9iai5odG1sTGFiZWx9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiZmlsZXR5cGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpbGVFeHRPYmouaHRtbExhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e2ZpbGVFeHRPYmouaHRtbExhYmVsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHByb3BzLm9uSGFuZGxlT3B0aW9uc0ZpbGVFeHRlbmlvbnMoZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNlbGVjdC10ZXh0XCI+e2ZpbGVFeHRPYmoudGV4dH08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGZpbGVFeHRlbnNpb25zTGlzdDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRm9ybU9wdGlvbnMocHJvcHMpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiZm9ybS1vcHRpb25zXCI+XHJcbiAgICAgICAgICAgIDxoMz4zLiBPcHRpb25zPC9oMz5cclxuXHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtYm9sZCBoZWFkZXItZm91clwiPkZpbGUgRXh0ZW5zaW9uczwvcD5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW8tY29udGFpbmVyLWZpbGV0eXBlXCI+XHJcbiAgICAgICAgICAgICAgICA8RmlsZUV4dGVuc2lvbk9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBnZXRGaWxFeHRlbnNpb25zTW9kZWw9e3Byb3BzLmdldEZpbEV4dGVuc2lvbnNNb2RlbH1cclxuICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZU9wdGlvbnNGaWxlRXh0ZW5pb25zPXtwcm9wcy5vbkhhbmRsZU9wdGlvbnNGaWxlRXh0ZW5pb25zfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG5cclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ib2xkIGhlYWRlci1mb3VyXCI+U3F1YXNoPC9wPlxyXG5cclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibWFyZ2luLWZpeFwiPlNxdWFzaCBzY2FsZSBkb3duIGltYWdlIGZpbGUgc2l6ZS48L3A+XHJcblxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBmaWxlIHNpemUgaXMgYmlnIGVub3VnaCBpdCBtYXkgcmVmaW5lIGlsbHVzdHJhdGlvbnMuIFNsaWNpbmcgcmF0aW8gd2lsbCBub3QgYmUgYWZmZWN0ZWQgLSBpdCB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgcGFnZSBkaXZpc2lvbi48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPmlmIHlvdXIgZmlsZSBpcyBzbWFsbGVyIHRoYW4gdGhlIHNlbGVjdGVkIHNxdWFzaCBvcHRpb24sIGl0IHdpbGwgZXhwYW5kIHlvdXIgaW1hZ2UgYW5kIGF0dGVtcHQgdG8gcHJvZHVjZSB0byB0aGUgc2FtZSBhc3BlY3QgcmF0aW8gb2YgeW91ciBjaG9zZW4gd2ViY29taWMgcGxhdGZvcm0uPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW8tY29udGFpbmVyLXNxdWFzaFwiPlxyXG4gICAgICAgICAgICAgICAgPFNxdWFzaE9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBnZXRTcXVhc2hMZXZlbE1vZGVsPXtwcm9wcy5nZXRTcXVhc2hMZXZlbE1vZGVsfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlT3B0aW9uc1NxdWFzaExldmVsPXtwcm9wcy5vbkhhbmRsZU9wdGlvbnNTcXVhc2hMZXZlbH1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvc2VjdGlvbj5cclxuICAgIClcclxufSIsIi8vIFRPRE86IEZFQVRVUkUgKE5FWFQgVVBEQVRFKVxyXG4vLyBhZGp1c3QgdG8gd2ViY29taWMgcGxhdGZvcm0gcmF0aW8gZm9yIGRpc3BsYXlcclxuXHJcbmZ1bmN0aW9uIFByb2R1Y3QocHJvcHMpIHtcclxuXHJcbiAgICAvLyBJTkpFQ1QgaW1hZ2UgYmxvYlxyXG4gICAgY29uc3QgcHJvY2Vzc2VkSW1hZ2VGSWxlcyA9IHByb3BzLmdldEltYWdlRGF0YS5tYXAoKGltZ0RhdGEsIGluZGV4KSA9PiB7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJvZHVjdF9faW1hZ2UtYmxvY2tcIiBrZXk9e2luZGV4fT5cclxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtpbWdEYXRhfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBwcm9jZXNzZWRJbWFnZUZJbGVzO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGb3JtUmVzdWx0cyhwcm9wcykge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJmb3JtLXJlc3VsdHNcIj5cclxuICAgICAgICAgICAgPGgzPlJlc3VsdHM8L2gzPlxyXG5cclxuICAgICAgICAgICAgPHA+Rm9yIGVhY2ggd2ViY29taWMgcGxhdGZvcm0gc2VsZWN0ZWQsIGEgemlwIGZpbGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRvd25sb2FkZWQgYWZ0ZXIgc2xpY2luZyBwcm9jZXNzIGNvbXBsZXRlZC48L3A+XHJcblxyXG4gICAgICAgICAgICA8Y2FudmFzIGlkPVwiY2FudmFzXCI+PC9jYW52YXM+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInByb2R1Y3QtY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInByb2R1Y3RcIj5cclxuICAgICAgICAgICAgICAgICAgICA8UHJvZHVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJbWFnZURhdGE9e3Byb3BzLmdldEltYWdlRGF0YX1cclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvc2VjdGlvbj5cclxuICAgIClcclxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdlbmVyYXRlVW5pcXVlSWQoKSB7XHJcbiAgICBpZiAod2luZG93LmNyeXB0byAmJiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgRm9ybVVwbG9hZCBmcm9tICcuL0Zvcm1VcGxvYWQnO1xyXG5pbXBvcnQgRm9ybVNlbGVjdCBmcm9tICcuL0Zvcm1TZWxlY3QnO1xyXG5pbXBvcnQgRm9ybU9wdGlvbnMgZnJvbSAnLi9Gb3JtT3B0aW9ucyc7XHJcbmltcG9ydCBGb3JtUmVzdWx0cyBmcm9tICcuL0Zvcm1SZXN1bHRzJztcclxuXHJcbi8vIGxpYnNcclxuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uL2xpYnMvY3JlYXRlSWQnO1xyXG5cclxuLy8gVE9ETzogRkVBVFVSRSAoTkVYVCBVUERBVEUpXHJcbi8vIFwiUm90YXRlXCIgYnV0dG9uIGluIFByZXZpZXcgdGh1bWJcclxuLy8gQWxzbyBzZWUgaW4gJ0Zvcm1VcGxvYWQuanMnXHJcblxyXG5jb25zdCBhbGVydE1lc3NhZ2VzID0ge1xyXG4gICAgb25TdWNjZXNzOiB7XHJcbiAgICAgICAgZmlsZXNSZW1vdmVkOiBcIkZpbGVzIHdlcmUgY2xlYXJlZC5cIixcclxuICAgICAgICBjb21wbGV0ZWRQcm9jZXNzOiBcIlByb2Nlc3MgY29tcGxldGVkIVwiXHJcbiAgICB9LFxyXG4gICAgb25FcnJvcjoge1xyXG4gICAgICAgIHVuYWNjZXB0YWJsZUZpbGVUeXBlOiBcIkZpbGUgZXh0ZW5zaW9ucyBub3Qgc3VwcG9ydGVkISBPbmx5IFBORyBhbmQgSlBFRyAob3IgSlBHKSBhbGxvd2VkLlwiLFxyXG4gICAgICAgIG92ZXJNYXhGaWxlU2l6ZTogXCJUb3RhbCBmaWxlIHNpemUgaXMgb3ZlciBtYXhpbXVtLiBSZW1vdmUgc29tZSBmaWxlcyB0byBjb250aW51ZS5cIixcclxuICAgICAgICBub0ZpbGVzRm91bmQ6IFwiTm8gaW1hZ2VzIGZvdW5kIHRvIHByb2Nlc3MuIFVwbG9hZCBzb21lIGltYWdlcyB0byAnQmVnaW4gU2xpY2UnIVwiLFxyXG4gICAgICAgIHNlbGVjdEZvcm1NYW5kYXRvcnk6IFwiUGxlYXNlIGNoZWNrIGF0IGxlYXN0IG9uZSB3ZWJjb21pYyBwbGF0Zm9ybSB1bmRlciAnMi4gU2VsZWN0Jy5cIixcclxuICAgICAgICBzZWxlY3RGb3JtTWFuZGF0b3J5VGFyZ2V0OiBcIkNoZWNrIGF0IGxlYXN0IG9uZSBpbiBvcmRlciB0byBjb250aW51ZS5cIlxyXG5cclxuICAgIH0sXHJcbiAgICBvbldhcm5pbmc6IHtcclxuICAgICAgICBuZWFyTWF4RmlsZVNpemU6IFwiVG90YWwgZmlsZSBzaXplIGlzIG5lYXIgbWF4aW11bSFcIixcclxuICAgIH1cclxufVxyXG5cclxuY29uc3Qgd2ViY29taWNzTW9kZWwgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgaHRtbExhYmVsOiBcIndlYnRvb25cIixcclxuICAgICAgICBpbWFnZVNvdXJjZTogXCJpbWFnZXMvd2VidG9vbi1pY29uLnN2Z1wiLFxyXG4gICAgICAgIGh0bWxBbHQ6IFwid2VidG9vbiBpY29uXCIsXHJcbiAgICAgICAgdGV4dDogXCJXZWJ0b29uXCIsXHJcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGh0bWxMYWJlbDogXCJ0YXBhc1wiLFxyXG4gICAgICAgIGltYWdlU291cmNlOiBcImltYWdlcy90YXBhcy1pY29uLnBuZ1wiLFxyXG4gICAgICAgIGh0bWxBbHQ6IFwidGFwYXMgaWNvblwiLFxyXG4gICAgICAgIHRleHQ6IFwiVGFwYXNcIixcclxuICAgICAgICBkaXNhYmxlZDogdHJ1ZVxyXG4gICAgfSxcclxuXTtcclxuXHJcbi8vIFJBRElPIE9QVElPTlNcclxuLy8gRGVmYXVsdCBDSEVDS0VEOiBmaWxFeHRlbnNpb25zTW9kZWxbMF1cclxuY29uc3QgZmlsRXh0ZW5zaW9uc01vZGVsID0gW1xyXG4gICAge1xyXG4gICAgICAgIGh0bWxMYWJlbDogXCJqcGVnXCIsXHJcbiAgICAgICAgdGV4dDogXCJKUEVHXCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgaHRtbExhYmVsOiBcInBuZ1wiLFxyXG4gICAgICAgIHRleHQ6IFwiUE5HXCJcclxuICAgIH1cclxuXTtcclxuXHJcbi8vIFJBRElPIE9QVElPTlNcclxuLy8gRGVmYXVsdCBDSEVDS0VEOiBzcXVhc2hMZXZlbE1vZGVsWzBdXHJcbmNvbnN0IHNxdWFzaExldmVsTW9kZWwgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgaHRtbExhYmVsOiBcIm5vbmVcIixcclxuICAgICAgICBwaXhlbFZhbHVlOiAwLFxyXG4gICAgICAgIHRleHQ6IFwibm9uZVwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGh0bWxMYWJlbDogXCI0MDBcIixcclxuICAgICAgICBwaXhlbFZhbHVlOiA0MDAsXHJcbiAgICAgICAgdGV4dDogXCI0MDAgd2lkdGggcGl4ZWxzXCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgaHRtbExhYmVsOiBcIjUwMFwiLFxyXG4gICAgICAgIHBpeGVsVmFsdWU6IDUwMCxcclxuICAgICAgICB0ZXh0OiBcIjUwMCB3aWR0aCBwaXhlbHNcIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBodG1sTGFiZWw6IFwiNjAwXCIsXHJcbiAgICAgICAgcGl4ZWxWYWx1ZTogNjAwLFxyXG4gICAgICAgIHRleHQ6IFwiNjAwIHdpZHRoIHBpeGVsc1wiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGh0bWxMYWJlbDogXCI3MDBcIixcclxuICAgICAgICBwaXhlbFZhbHVlOiA3MDAsXHJcbiAgICAgICAgdGV4dDogXCI3MDAgd2lkdGggcGl4ZWxzXCJcclxuICAgIH1cclxuXVxyXG5cclxuLy8gQWNjZXB0ZWQgZmlsZSB0eXBlc1xyXG5jb25zdCBmaWxlVHlwZXMgPSBbXHJcbiAgICAnaW1hZ2UvanBlZycsXHJcbiAgICAnaW1hZ2UvanBnJyxcclxuICAgICdpbWFnZS9wbmcnLFxyXG5dO1xyXG5cclxuZnVuY3Rpb24gdmFsaWRGaWxlVHlwZShmaWxlKSB7XHJcbiAgICByZXR1cm4gZmlsZVR5cGVzLmluY2x1ZGVzKGZpbGUpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAvLyAjIFNUWUxFUyBFVkVOVFxyXG4gICAgICAgICAgICAvLyBFVkVOVDogb25EcmFnT3ZlclxyXG4gICAgICAgICAgICBpc0RyYWdPdmVyOiBmYWxzZSxcclxuICAgICAgICAgICAgZHJvcHpvbmVCb3JkZXJzQ2xhc3M6IHtcclxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodDogXCJkcm9wem9uZSBkcm9wem9uZS0tb3ZlclwiLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogXCJkcm9wem9uZVwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlucHV0RGF0YUF2YWlsYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIC8vIEVWRU5UOiBvbkNsaWNrXHJcbiAgICAgICAgICAgIC8vIFwiQmVnaW4gU2xpY2UhXCIgYnV0dG9uXHJcbiAgICAgICAgICAgIHNsaWNlVGV4dDogXCJzbGljZS1idG5cIixcclxuICAgICAgICAgICAgLy8gRVZFTlQ6IGNvbmRpdGlvbmFsXHJcbiAgICAgICAgICAgIC8vIGRpdiBjbGFzcyBcInByZXZpZXctd3JhcHBlclwiXHJcbiAgICAgICAgICAgIHByZXZpZXdXcmFwcGVyQ2xhc3M6IHtcclxuICAgICAgICAgICAgICAgIHZpc2libGU6IFwicHJldmlldy13cmFwcGVyXCIsXHJcbiAgICAgICAgICAgICAgICBpbnZpc2libGU6IFwicHJldmlldy13cmFwcGVyIGhpZGRlblwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vICMgQUxFUlQgTUVTU0FHRVMgQU5EIFNUQVRFXHJcbiAgICAgICAgICAgIC8vIFN1Y2Nlc3NcclxuICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VTdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgYWxlcnRNZXNzYWdlU3VjY2VzczogXCJcIixcclxuICAgICAgICAgICAgLy8gRXJyb3JcclxuICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VFcnJvcjogZmFsc2UsXHJcbiAgICAgICAgICAgIGFsZXJ0TWVzc2FnZUVycm9yOiBcIlwiLFxyXG4gICAgICAgICAgICAvLyBXYXJuaW5nXHJcbiAgICAgICAgICAgIGlzQWxlcnRNZXNzYWdlV2FybmluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGFsZXJ0TWVzc2FnZVdhcm5pbmc6IFwiXCIsXHJcbiAgICAgICAgICAgIC8vIEVycm9yIG9uIFwiQmVnaW4gU2xpY2UhXCJcclxuICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VFcnJvck9uQmVnaW5TbGljZUJ0bjogZmFsc2UsXHJcbiAgICAgICAgICAgIGFsZXJ0TWVzc2FnZUVycm9yT25CZWdpblNsaWNlQnRuOiBcIlwiLFxyXG4gICAgICAgICAgICAvLyBTdWNjZXNzIG9uIFwiQmVnaW4gU2xpY2UhXCJcclxuICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VTdWNjZXNzT25CZWdpblNsaWNlQnRuOiBmYWxzZSxcclxuICAgICAgICAgICAgYWxlcnRNZXNzYWdlU3VjY2Vzc09uQmVnaW5TbGljZUJ0bjogXCJcIixcclxuICAgICAgICAgICAgLy8gRXJyb3Igb24gbm9uZSB3ZWJjb21pYyBwbGF0Zm9ybSBzZWxlY3RlZFxyXG4gICAgICAgICAgICBpc0FsZXJ0TWVzc2FnZUVycm9yT25TZWxlY3RGb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgYWxlcnRNZXNzYWdlRXJyb3JPblNlbGVjdEZvcm06IFwiXCIsXHJcblxyXG4gICAgICAgICAgICAvLyAjIERBVEFcclxuICAgICAgICAgICAgcHJvY2Vzc2VkRmlsZURhdGE6IFtdLFxyXG4gICAgICAgICAgICBpbnB1dEZpZWxkOiBbXSxcclxuICAgICAgICAgICAgLy8gaW5wdXRGaWVsZDogW1xyXG4gICAgICAgICAgICAvLyAgICAge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIGZpbGVSZWFkOiBbPG9iaj5dLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIGlkOiA8bnVtYmVyPlxyXG4gICAgICAgICAgICAvLyAgICAgICAgIGZpbGVTaXplOiA8bnVtYmVyPlxyXG4gICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAvLyBdXHJcbiAgICAgICAgICAgIHRvdGFsRmlsZVNpemU6IDAsIC8vIEJ5dGUgbWVhc3VyZW1lbnRcclxuICAgICAgICAgICAgc2VsZWN0ZWRXZWJjb21pY3M6IFtdLFxyXG4gICAgICAgICAgICBzZWxlY3RlZEZpbGVFeHRlbnNpb246IFwianBlZ1wiLCAvLyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgICAgIHNlbGVjdGVkU3F1YXNoTGV2ZWw6IFwibm9uZVwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gIyBNRVRIT0RTXHJcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnID0gdGhpcy5oYW5kbGVEcmFnLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnTGVhdmUgPSB0aGlzLmhhbmRsZURyYWdMZWF2ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlRmlsZURyb3AgPSB0aGlzLmhhbmRsZUZpbGVEcm9wLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVzdWx0cyA9IHRoaXMucHJvY2Vzc1Jlc3VsdHMuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmhhbmRsZUJlZ2luU2xpY0J0biA9IHRoaXMuaGFuZGxlQmVnaW5TbGljQnRuLmJpbmQodGhpcyk7XHJcbiAgICAgICAgLy8gVE9HR0xFIENMQVNTXHJcbiAgICAgICAgdGhpcy50b2dnbGVCZWdpblNsaWNlVGV4dCA9IHRoaXMudG9nZ2xlQmVnaW5TbGljZVRleHQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSB0aGlzLmhhbmRsZURyYWdFbmQuYmluZCh0aGlzKTtcclxuICAgICAgICAvLyBEQVRBIE1BTkFHRU1FTlRcclxuICAgICAgICAvLyBERUxFVEUgRGF0YVxyXG4gICAgICAgIHRoaXMuaGFuZGxlUmVtb3ZlU2VsZiA9IHRoaXMuaGFuZGxlUmVtb3ZlU2VsZi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2tUb1JlbW92ZUFsbCA9IHRoaXMuaGFuZGxlQ2xpY2tUb1JlbW92ZUFsbC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIC8vIFNFVCBmaWxlIGRhdGFcclxuICAgICAgICB0aGlzLnNldEZpbGVzRGF0YSA9IHRoaXMuc2V0RmlsZXNEYXRhLmJpbmQodGhpcyk7XHJcbiAgICAgICAgLy8gR0VUIHRvdGFsIGZpbGUgc2l6ZVxyXG4gICAgICAgIHRoaXMuY2hlY2tUb3RhbEZpbGVTaXplID0gdGhpcy5jaGVja1RvdGFsRmlsZVNpemUuYmluZCh0aGlzKTtcclxuICAgICAgICAvLyBVUExPQUQgb24gZmlsZSBicm93c2VcclxuICAgICAgICB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlID0gdGhpcy5oYW5kbGVJbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0ZWRXZWJjb21pYyA9IHRoaXMuaGFuZGxlU2VsZWN0ZWRXZWJjb21pYy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlT3B0aW9uc0ZpbGVFeHRlbmlvbnMgPSB0aGlzLmhhbmRsZU9wdGlvbnNGaWxlRXh0ZW5pb25zLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVPcHRpb25zU3F1YXNoTGV2ZWwgPSB0aGlzLmhhbmRsZU9wdGlvbnNTcXVhc2hMZXZlbC5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT1cclxuICAgIC8vICMgUkVBQ1QgTUVUSE9EU1xyXG4gICAgLy8gPT09PT09PT09PT09PT09XHJcbiAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgIC8vICAgICBjb25zb2xlLmxvZyhcIlVOTU9VTlRJTkcuLi5cIik7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAvLyAgICAgY29uc29sZS5sb2coXCJNT1VOVElORy4uLlwiKTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICAvLyAgICAgY29uc29sZS5sb2coXCJDT01QT05FTlQgVVBEQVRJTkcuLi5cIik7XHJcbiAgICAvLyB9XHJcblxyXG5cclxuICAgIC8vID09PT09PT09XHJcbiAgICAvLyAjIEVWRU5UU1xyXG4gICAgLy8gPT09PT09PT1cclxuXHJcbiAgICAvLyBldmVudDogZHJhZ1xyXG4gICAgaGFuZGxlRHJhZyhlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBpc0RyYWdPdmVyOiB0cnVlXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBldmVudDogZHJhZ1xyXG4gICAgaGFuZGxlRHJhZ0xlYXZlKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KGUpO1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBpc0RyYWdPdmVyOiBmYWxzZVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXZlbnQ6IGRyYWdcclxuICAgIC8vIFJlb3JkZXIgZmlsZXNcclxuICAgIGhhbmRsZURyYWdFbmQocmVzdWx0KSB7XHJcbiAgICAgICAgLy8gQ1JFQVRFIHNoYWxsb3cgY29weVxyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlLmlucHV0RmllbGQpO1xyXG5cclxuICAgICAgICAvLyBFWFRSQUNUIHRhcmdldGVkIGl0ZW1cclxuICAgICAgICBjb25zdCBbcmVvcmRlcmVkSXRlbV0gPSBpdGVtcy5zcGxpY2UocmVzdWx0LnNvdXJjZS5pbmRleCwgMSk7XHJcblxyXG4gICAgICAgIC8vIFBVU0ggdGFyZ2V0ZWQgaXRlbSBpbnRvIG5ldyBvcmRlclxyXG4gICAgICAgIGl0ZW1zLnNwbGljZShyZXN1bHQuZGVzdGluYXRpb24uaW5kZXgsIDAsIHJlb3JkZXJlZEl0ZW0pO1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgaW5wdXRGaWVsZDogaXRlbXNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGV2ZW50OiBjbGlja1xyXG4gICAgLy8gT3BlbiBicm93c2VyIGZvciBmaWxlc1xyXG4gICAgaGFuZGxlQ2xpY2tUb1VwbG9hZCgpIHtcclxuICAgICAgICBjb25zdCBkcm9wem9uZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5kcm9wem9uZV9faW5wdXRcIik7XHJcblxyXG4gICAgICAgIC8vIEVNVUxBVEUgSFRNTCBpbnB1dCBDTElDSyBldmVudFxyXG4gICAgICAgIGRyb3B6b25lSW5wdXQuY2xpY2soKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBldmVudDogY2xpY2tcclxuICAgIC8vIFVQREFURSBzdGF0ZSAnc2VsZWN0ZWRGaWxlRXh0ZW5zaW9uJ1xyXG4gICAgaGFuZGxlT3B0aW9uc0ZpbGVFeHRlbmlvbnMoZSkge1xyXG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGVkRmlsZUV4dGVuc2lvbiA9IGUudGFyZ2V0LnZhbHVlO1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRGaWxlRXh0ZW5zaW9uOiBuZXdTZWxlY3RlZEZpbGVFeHRlbnNpb25cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBldmVudDogY2xpY2tcclxuICAgIC8vIFVQREFURSBzdGF0ZSAnc2VsZWN0ZWRTcXVhc2hMZXZlbCdcclxuICAgIGhhbmRsZU9wdGlvbnNTcXVhc2hMZXZlbChlKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0ZWRTcXVhc2hMZXZlbCA9IHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlLCAxMCk7XHJcblxyXG4gICAgICAgIGlmIChuZXdTZWxlY3RlZFNxdWFzaExldmVsID09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFNxdWFzaExldmVsOiBcIm5vbmVcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkU3F1YXNoTGV2ZWw6IG5ld1NlbGVjdGVkU3F1YXNoTGV2ZWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGV2ZW50OiBjbGlja1xyXG4gICAgLy8gXCJCZWdpbiBTbGljZSFcIiBidXR0b25cclxuICAgIGhhbmRsZUJlZ2luU2xpY0J0bihlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbnB1dEZpZWxkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBBTEVSVCBNRVNTQUdFXHJcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgKG9yIGltYWdlIGZpbGUpIGZvdW5kXHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VFcnJvck9uQmVnaW5TbGljZUJ0bjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFsZXJ0TWVzc2FnZUVycm9yT25CZWdpblNsaWNlQnRuOiBhbGVydE1lc3NhZ2VzLm9uRXJyb3Iubm9GaWxlc0ZvdW5kXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxlcnRNZXNzYWdlRXJyb3JPbkJlZ2luU2xpY2VCdG46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0TWVzc2FnZUVycm9yT25CZWdpblNsaWNlQnRuOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIDgwMDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkV2ViY29taWNzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQUxFUlQgTUVTU0FHRSAoUEVSU0lTVClcclxuICAgICAgICAgICAgICAgIC8vIE5vIHdlYmNvbWljIHBsYXRmb3JtIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBpc0FsZXJ0TWVzc2FnZUVycm9yT25CZWdpblNsaWNlQnRuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0TWVzc2FnZUVycm9yT25CZWdpblNsaWNlQnRuOiBhbGVydE1lc3NhZ2VzLm9uRXJyb3Iuc2VsZWN0Rm9ybU1hbmRhdG9yeSxcclxuICAgICAgICAgICAgICAgICAgICBpc0FsZXJ0TWVzc2FnZUVycm9yT25TZWxlY3RGb3JtOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0TWVzc2FnZUVycm9yT25TZWxlY3RGb3JtOiBhbGVydE1lc3NhZ2VzLm9uRXJyb3Iuc2VsZWN0Rm9ybU1hbmRhdG9yeVRhcmdldFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEFMRVJUIE1FU1NBR0UgKFBFUlNJU1QgLT4gUkVNT1ZFRClcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxlcnRNZXNzYWdlRXJyb3JPbkJlZ2luU2xpY2VCdG46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0TWVzc2FnZUVycm9yT25CZWdpblNsaWNlQnRuOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxlcnRNZXNzYWdlRXJyb3JPblNlbGVjdEZvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0TWVzc2FnZUVycm9yT25TZWxlY3RGb3JtOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUmVzdWx0cygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVCZWdpblNsaWNlVGV4dCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQmVnaW5TbGljZVRleHQoKTtcclxuICAgICAgICAgICAgICAgIH0sIDE1MDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGV2ZW50OiBjbGlja1xyXG4gICAgLy8gXCJYXCIgYnV0dG9uXHJcbiAgICAvLyBSRU1PVkUgY3VycmVudCB0aHVtYiBVSVxyXG4gICAgLy8gUkVNT1ZFIGN1cnJlbnQgdGh1bWIgZGF0YVxyXG4gICAgaGFuZGxlUmVtb3ZlU2VsZihlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAvLyBHUkFCIGFsbCBsaXN0XHJcbiAgICAgICAgY29uc3Qgc291cmNlVGh1bWJuYWlscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIucHJldmlld19fdGh1bWJuYWlsLWNvbnRhaW5lclwiKTtcclxuXHJcbiAgICAgICAgLy8gVFJBTlNGT1JNIG5vZGUgaW50byBKYXZhU2NyaXB0IG9iamVjdHMgKGFycmF5KVxyXG4gICAgICAgIGNvbnN0IGFyclRodW1ibmFpbHMgPSBBcnJheS5mcm9tKHNvdXJjZVRodW1ibmFpbHMpO1xyXG5cclxuICAgICAgICAvLyBDUkVBVEUgc2hhbGxvdyBjb3B5XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGUuaW5wdXRGaWVsZCk7XHJcblxyXG4gICAgICAgIC8vIEdFVCBpbmRleCBvZiB0YXJnZXRlZCBpdGVtXHJcbiAgICAgICAgY29uc3QgcmVtb3ZlSXRlbUluZGV4ID0gYXJyVGh1bWJuYWlscy5pbmRleE9mKGUudGFyZ2V0LnBhcmVudEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAvLyBVUERBVEUgc3RhdGUgdG90YWxGaWxlU2l6ZVxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKGN1cnJlbnRTdGF0ZSkgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gR0VUIGRhdGFcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlSW5wdXRGaWVsZCA9IEFycmF5LmZyb20oY3VycmVudFN0YXRlLmlucHV0RmllbGQpO1xyXG5cclxuICAgICAgICAgICAgLy8gR0VUIGRhdGEgJ2ZpbGVTaXplJ1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlU2l6ZXNBcnIgPSBzb3VyY2VJbnB1dEZpZWxkLm1hcCgoZmlsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuZmlsZVNpemU7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gU1VNIGFsbCBkYXRhICdmaWxlU2l6ZSdcclxuICAgICAgICAgICAgY29uc3QgdG90YWxGaWxlQnl0ZSA9IGZpbGVTaXplc0Fyci5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVYVFJBQ1QgdGFyZ2V0ZWQgaXRlbSAnZmlsZVNpemUnXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRJdGVtRmlsZVNpemUgPSBzb3VyY2VJbnB1dEZpZWxkW3JlbW92ZUl0ZW1JbmRleF1bXCJmaWxlU2l6ZVwiXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNVQlRSQUNUICd0b3RhbEZpbGVTaXplJyAtIHRhcmdldGVkIGl0ZW0gJ2ZpbGVTaXplJ1xyXG4gICAgICAgICAgICBjb25zdCBuZXdUb3RhbEZpbGVTaXplID0gdG90YWxGaWxlQnl0ZSAtIHJlbW92ZWRJdGVtRmlsZVNpemU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKHtcclxuICAgICAgICAgICAgICAgIHRvdGFsRmlsZVNpemU6IG5ld1RvdGFsRmlsZVNpemVcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIFVQREFURSBVSVxyXG4gICAgICAgIH0sIHRoaXMuY2hlY2tUb3RhbEZpbGVTaXplKCkpO1xyXG5cclxuICAgICAgICAvLyBSRU1PVkUgdGFyZ2V0ZWQgaXRlbVxyXG4gICAgICAgIGl0ZW1zLnNwbGljZShyZW1vdmVJdGVtSW5kZXgsIDEpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gVVBEQVRFIGRhdGFcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgaW5wdXRGaWVsZDogaXRlbXNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBldmVudDogY2xpY2tcclxuICAgIC8vIEVNUFRZIHN0YXRlIFwiaW5wdXRGaWVsZFwiXHJcbiAgICAvLyBcIkNsZWFyIEZpbGVzXCIgYnV0dG9uXHJcbiAgICBoYW5kbGVDbGlja1RvUmVtb3ZlQWxsKCkge1xyXG4gICAgICAgIC8vIEFMRVJUIE1FU1NBR0VcclxuICAgICAgICAvLyBVUERBVEUgZGF0YVxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBpbnB1dEZpZWxkOiBbXSxcclxuICAgICAgICAgICAgaW5wdXREYXRhQXZhaWxhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VTdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICBhbGVydE1lc3NhZ2VTdWNjZXNzOiBhbGVydE1lc3NhZ2VzLm9uU3VjY2Vzcy5maWxlc1JlbW92ZWRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VTdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGFsZXJ0TWVzc2FnZVN1Y2Nlc3M6IFwiXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgODAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXZlbnQ6IGNoYW5nZVxyXG4gICAgLy8gTElTdEVOIHRvIHVzZXIgb24gQ0xJQ0sgdG8gdXBsb2FkIGZpbGVcclxuICAgIC8vIGlmIHVzZXIgc2VsZWN0cyBmaWxlKHMpLCBwcm9jZWVkIHRvIHByb2Nlc3MgaW1hZ2UgZmlsZXMgbWV0aG9kc1xyXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UoZSkge1xyXG4gICAgICAgIGNvbnN0IGZpbGVzID0gZS50YXJnZXQuZmlsZXM7XHJcbiAgICAgICAgdGhpcy5zZXRGaWxlc0RhdGEoZmlsZXMpO1xyXG5cclxuICAgICAgICAvLyBVUERBVEUgVUkgb24gQ09ORElUSU9OXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5wdXRGaWVsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGlucHV0RGF0YUF2YWlsYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBldmVudDogY2xpY2tcclxuICAgIC8vIFVQREFURSBzdGF0ZSAnc2VsZWN0ZWRXZWJjb21pY3MnXHJcbiAgICBoYW5kbGVTZWxlY3RlZFdlYmNvbWljKGUpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFdlYmNvbWljVmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudFNlbGVjdGVkV2ViY29taWNzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZFdlYmNvbWljcztcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3RlZFdlYmNvbWljcy5pbmNsdWRlcyhzZWxlY3RlZFdlYmNvbWljVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIC8vIFVOQ0hFQ0tcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlSXRlbUluZGV4ID0gY3VycmVudFNlbGVjdGVkV2ViY29taWNzLmluZGV4T2Yoc2VsZWN0ZWRXZWJjb21pY1ZhbHVlKTtcclxuICAgICAgICAgICAgY3VycmVudFNlbGVjdGVkV2ViY29taWNzLnNwbGljZShyZW1vdmVJdGVtSW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFdlYmNvbWljczogY3VycmVudFNlbGVjdGVkV2ViY29taWNzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENIRUNLXHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKGN1cnJlbnRTdGF0ZSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkV2ViY29taWNzOiBbLi4uY3VycmVudFN0YXRlLnNlbGVjdGVkV2ViY29taWNzLCBzZWxlY3RlZFdlYmNvbWljVmFsdWVdXHJcblxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyA9PT09PT09PT1cclxuICAgIC8vICMgTUVUSE9EU1xyXG4gICAgLy8gPT09PT09PT09XHJcblxyXG4gICAgLy8gVE9HR0xFXHJcbiAgICAvLyBcIkJlZ2luIFNsaWNlXCIgVGV4dFxyXG4gICAgdG9nZ2xlQmVnaW5TbGljZVRleHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2xpY2VUZXh0ID09PSBcInNsaWNlLWJ0blwiKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIHNsaWNlVGV4dDogXCJpY29uLXNwaW5uZXI4IGFuaW1hdGUtc3BpblwiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnNsaWNlVGV4dCA9PT0gXCJpY29uLXNwaW5uZXI4IGFuaW1hdGUtc3BpblwiKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIHNsaWNlVGV4dDogXCJzbGljZS1idG5cIlxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGRVRDSElORyBGSUxFIFJFQURcclxuICAgIC8vIC0gVkFMSURBVEUgZmlsZSBvbiB1cGxvYWRcclxuICAgIC8vIC0gVVBEQVRFIHN0YXRlIFwiaW5wdXRGaWVsZFwiXHJcbiAgICAvLyAtIFRPR0dMRSBjbGFzc1xyXG4gICAgaGFuZGxlRmlsZURyb3AoZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICBjb25zdCBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xyXG5cclxuICAgICAgICB0aGlzLnNldEZpbGVzRGF0YShmaWxlcyk7XHJcblxyXG4gICAgICAgIC8vIFVQREFURSBkYXRhIGJvb2xlYW4gKGZvciBvdGhlciBjaGFpbiByZWFjdGlvbnMpXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5wdXRGaWVsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGlucHV0RGF0YUF2YWlsYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIGlzRHJhZ092ZXI6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RmlsZXNEYXRhKGZpbGVzKSB7XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhmaWxlcykuZm9yRWFjaCgob2JqKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBWQUxJREFURVxyXG4gICAgICAgICAgICBpZiAoIXZhbGlkRmlsZVR5cGUob2JqLnR5cGUpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQUxFUlQgTUVTU0FHRVxyXG4gICAgICAgICAgICAgICAgLy8gVXNlciBhdHRlbXB0ZWQgdG8gdXBsb2FkIHVuYWNjZXB0YWJsZSBmaWxlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxlcnRNZXNzYWdlRXJyb3I6IGFsZXJ0TWVzc2FnZXMub25FcnJvci51bmFjY2VwdGFibGVGaWxlVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0FsZXJ0TWVzc2FnZUVycm9yOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydE1lc3NhZ2VFcnJvcjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VFcnJvcjogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSwgODAwMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ1JFQVRFIGltYWdlIGZpbGUgZGF0YSBwcmV2aWV3IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgoY3VycmVudFN0YXRlKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0RmllbGQ6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3VycmVudFN0YXRlLmlucHV0RmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkOiBvYmosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogY3JlYXRlSWQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVTaXplOiBvYmouc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVVBEQVRFIHN0YXRlICd0b3RhbEZpbGVTaXplJ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgoY3VycmVudFN0YXRlKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdFVCBtYWluIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VJbnB1dEZpZWxkID0gY3VycmVudFN0YXRlLmlucHV0RmllbGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdFVCBtYWluIGRhdGEgJ2ZpbGVTaXplJ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVTaXplc0FyciA9IHNvdXJjZUlucHV0RmllbGQubWFwKChmaWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmZpbGVTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT1RBTCBtYWluIGRhdGEgJ2ZpbGVTaXplJ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsRmlsZUJ5dGUgPSBmaWxlU2l6ZXNBcnIucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEZpbGVTaXplOiB0b3RhbEZpbGVCeXRlXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ0hFQ0sgQ09ORElUSU9OXHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmNoZWNrVG90YWxGaWxlU2l6ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ0hFQ0sgQ09ORElUSU9OXHJcbiAgICAvLyBVUERBVEUgVUkgaWYgQ09ORElUSU9OIGFyZSBtZXRcclxuICAgIGNoZWNrVG90YWxGaWxlU2l6ZSgpIHtcclxuXHJcbiAgICAgICAgLy8gQUxFUlQgTUVTU0FHRVxyXG4gICAgICAgIC8vIENPTkRJVElPTlxyXG4gICAgICAgIC8vIG5lYXIgbWF4LCBwYXNzIDE4TUJcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS50b3RhbEZpbGVTaXplID49IDE4ODc0MzY4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VXYXJuaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYWxlcnRNZXNzYWdlV2FybmluZzogYWxlcnRNZXNzYWdlcy5vbldhcm5pbmcubmVhck1heEZpbGVTaXplXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBTEVSVCBNRVNTQUdFXHJcbiAgICAgICAgLy8gQ09ORElUSU9OXHJcbiAgICAgICAgLy8gb3ZlciBtYXgsIHBhc3MgMjBNQlxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnRvdGFsRmlsZVNpemUgPj0gMjA5NzE1MjApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBpc0FsZXJ0TWVzc2FnZUVycm9yOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYWxlcnRNZXNzYWdlRXJyb3I6IGFsZXJ0TWVzc2FnZXMub25FcnJvci5vdmVyTWF4RmlsZVNpemVcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUFJPQ0VTUyBJTUFHRSBGSUxFU1xyXG4gICAgcHJvY2Vzc1Jlc3VsdHMoKSB7XHJcbiAgICAgICAgLy8gR0VUIGFsbCBpbWFnZSBmaWxlIGVsZW1lbnRzXHJcbiAgICAgICAgY29uc3Qgc291cmNlSW1hZ2VzUmF3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5wcmV2aWV3X190aHVtYm5haWwgaW1nXCIpO1xyXG4gICAgICAgIC8vIFJFRkVSRU5DRSB0aGUgY2FudmFzXHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjYW52YXNcIik7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgIC8vIFRSQU5TRk9STSBub2RlIGludG8gSmF2YVNjcmlwdCBvYmplY3RzIChhcnJheSlcclxuICAgICAgICBjb25zdCBzb3VyY2VJbWFnZXMgPSBBcnJheS5mcm9tKHNvdXJjZUltYWdlc1Jhdyk7XHJcblxyXG4gICAgICAgIC8vIEdFVCB1c2VyIHNlbGVjdGVkIHdlYmNvbWljIHBsYXRmb3JtKHMpIGZyb20gU0VMRUNUIGZvcm0gY29tcG9uZW50XHJcbiAgICAgICAgY29uc3QgU2VsZWN0ZWR3ZWJjb21pY3MgPSB0aGlzLnN0YXRlLnNlbGVjdGVkV2ViY29taWNzO1xyXG5cclxuICAgICAgICAvLyAjICgxKSBTRUxFQ1QgZm9ybVxyXG4gICAgICAgIC8vIFBST0NFU1MgZmlsZXMgZm9yIGFsbCBzZWxlY3RlZCB3ZWJjb21pYyBwbGF0Zm9ybSBhcHBsaWVkXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBTZWxlY3RlZHdlYmNvbWljcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgbGV0IHByb2Nlc3NJbWFnZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBST0NFU1MgaW1hZ2UgZmlsZVxyXG4gICAgICAgICAgICBzb3VyY2VJbWFnZXMuZm9yRWFjaCgoaW1nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWdXaWR0aCA9IGltZy5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWdIZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAqIENPTkRJVElPTjogaW1hZ2Ugd2lkdGggPiBpbWFnZSBoZWlnaHRcclxuICAgICAgICAgICAgICAgIC8vIFJPVEFURSBpbWFnZVxyXG4gICAgICAgICAgICAgICAgaWYgKGltZ1dpZHRoID4gaW1nSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBCb3R0b20gc3VyZmFjZSB3b3VsZCBiZSBwb2ludGVkIGxlZnQsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvcCBzdXJmYWNlIHdvdWxkIGJlIHBvaW50ZWQgcmlnaHRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWdXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJvdGF0ZShNYXRoLlBJIC8gMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcsIDAsIC0oaW1nSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gaW1nSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWdXaWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc2NhbGVXaWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAjICgyKSBPUFRJT05TIGZvcm0gLSBcIlNRVUFTSFwiXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUuc2VsZWN0ZWRTcXVhc2hMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlV2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlV2lkdGggPSA0MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVdpZHRoID0gNTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDYwMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVXaWR0aCA9IDYwMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3MDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlV2lkdGggPSA3MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCB3ZWJjb21pY01heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgbGV0IHdlYmNvbWljTWF4SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZFQVRVUkUgKE5FWFQgVVBEQVRFKVxyXG4gICAgICAgICAgICAgICAgLy8gRmluZCBvdXQgbm9ybWFsIHRhcGFzIHJhdGlvXHJcbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50IFdlYmNvbWljIFBsYXRmb3JtIEF2YWlsYWJsZS4uLlxyXG4gICAgICAgICAgICAgICAgLy8gISB0YXBhcyBpbiB0aGUgd29ya3MuLi4gKFdJUClcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoU2VsZWN0ZWR3ZWJjb21pY3NbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2VidG9vblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJjb21pY01heFdpZHRoID0gODAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJjb21pY01heEhlaWdodCA9IDEyODA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0YXBhc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJjb21pY01heFdpZHRoID0gOTYwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJjb21pY01heEhlaWdodCA9IDE0NDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2ViY29taWNNYXhXaWR0aCAvIHdlYmNvbWljTWF4SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGJhc2VkIG9uIGFzcGVjdCByYXRpbywgd2hhdCB0aGUgaGVpZ2h0IHNob3VsZCBiZS4uLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZXJtaW5lZGVIZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzY2FsZURldGVybWluZWRlSGVpZ2h0ID0gZGV0ZXJtaW5lZGVIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGVXaWR0aCAhPT0gd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZURldGVybWluZWRlSGVpZ2h0ID0gc2NhbGVXaWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vICogQ09ORElUSU9OOlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZmlsZSBpbWFnZSBuYXR1cmFsSGVpZ2h0IGlzIHNob3J0ZXIgdGhhbiBkZXRlcm1pbmVkSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGFzIGlzLi4uIHVubGVzcyBPcHRpb25zIHNjYWxlIGFwcGxpZWRcclxuICAgICAgICAgICAgICAgIGlmIChkZXRlcm1pbmVkZUhlaWdodCA+IG1heEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlTWF4SGVpZ2h0ID0gc2NhbGVXaWR0aCAvICh3aWR0aCAvIG1heEhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNjYWxlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHNjYWxlTWF4SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLCAwLCAwLCBzY2FsZVdpZHRoLCBzY2FsZU1heEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbnZhcy50b0RhdGFVUkwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0ltYWdlcy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aW1lc1RvU2xpY2UgPSBNYXRoLmZsb29yKG1heEhlaWdodCAvIGRldGVybWluZWRlSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFNsaWNlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3WVBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2xpY2VkSW1hZ2VzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICogQ09ORElUSU9OOiBMb25nZXIgbGVuZ3RoIChoZWlnaHQpIGltYWdlc1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aW1lc1RvU2xpY2UgPiBjdXJyZW50U2xpY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3WVBvc2l0aW9uID0gZGV0ZXJtaW5lZGVIZWlnaHQgKiBjdXJyZW50U2xpY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBzY2FsZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc2NhbGVEZXRlcm1pbmVkZUhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLCAwLCBuZXdZUG9zaXRpb24sIHdpZHRoLCBkZXRlcm1pbmVkZUhlaWdodCwgMCwgMCwgc2NhbGVXaWR0aCwgc2NhbGVEZXRlcm1pbmVkZUhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2VkSW1hZ2VzLnB1c2goY2FudmFzLnRvRGF0YVVSTCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTbGljZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKiBDT05EVElPTjogT2RkIG51bWJlciByZW1haW5pbmdcclxuICAgICAgICAgICAgICAgICAgICAvLyBHRVQgbGFzdCBjb29yZGluYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR0VUIHJlbWFpbmluZyBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1haW5Db29yZGluYXRlWSA9IHRpbWVzVG9TbGljZSAqIGRldGVybWluZWRlSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbkhlaWdodCA9IG1heEhlaWdodCAtIHJlbWFpbkNvb3JkaW5hdGVZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPUFRJT05TIFNxdWFzaCAtIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZVJlbWFpbmVIZWlnaHQgPSByZW1haW5IZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlV2lkdGggIT09IHdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUmVtYWluZUhlaWdodCA9IHNjYWxlV2lkdGggLyAod2lkdGggLyByZW1haW5IZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbkhlaWdodCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdZUG9zaXRpb24gPSByZW1haW5Db29yZGluYXRlWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vID8gUmVmYWN0b3IgdG8gYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBzY2FsZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc2NhbGVSZW1haW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZywgMCwgbmV3WVBvc2l0aW9uLCB3aWR0aCwgcmVtYWluSGVpZ2h0LCAwLCAwLCBzY2FsZVdpZHRoLCBzY2FsZVJlbWFpbmVIZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlZEltYWdlcy5wdXNoKGNhbnZhcy50b0RhdGFVUkwoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzSW1hZ2VzLnB1c2goLi4uc2xpY2VkSW1hZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQ1JFQVRFIFppcCBmb2xkZXJcclxuICAgICAgICAgICAgLy8gTkFNRSBpbWFnZXMgd2l0aCBwYWRkZWQgemVybyBpZiB1bmRlciAxMHNcclxuICAgICAgICAgICAgLy8gR0VUIHVzZXIgZmlsZSBleHRlbnNpb24gcHJlZmVybmNlIGZyb20gT3B0aW9ucyBmb3JtIC0gRmlsZSBFeHRlbnNpb25zXHJcbiAgICAgICAgICAgIC8vIFBVU0ggaW1hZ2VzIHRvIFppcCBmb2xkZXJcclxuICAgICAgICAgICAgLy8gRE9XTkxPQUQgdG8gdXNlcidzIFBDXHJcbiAgICAgICAgICAgIGNvbnN0IHppcCA9IG5ldyBKU1ppcCgpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEZpbGVFeHQgPSB0aGlzLnN0YXRlLnNlbGVjdGVkRmlsZUV4dGVuc2lvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIE5PVEU6IE5hbWluZyBpcyBwYWRkZWQgd2l0aCB6ZXJvIG9mIHRlbnNcclxuICAgICAgICAgICAgLy8gT3ZlciB0ZW5zIGFyZSB1bmF2YWlsYWJsZVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9jZXNzSW1hZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBgJHtpfS4ke3NlbGVjdGVkRmlsZUV4dH1gO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IGAke2kudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIil9LiR7c2VsZWN0ZWRGaWxlRXh0fWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgemlwLmZpbGUoZmlsZU5hbWUsIHByb2Nlc3NJbWFnZXNbaV0uc3Vic3RyKHByb2Nlc3NJbWFnZXNbaV0uaW5kZXhPZignLCcpICsgMSksIHsgYmFzZTY0OiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB6aXAuZ2VuZXJhdGVBc3luYyh7IHR5cGU6IFwiYmxvYlwiLCBtaW1lVHlwZTogXCJpbWFnZS9qcGVnXCIgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChibG9iKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVBcyhibG9iLCBgJHtTZWxlY3RlZHdlYmNvbWljc1tpXX0uemlwYCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gQUREIGltYWdlICdkYXRhOicgdXJsIGFyciBvZiBwcm9jZXNzZWQgaW1hZ2UgZmlsZXNcclxuICAgICAgICAgICAgLy8gUkVTUE9ORFMgdG8gZGlzcGxheSBpbiBSZXN1bHQgZm9ybVxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZEZpbGVEYXRhOiBwcm9jZXNzSW1hZ2VzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQUxFUlQgTUVTU0FHRVxyXG4gICAgICAgIC8vIFByb2Nlc3MgY29tcGxldGVkXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIGlzQWxlcnRNZXNzYWdlU3VjY2Vzc09uQmVnaW5TbGljZUJ0bjogdHJ1ZSxcclxuICAgICAgICAgICAgYWxlcnRNZXNzYWdlU3VjY2Vzc09uQmVnaW5TbGljZUJ0bjogYWxlcnRNZXNzYWdlcy5vblN1Y2Nlc3MuY29tcGxldGVkUHJvY2Vzc1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBpc0FsZXJ0TWVzc2FnZVN1Y2Nlc3NPbkJlZ2luU2xpY2VCdG46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYWxlcnRNZXNzYWdlU3VjY2Vzc09uQmVnaW5TbGljZUJ0bjogXCJcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgODAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICA8aDI+U3RhcnQgSGVyZTwvaDI+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybVVwbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVWRU5UU1xyXG4gICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlRHJhZz17dGhpcy5oYW5kbGVEcmFnfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlRHJhZ0xlYXZlPXt0aGlzLmhhbmRsZURyYWdMZWF2ZX1cclxuICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZUZpbGVEcm9wPXt0aGlzLmhhbmRsZUZpbGVEcm9wfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVtb3ZlU2VsZj17dGhpcy5oYW5kbGVSZW1vdmVTZWxmfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uaGFuZGxlRHJhZ0VuZD17dGhpcy5oYW5kbGVEcmFnRW5kfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlQ2xpY2tUb1VwbG9hZD17dGhpcy5oYW5kbGVDbGlja1RvVXBsb2FkfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlSW5wdXRDaGFuZ2U9e3RoaXMuaGFuZGxlSW5wdXRDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVDbGlja1RvUmVtb3ZlQWxsPXt0aGlzLmhhbmRsZUNsaWNrVG9SZW1vdmVBbGx9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU1RZTEVEIEVWRU5UU1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZURyb3B6b25lQm9yZGVyc0NsYXNzPXt0aGlzLnN0YXRlLmlzRHJhZ092ZXIgPyB0aGlzLnN0YXRlLmRyb3B6b25lQm9yZGVyc0NsYXNzLmhpZ2hsaWdodCA6IHRoaXMuc3RhdGUuZHJvcHpvbmVCb3JkZXJzQ2xhc3MuZGVmYXVsdH1cclxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVQcmV2aWV3V3JhcHBlckNsYXNzPXt0aGlzLnN0YXRlLmlucHV0RGF0YUF2YWlsYWJsZSA/IHRoaXMuc3RhdGUucHJldmlld1dyYXBwZXJDbGFzcy52aXNpYmxlIDogdGhpcy5zdGF0ZS5wcmV2aWV3V3JhcHBlckNsYXNzLmludmlzaWJsZX1cclxuICAgICAgICAgICAgICAgICAgICAvLyBBTEVSVCBNRVNTQUdFU1xyXG4gICAgICAgICAgICAgICAgICAgIGdldEFsZXJ0RXJyb3JUZXh0PXt0aGlzLnN0YXRlLmFsZXJ0TWVzc2FnZUVycm9yfVxyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxlcnRNZXNzYWdlRXJyb3I9e3RoaXMuc3RhdGUuaXNBbGVydE1lc3NhZ2VFcnJvcn1cclxuICAgICAgICAgICAgICAgICAgICBnZXRBbGVydFN1Y2Nlc3NUZXh0PXt0aGlzLnN0YXRlLmFsZXJ0TWVzc2FnZVN1Y2Nlc3N9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VTdWNjZXNzPXt0aGlzLnN0YXRlLmlzQWxlcnRNZXNzYWdlU3VjY2Vzc31cclxuICAgICAgICAgICAgICAgICAgICBpc0FsZXJ0TWVzc2FnZVdhcm5pbmc9e3RoaXMuc3RhdGUuaXNBbGVydE1lc3NhZ2VXYXJuaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgIGdldEFsZXJ0V2FybmluZ1RleHQ9e3RoaXMuc3RhdGUuYWxlcnRNZXNzYWdlV2FybmluZ31cclxuICAgICAgICAgICAgICAgICAgICAvLyBEQVRBU1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0RmllbGQ9e3RoaXMuc3RhdGUuaW5wdXRGaWVsZH1cclxuICAgICAgICAgICAgICAgICAgICBnZXRUb3RhbEZpbGVTaXplPXt0aGlzLnN0YXRlLnRvdGFsRmlsZVNpemV9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPEZvcm1TZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICBnZXRXZWJjb21pY3NNb2RlbD17d2ViY29taWNzTW9kZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVTZWxlY3RlZFdlYmNvbWljPXt0aGlzLmhhbmRsZVNlbGVjdGVkV2ViY29taWN9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbGVydE1lc3NhZ2VTZWxlY3RGb3JtRXJyb3I9e3RoaXMuc3RhdGUuaXNBbGVydE1lc3NhZ2VFcnJvck9uU2VsZWN0Rm9ybX1cclxuICAgICAgICAgICAgICAgICAgICBnZXRBbGVydE1lc3NhZ2VTZWxlY3RGb3JtVGV4dD17dGhpcy5zdGF0ZS5hbGVydE1lc3NhZ2VFcnJvck9uU2VsZWN0Rm9ybX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8Rm9ybU9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBnZXRGaWxFeHRlbnNpb25zTW9kZWw9e2ZpbEV4dGVuc2lvbnNNb2RlbH1cclxuICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZU9wdGlvbnNGaWxlRXh0ZW5pb25zPXt0aGlzLmhhbmRsZU9wdGlvbnNGaWxlRXh0ZW5pb25zfVxyXG4gICAgICAgICAgICAgICAgICAgIGdldFNxdWFzaExldmVsTW9kZWw9e3NxdWFzaExldmVsTW9kZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVPcHRpb25zU3F1YXNoTGV2ZWw9e3RoaXMuaGFuZGxlT3B0aW9uc1NxdWFzaExldmVsfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2xpY2UtYnRuLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNsaWNlLWJ0blwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQmVnaW5TbGljQnRufT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGgzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuc2xpY2VUZXh0ID09PSBcInNsaWNlLWJ0blwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkJlZ2luIFNsaWNlIVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiA8aSBjbGFzc05hbWU9XCJpY29uLXNwaW5uZXI4IGFuaW1hdGUtc3BpblwiPjwvaT59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaDM+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICB7LyogQ09ORElUSU9OICovfVxyXG4gICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuaXNBbGVydE1lc3NhZ2VFcnJvck9uQmVnaW5TbGljZUJ0biA9PT0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgID8gPGRpdiBjbGFzc05hbWU9XCJhbGVydC1tZXNzYWdlLS1lcnJvclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJhbGVydC1pY29uIGFsZXJ0LWljb24tLWVycm9yIGljb24td2FybmluZ1wiPjwvaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWxlcnQtbWVzc2FnZS10ZXh0LS1lcnJvclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuYWxlcnRNZXNzYWdlRXJyb3JPbkJlZ2luU2xpY2VCdG59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA6IG51bGx9XHJcbiAgICAgICAgICAgICAgICB7LyogQ09ORElUSU9OICovfVxyXG4gICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuaXNBbGVydE1lc3NhZ2VTdWNjZXNzT25CZWdpblNsaWNlQnRuID09PSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgPyA8ZGl2IGNsYXNzTmFtZT1cImFsZXJ0LW1lc3NhZ2UtLXN1Y2Nlc3NcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiYWxlcnQtaWNvbiBhbGVydC1pY29uLS1zdWNjZXNzIGljb24tY2hlY2tcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFsZXJ0LW1lc3NhZ2UtdGV4dC0tc3VjY2Vzc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuYWxlcnRNZXNzYWdlU3VjY2Vzc09uQmVnaW5TbGljZUJ0bn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbH1cclxuICAgICAgICAgICAgICAgIDxGb3JtUmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgICAgIGdldEltYWdlRGF0YT17dGhpcy5zdGF0ZS5wcm9jZXNzZWRGaWxlRGF0YX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IEZvcm0gZnJvbSBcIi4vc2NyaXB0cy9jb21wb25lbnRzL0Zvcm0uanNcIjtcclxuXHJcblJlYWN0RE9NLnJlbmRlcihcclxuICAgIDxGb3JtIC8+LFxyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm1haW5cIilcclxuKSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///352\n')},703:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"zt\": () => (/* reexport */ components_Provider),\n  \"$j\": () => (/* reexport */ connect)\n});\n\n// UNUSED EXPORTS: ReactReduxContext, batch, connectAdvanced, createDispatchHook, createSelectorHook, createStoreHook, shallowEqual, useDispatch, useSelector, useStore\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(294);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(697);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/Context.js\n\nvar Context_ReactReduxContext = /*#__PURE__*/react.createContext(null);\n\nif (false) {}\n\n/* harmony default export */ const Context = ((/* unused pure expression or super */ null && (Context_ReactReduxContext)));\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/batch.js\n// Default to a dummy \"batch\" implementation that just runs the callback\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\nvar batch = defaultNoopBatch; // Allow injecting another batching function later\n\nvar setBatch = function setBatch(newBatch) {\n  return batch = newBatch;\n}; // Supply a getter just to skip dealing with ESM bindings\n\nvar getBatch = function getBatch() {\n  return batch;\n};\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/Subscription.js\n // encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\nvar nullListeners = {\n  notify: function notify() {}\n};\n\nfunction createListenerCollection() {\n  var batch = getBatch();\n  var first = null;\n  var last = null;\n  return {\n    clear: function clear() {\n      first = null;\n      last = null;\n    },\n    notify: function notify() {\n      batch(function () {\n        var listener = first;\n\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get: function get() {\n      var listeners = [];\n      var listener = first;\n\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n\n      return listeners;\n    },\n    subscribe: function subscribe(callback) {\n      var isSubscribed = true;\n      var listener = last = {\n        callback: callback,\n        next: null,\n        prev: last\n      };\n\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\n\nvar Subscription_Subscription = /*#__PURE__*/function () {\n  function Subscription(store, parentSub) {\n    this.store = store;\n    this.parentSub = parentSub;\n    this.unsubscribe = null;\n    this.listeners = nullListeners;\n    this.handleChangeWrapper = this.handleChangeWrapper.bind(this);\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.addNestedSub = function addNestedSub(listener) {\n    this.trySubscribe();\n    return this.listeners.subscribe(listener);\n  };\n\n  _proto.notifyNestedSubs = function notifyNestedSubs() {\n    this.listeners.notify();\n  };\n\n  _proto.handleChangeWrapper = function handleChangeWrapper() {\n    if (this.onStateChange) {\n      this.onStateChange();\n    }\n  };\n\n  _proto.isSubscribed = function isSubscribed() {\n    return Boolean(this.unsubscribe);\n  };\n\n  _proto.trySubscribe = function trySubscribe() {\n    if (!this.unsubscribe) {\n      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) : this.store.subscribe(this.handleChangeWrapper);\n      this.listeners = createListenerCollection();\n    }\n  };\n\n  _proto.tryUnsubscribe = function tryUnsubscribe() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = null;\n      this.listeners.clear();\n      this.listeners = nullListeners;\n    }\n  };\n\n  return Subscription;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/Provider.js\n\n\n\n\n\nfunction Provider(_ref) {\n  var store = _ref.store,\n      context = _ref.context,\n      children = _ref.children;\n  var contextValue = (0,react.useMemo)(function () {\n    var subscription = new Subscription_Subscription(store);\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    return {\n      store: store,\n      subscription: subscription\n    };\n  }, [store]);\n  var previousState = (0,react.useMemo)(function () {\n    return store.getState();\n  }, [store]);\n  (0,react.useEffect)(function () {\n    var subscription = contextValue.subscription;\n    subscription.trySubscribe();\n\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n\n    return function () {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = null;\n    };\n  }, [contextValue, previousState]);\n  var Context = context || Context_ReactReduxContext;\n  return /*#__PURE__*/react.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\nif (false) {}\n\n/* harmony default export */ const components_Provider = (Provider);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nvar esm_extends = __webpack_require__(122);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nvar objectWithoutPropertiesLoose = __webpack_require__(756);\n// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar hoist_non_react_statics_cjs = __webpack_require__(679);\nvar hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);\n// EXTERNAL MODULE: ./node_modules/react-redux/node_modules/react-is/index.js\nvar react_is = __webpack_require__(973);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js\n // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nvar useIsomorphicLayoutEffect_useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react.useLayoutEffect : react.useEffect;\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/components/connectAdvanced.js\n\n\n\n\n\n\n\n // Define some constant arrays just to avoid re-creating these\n\nvar EMPTY_ARRAY = [];\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\n\nvar stringifyComponent = function stringifyComponent(Comp) {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\n\nfunction storeStateUpdatesReducer(state, action) {\n  var updateCount = state[1];\n  return [action.payload, updateCount + 1];\n}\n\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect_useIsomorphicLayoutEffect(function () {\n    return effectFunc.apply(void 0, effectArgs);\n  }, dependencies);\n}\n\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  // We want to capture the wrapper props and child props we used for later comparisons\n  lastWrapperProps.current = wrapperProps;\n  lastChildProps.current = actualChildProps;\n  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update\n\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\n\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {\n  // If we're not subscribed to the store, nothing to do here\n  if (!shouldHandleStateChanges) return; // Capture values for checking if and when this component unmounts\n\n  var didUnsubscribe = false;\n  var lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component\n\n  var checkForUpdates = function checkForUpdates() {\n    if (didUnsubscribe) {\n      // Don't run stale listeners.\n      // Redux doesn't guarantee unsubscriptions happen until next dispatch.\n      return;\n    }\n\n    var latestStoreState = store.getState();\n    var newChildProps, error;\n\n    try {\n      // Actually run the selector with the most recent store state and wrapper props\n      // to determine what the child props should be\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n\n    if (!error) {\n      lastThrownError = null;\n    } // If the child props haven't changed, nothing to do here - cascade the subscription update\n\n\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      // Save references to the new child props.  Note that we track the \"child props from store update\"\n      // as a ref instead of a useState/useReducer because we need a way to determine if that value has\n      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\n      // forcing another re-render, which we don't want.\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true; // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render\n\n      forceComponentUpdateDispatch({\n        type: 'STORE_UPDATED',\n        payload: {\n          error: error\n        }\n      });\n    }\n  }; // Actually subscribe to the nearest connected ancestor (or store)\n\n\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe(); // Pull data from the store after first render in case the store has\n  // changed since we began.\n\n  checkForUpdates();\n\n  var unsubscribeWrapper = function unsubscribeWrapper() {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n\n    if (lastThrownError) {\n      // It's possible that we caught an error due to a bad mapState function, but the\n      // parent re-rendered without this component and we're about to unmount.\n      // This shouldn't happen as long as we do top-down subscriptions correctly, but\n      // if we ever do those wrong, this throw will surface the error in our tests.\n      // In that case, throw the error from here so it doesn't get lost.\n      throw lastThrownError;\n    }\n  };\n\n  return unsubscribeWrapper;\n}\n\nvar initStateUpdates = function initStateUpdates() {\n  return [null, 0];\n};\n\nfunction connectAdvanced(\n/*\n  selectorFactory is a func that is responsible for returning the selector function used to\n  compute new props from state, props, and dispatch. For example:\n     export default connectAdvanced((dispatch, options) => (state, props) => ({\n      thing: state.things[props.thingId],\n      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),\n    }))(YourComponent)\n   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators\n  outside of their selector as an optimization. Options passed to connectAdvanced are passed to\n  the selectorFactory, along with displayName and WrappedComponent, as the second argument.\n   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound\n  props. Do not use connectAdvanced directly without memoizing results between calls to your\n  selector, otherwise the Connect component will re-render on every state or props change.\n*/\nselectorFactory, // options object:\n_ref) {\n  if (_ref === void 0) {\n    _ref = {};\n  }\n\n  var _ref2 = _ref,\n      _ref2$getDisplayName = _ref2.getDisplayName,\n      getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {\n    return \"ConnectAdvanced(\" + name + \")\";\n  } : _ref2$getDisplayName,\n      _ref2$methodName = _ref2.methodName,\n      methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,\n      _ref2$renderCountProp = _ref2.renderCountProp,\n      renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,\n      _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,\n      shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,\n      _ref2$storeKey = _ref2.storeKey,\n      storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey,\n      _ref2$withRef = _ref2.withRef,\n      withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,\n      _ref2$forwardRef = _ref2.forwardRef,\n      forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef,\n      _ref2$context = _ref2.context,\n      context = _ref2$context === void 0 ? Context_ReactReduxContext : _ref2$context,\n      connectOptions = (0,objectWithoutPropertiesLoose/* default */.Z)(_ref2, [\"getDisplayName\", \"methodName\", \"renderCountProp\", \"shouldHandleStateChanges\", \"storeKey\", \"withRef\", \"forwardRef\", \"context\"]);\n\n  if (false) { var customStoreWarningMessage; }\n\n  var Context = context;\n  return function wrapWithConnect(WrappedComponent) {\n    if (false) {}\n\n    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    var displayName = getDisplayName(wrappedComponentName);\n\n    var selectorFactoryOptions = (0,esm_extends/* default */.Z)({}, connectOptions, {\n      getDisplayName: getDisplayName,\n      methodName: methodName,\n      renderCountProp: renderCountProp,\n      shouldHandleStateChanges: shouldHandleStateChanges,\n      storeKey: storeKey,\n      displayName: displayName,\n      wrappedComponentName: wrappedComponentName,\n      WrappedComponent: WrappedComponent\n    });\n\n    var pure = connectOptions.pure;\n\n    function createChildSelector(store) {\n      return selectorFactory(store.dispatch, selectorFactoryOptions);\n    } // If we aren't running in \"pure\" mode, we don't want to memoize values.\n    // To avoid conditionally calling hooks, we fall back to a tiny wrapper\n    // that just executes the given callback immediately.\n\n\n    var usePureOnlyMemo = pure ? react.useMemo : function (callback) {\n      return callback();\n    };\n\n    function ConnectFunction(props) {\n      var _useMemo = (0,react.useMemo)(function () {\n        // Distinguish between actual \"data\" props that were passed to the wrapper component,\n        // and values needed to control behavior (forwarded refs, alternate context instances).\n        // To maintain the wrapperProps object reference, memoize this destructuring.\n        var reactReduxForwardedRef = props.reactReduxForwardedRef,\n            wrapperProps = (0,objectWithoutPropertiesLoose/* default */.Z)(props, [\"reactReduxForwardedRef\"]);\n\n        return [props.context, reactReduxForwardedRef, wrapperProps];\n      }, [props]),\n          propsContext = _useMemo[0],\n          reactReduxForwardedRef = _useMemo[1],\n          wrapperProps = _useMemo[2];\n\n      var ContextToUse = (0,react.useMemo)(function () {\n        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\n        // Memoize the check that determines which context instance we should use.\n        return propsContext && propsContext.Consumer && (0,react_is.isContextConsumer)( /*#__PURE__*/react.createElement(propsContext.Consumer, null)) ? propsContext : Context;\n      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available\n\n      var contextValue = (0,react.useContext)(ContextToUse); // The store _must_ exist as either a prop or in context.\n      // We'll check to see if it _looks_ like a Redux store first.\n      // This allows us to pass through a `store` prop that is just a plain value.\n\n      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n\n      if (false) {} // Based on the previous check, one of these must be true\n\n\n      var store = didStoreComeFromProps ? props.store : contextValue.store;\n      var childPropsSelector = (0,react.useMemo)(function () {\n        // The child props selector needs the store reference as an input.\n        // Re-create this selector whenever the store changes.\n        return createChildSelector(store);\n      }, [store]);\n\n      var _useMemo2 = (0,react.useMemo)(function () {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\n\n        var subscription = new Subscription_Subscription(store, didStoreComeFromProps ? null : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `subscription` will then be null. This can\n        // probably be avoided if Subscription's listeners logic is changed to not call listeners\n        // that have been unsubscribed in the  middle of the notification loop.\n\n        var notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);\n        return [subscription, notifyNestedSubs];\n      }, [store, didStoreComeFromProps, contextValue]),\n          subscription = _useMemo2[0],\n          notifyNestedSubs = _useMemo2[1]; // Determine what {store, subscription} value should be put into nested context, if necessary,\n      // and memoize that value to avoid unnecessary context updates.\n\n\n      var overriddenContextValue = (0,react.useMemo)(function () {\n        if (didStoreComeFromProps) {\n          // This component is directly subscribed to a store from props.\n          // We don't want descendants reading from this store - pass down whatever\n          // the existing context value is from the nearest connected ancestor.\n          return contextValue;\n        } // Otherwise, put this component's subscription instance into context, so that\n        // connected descendants won't update until after this component is done\n\n\n        return (0,esm_extends/* default */.Z)({}, contextValue, {\n          subscription: subscription\n        });\n      }, [didStoreComeFromProps, contextValue, subscription]); // We need to force this wrapper component to re-render whenever a Redux store update\n      // causes a change to the calculated child component props (or we caught an error in mapState)\n\n      var _useReducer = (0,react.useReducer)(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates),\n          _useReducer$ = _useReducer[0],\n          previousStateUpdateResult = _useReducer$[0],\n          forceComponentUpdateDispatch = _useReducer[1]; // Propagate any mapState/mapDispatch errors upwards\n\n\n      if (previousStateUpdateResult && previousStateUpdateResult.error) {\n        throw previousStateUpdateResult.error;\n      } // Set up refs to coordinate values between the subscription effect and the render logic\n\n\n      var lastChildProps = (0,react.useRef)();\n      var lastWrapperProps = (0,react.useRef)(wrapperProps);\n      var childPropsFromStoreUpdate = (0,react.useRef)();\n      var renderIsScheduled = (0,react.useRef)(false);\n      var actualChildProps = usePureOnlyMemo(function () {\n        // Tricky logic here:\n        // - This render may have been triggered by a Redux store update that produced new child props\n        // - However, we may have gotten new wrapper props after that\n        // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\n        // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\n        // So, we'll use the child props from store update only if the wrapper props are the same as last time.\n        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n          return childPropsFromStoreUpdate.current;\n        } // TODO We're reading the store directly in render() here. Bad idea?\n        // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n        // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n        // to determine what the child props should be.\n\n\n        return childPropsSelector(store.getState(), wrapperProps);\n      }, [store, previousStateUpdateResult, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns\n      // about useLayoutEffect in SSR, so we try to detect environment and fall back to\n      // just useEffect instead to avoid the warning, since neither will run anyway.\n\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]); // Our re-subscribe logic only runs when the store/subscription setup changes\n\n      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]); // Now that all that's done, we can finally try to actually render the child component.\n      // We memoize the elements for the rendered child component as an optimization.\n\n      var renderedWrappedComponent = (0,react.useMemo)(function () {\n        return /*#__PURE__*/react.createElement(WrappedComponent, (0,esm_extends/* default */.Z)({}, actualChildProps, {\n          ref: reactReduxForwardedRef\n        }));\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering\n      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\n\n      var renderedChild = (0,react.useMemo)(function () {\n        if (shouldHandleStateChanges) {\n          // If this component is subscribed to store updates, we need to pass its own\n          // subscription instance down to our descendants. That means rendering the same\n          // Context instance, and putting a different value into the context.\n          return /*#__PURE__*/react.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    } // If we're in \"pure\" mode, ensure our wrapper component only re-renders when incoming props have changed.\n\n\n    var Connect = pure ? react.memo(ConnectFunction) : ConnectFunction;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = displayName;\n\n    if (forwardRef) {\n      var forwarded = react.forwardRef(function forwardConnectRef(props, ref) {\n        return /*#__PURE__*/react.createElement(Connect, (0,esm_extends/* default */.Z)({}, props, {\n          reactReduxForwardedRef: ref\n        }));\n      });\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return hoist_non_react_statics_cjs_default()(forwarded, WrappedComponent);\n    }\n\n    return hoist_non_react_statics_cjs_default()(Connect, WrappedComponent);\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/shallowEqual.js\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n// EXTERNAL MODULE: ./node_modules/redux/es/redux.js\nvar redux = __webpack_require__(890);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/wrapMapToProps.js\n\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch, options) {\n    var constant = getConstant(dispatch, options);\n\n    function constantSelector() {\n      return constant;\n    }\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\n\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, _ref) {\n    var displayName = _ref.displayName;\n\n    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);\n    }; // allow detectFactoryAndVerify to get ownProps\n\n\n    proxy.dependsOnOwnProps = true;\n\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      var props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      if (false) {}\n      return props;\n    };\n\n    return proxy;\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mapDispatchToProps.js\n\n\nfunction whenMapDispatchToPropsIsFunction(mapDispatchToProps) {\n  return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : undefined;\n}\nfunction whenMapDispatchToPropsIsMissing(mapDispatchToProps) {\n  return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {\n    return {\n      dispatch: dispatch\n    };\n  }) : undefined;\n}\nfunction whenMapDispatchToPropsIsObject(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(function (dispatch) {\n    return (0,redux/* bindActionCreators */.DE)(mapDispatchToProps, dispatch);\n  }) : undefined;\n}\n/* harmony default export */ const mapDispatchToProps = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mapStateToProps.js\n\nfunction whenMapStateToPropsIsFunction(mapStateToProps) {\n  return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : undefined;\n}\nfunction whenMapStateToPropsIsMissing(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(function () {\n    return {};\n  }) : undefined;\n}\n/* harmony default export */ const mapStateToProps = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mergeProps.js\n\n\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return (0,esm_extends/* default */.Z)({}, ownProps, stateProps, dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, _ref) {\n    var displayName = _ref.displayName,\n        pure = _ref.pure,\n        areMergedPropsEqual = _ref.areMergedPropsEqual;\n    var hasRunOnce = false;\n    var mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n\n      if (hasRunOnce) {\n        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (false) {}\n      }\n\n      return mergedProps;\n    };\n  };\n}\nfunction whenMergePropsIsFunction(mergeProps) {\n  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;\n}\nfunction whenMergePropsIsOmitted(mergeProps) {\n  return !mergeProps ? function () {\n    return defaultMergeProps;\n  } : undefined;\n}\n/* harmony default export */ const mergeProps = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/selectorFactory.js\n\n\nfunction impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {\n  return function impureFinalPropsSelector(state, ownProps) {\n    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);\n  };\n}\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {\n  var areStatesEqual = _ref.areStatesEqual,\n      areOwnPropsEqual = _ref.areOwnPropsEqual,\n      areStatePropsEqual = _ref.areStatePropsEqual;\n  var hasRunAtLeastOnce = false;\n  var state;\n  var ownProps;\n  var stateProps;\n  var dispatchProps;\n  var mergedProps;\n\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewState() {\n    var nextStateProps = mapStateToProps(state, ownProps);\n    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    var stateChanged = !areStatesEqual(nextState, state);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n} // TODO: Add more comments\n// If pure is true, the selector returned by selectorFactory will memoize its results,\n// allowing connectAdvanced's shouldComponentUpdate to return false if final\n// props have not changed. If false, the selector will always return a new\n// object and shouldComponentUpdate will always return true.\n\nfunction finalPropsSelectorFactory(dispatch, _ref2) {\n  var initMapStateToProps = _ref2.initMapStateToProps,\n      initMapDispatchToProps = _ref2.initMapDispatchToProps,\n      initMergeProps = _ref2.initMergeProps,\n      options = (0,objectWithoutPropertiesLoose/* default */.Z)(_ref2, [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"]);\n\n  var mapStateToProps = initMapStateToProps(dispatch, options);\n  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  var mergeProps = initMergeProps(dispatch, options);\n\n  if (false) {}\n\n  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;\n  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/connect.js\n\n\n\n\n\n\n\n\n/*\n  connect is a facade over connectAdvanced. It turns its args into a compatible\n  selectorFactory, which has the signature:\n\n    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps\n  \n  connect passes its args to connectAdvanced as options, which will in turn pass them to\n  selectorFactory each time a Connect component instance is instantiated or hot reloaded.\n\n  selectorFactory returns a final props selector from its mapStateToProps,\n  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,\n  mergePropsFactories, and pure args.\n\n  The resulting final props selector is called by the Connect component instance whenever\n  it receives new props or store state.\n */\n\nfunction match(arg, factories, name) {\n  for (var i = factories.length - 1; i >= 0; i--) {\n    var result = factories[i](arg);\n    if (result) return result;\n  }\n\n  return function (dispatch, options) {\n    throw new Error(\"Invalid value of type \" + typeof arg + \" for \" + name + \" argument when connecting component \" + options.wrappedComponentName + \".\");\n  };\n}\n\nfunction strictEqual(a, b) {\n  return a === b;\n} // createConnect with default args builds the 'official' connect behavior. Calling it with\n// different options opens up some testing and extensibility scenarios\n\n\nfunction createConnect(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$connectHOC = _ref.connectHOC,\n      connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC,\n      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,\n      mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? mapStateToProps : _ref$mapStateToPropsF,\n      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,\n      mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? mapDispatchToProps : _ref$mapDispatchToPro,\n      _ref$mergePropsFactor = _ref.mergePropsFactories,\n      mergePropsFactories = _ref$mergePropsFactor === void 0 ? mergeProps : _ref$mergePropsFactor,\n      _ref$selectorFactory = _ref.selectorFactory,\n      selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;\n\n  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {\n    if (_ref2 === void 0) {\n      _ref2 = {};\n    }\n\n    var _ref3 = _ref2,\n        _ref3$pure = _ref3.pure,\n        pure = _ref3$pure === void 0 ? true : _ref3$pure,\n        _ref3$areStatesEqual = _ref3.areStatesEqual,\n        areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,\n        _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,\n        areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua,\n        _ref3$areStatePropsEq = _ref3.areStatePropsEqual,\n        areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq,\n        _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,\n        areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE,\n        extraOptions = (0,objectWithoutPropertiesLoose/* default */.Z)(_ref3, [\"pure\", \"areStatesEqual\", \"areOwnPropsEqual\", \"areStatePropsEqual\", \"areMergedPropsEqual\"]);\n\n    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');\n    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');\n    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');\n    return connectHOC(selectorFactory, (0,esm_extends/* default */.Z)({\n      // used in error messages\n      methodName: 'connect',\n      // used to compute Connect's displayName from the wrapped component's displayName.\n      getDisplayName: function getDisplayName(name) {\n        return \"Connect(\" + name + \")\";\n      },\n      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes\n      shouldHandleStateChanges: Boolean(mapStateToProps),\n      // passed through to selectorFactory\n      initMapStateToProps: initMapStateToProps,\n      initMapDispatchToProps: initMapDispatchToProps,\n      initMergeProps: initMergeProps,\n      pure: pure,\n      areStatesEqual: areStatesEqual,\n      areOwnPropsEqual: areOwnPropsEqual,\n      areStatePropsEqual: areStatePropsEqual,\n      areMergedPropsEqual: areMergedPropsEqual\n    }, extraOptions));\n  };\n}\n/* harmony default export */ const connect = (/*#__PURE__*/createConnect());\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useReduxContext.js\n\n\n/**\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\n * hook that you should usually not need to call directly.\n *\n * @returns {any} the value of the `ReactReduxContext`\n *\n * @example\n *\n * import React from 'react'\n * import { useReduxContext } from 'react-redux'\n *\n * export const CounterComponent = ({ value }) => {\n *   const { store } = useReduxContext()\n *   return <div>{store.getState()}</div>\n * }\n */\n\nfunction useReduxContext() {\n  var contextValue = useContext(ReactReduxContext);\n\n  if (false) {}\n\n  return contextValue;\n}\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useStore.js\n\n\n\n/**\n * Hook factory, which creates a `useStore` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useStore` hook bound to the specified context.\n */\n\nfunction useStore_createStoreHook(context) {\n  if (context === void 0) {\n    context = ReactReduxContext;\n  }\n\n  var useReduxContext = context === ReactReduxContext ? useDefaultReduxContext : function () {\n    return useContext(context);\n  };\n  return function useStore() {\n    var _useReduxContext = useReduxContext(),\n        store = _useReduxContext.store;\n\n    return store;\n  };\n}\n/**\n * A hook to access the redux store.\n *\n * @returns {any} the redux store\n *\n * @example\n *\n * import React from 'react'\n * import { useStore } from 'react-redux'\n *\n * export const ExampleComponent = () => {\n *   const store = useStore()\n *   return <div>{store.getState()}</div>\n * }\n */\n\nvar useStore = /*#__PURE__*/(/* unused pure expression or super */ null && (useStore_createStoreHook()));\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useDispatch.js\n\n\n/**\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useDispatch` hook bound to the specified context.\n */\n\nfunction createDispatchHook(context) {\n  if (context === void 0) {\n    context = ReactReduxContext;\n  }\n\n  var useStore = context === ReactReduxContext ? useDefaultStore : createStoreHook(context);\n  return function useDispatch() {\n    var store = useStore();\n    return store.dispatch;\n  };\n}\n/**\n * A hook to access the redux `dispatch` function.\n *\n * @returns {any|function} redux store's `dispatch` function\n *\n * @example\n *\n * import React, { useCallback } from 'react'\n * import { useDispatch } from 'react-redux'\n *\n * export const CounterComponent = ({ value }) => {\n *   const dispatch = useDispatch()\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\n *   return (\n *     <div>\n *       <span>{value}</span>\n *       <button onClick={increaseCounter}>Increase counter</button>\n *     </div>\n *   )\n * }\n */\n\nvar useDispatch = /*#__PURE__*/(/* unused pure expression or super */ null && (createDispatchHook()));\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useSelector.js\n\n\n\n\n\n\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\n\nfunction useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {\n  var _useReducer = useReducer(function (s) {\n    return s + 1;\n  }, 0),\n      forceRender = _useReducer[1];\n\n  var subscription = useMemo(function () {\n    return new Subscription(store, contextSub);\n  }, [store, contextSub]);\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef();\n  var latestStoreState = useRef();\n  var latestSelectedState = useRef();\n  var storeState = store.getState();\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(storeState);\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\" + latestSubscriptionCallbackError.current.stack + \"\\n\\n\";\n    }\n\n    throw err;\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    latestSelector.current = selector;\n    latestStoreState.current = storeState;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(function () {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(store.getState());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender();\n    }\n\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    return function () {\n      return subscription.tryUnsubscribe();\n    };\n  }, [store, subscription]);\n  return selectedState;\n}\n/**\n * Hook factory, which creates a `useSelector` hook bound to a given context.\n *\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\n * @returns {Function} A `useSelector` hook bound to the specified context.\n */\n\n\nfunction createSelectorHook(context) {\n  if (context === void 0) {\n    context = ReactReduxContext;\n  }\n\n  var useReduxContext = context === ReactReduxContext ? useDefaultReduxContext : function () {\n    return useContext(context);\n  };\n  return function useSelector(selector, equalityFn) {\n    if (equalityFn === void 0) {\n      equalityFn = refEquality;\n    }\n\n    if (false) {}\n\n    var _useReduxContext = useReduxContext(),\n        store = _useReduxContext.store,\n        contextSub = _useReduxContext.subscription;\n\n    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);\n    useDebugValue(selectedState);\n    return selectedState;\n  };\n}\n/**\n * A hook to access the redux store's state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param {Function} selector the selector function\n * @param {Function=} equalityFn the function that will be used to determine equality\n *\n * @returns {any} the selected state\n *\n * @example\n *\n * import React from 'react'\n * import { useSelector } from 'react-redux'\n *\n * export const CounterComponent = () => {\n *   const counter = useSelector(state => state.counter)\n *   return <div>{counter}</div>\n * }\n */\n\nvar useSelector = /*#__PURE__*/(/* unused pure expression or super */ null && (createSelectorHook()));\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(935);\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/reactBatchedUpdates.js\n/* eslint-disable import/no-unresolved */\n\n;// CONCATENATED MODULE: ./node_modules/react-redux/es/index.js\n\n\n\n\n\n\n\n\n\n\nsetBatch(react_dom.unstable_batchedUpdates);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Db250ZXh0LmpzPzhlODciLCJ3ZWJwYWNrOi8vc3VwZXItY29taWMtc2xpY2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL2JhdGNoLmpzPzRkZjIiLCJ3ZWJwYWNrOi8vc3VwZXItY29taWMtc2xpY2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL1N1YnNjcmlwdGlvbi5qcz83OWQ2Iiwid2VicGFjazovL3N1cGVyLWNvbWljLXNsaWNlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzPzExZjgiLCJ3ZWJwYWNrOi8vc3VwZXItY29taWMtc2xpY2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QuanM/NTdlNiIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQuanM/ZmUzMyIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvc2hhbGxvd0VxdWFsLmpzPzFhMDgiLCJ3ZWJwYWNrOi8vc3VwZXItY29taWMtc2xpY2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanM/MjQyNSIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanM/MmY1ZCIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMuanM/ZTQ1NyIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tZXJnZVByb3BzLmpzP2JmNGMiLCJ3ZWJwYWNrOi8vc3VwZXItY29taWMtc2xpY2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LmpzPzc5MDYiLCJ3ZWJwYWNrOi8vc3VwZXItY29taWMtc2xpY2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvY29ubmVjdC5qcz8zYjUxIiwid2VicGFjazovL3N1cGVyLWNvbWljLXNsaWNlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VSZWR1eENvbnRleHQuanM/OTgyNSIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaG9va3MvdXNlU3RvcmUuanM/Y2I4NyIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaG9va3MvdXNlRGlzcGF0Y2guanM/ZWUyNCIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaG9va3MvdXNlU2VsZWN0b3IuanM/MzM5YyIsIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvcmVhY3RCYXRjaGVkVXBkYXRlcy5qcz9mNWY1Iiwid2VicGFjazovL3N1cGVyLWNvbWljLXNsaWNlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9pbmRleC5qcz9mY2MyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ25CLElBQUkseUJBQWlCLGdCQUFnQixtQkFBbUI7O0FB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Q0FBQyxpQ0FBSyIsImZpbGUiOiI3MDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IHZhciBSZWFjdFJlZHV4Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFJlZHV4Q29udGV4dC5kaXNwbGF5TmFtZSA9ICdSZWFjdFJlZHV4Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RSZWR1eENvbnRleHQ7IiwiLy8gRGVmYXVsdCB0byBhIGR1bW15IFwiYmF0Y2hcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGp1c3QgcnVucyB0aGUgY2FsbGJhY2tcbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxudmFyIGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaDsgLy8gQWxsb3cgaW5qZWN0aW5nIGFub3RoZXIgYmF0Y2hpbmcgZnVuY3Rpb24gbGF0ZXJcblxuZXhwb3J0IHZhciBzZXRCYXRjaCA9IGZ1bmN0aW9uIHNldEJhdGNoKG5ld0JhdGNoKSB7XG4gIHJldHVybiBiYXRjaCA9IG5ld0JhdGNoO1xufTsgLy8gU3VwcGx5IGEgZ2V0dGVyIGp1c3QgdG8gc2tpcCBkZWFsaW5nIHdpdGggRVNNIGJpbmRpbmdzXG5cbmV4cG9ydCB2YXIgZ2V0QmF0Y2ggPSBmdW5jdGlvbiBnZXRCYXRjaCgpIHtcbiAgcmV0dXJuIGJhdGNoO1xufTsiLCJpbXBvcnQgeyBnZXRCYXRjaCB9IGZyb20gJy4vYmF0Y2gnOyAvLyBlbmNhcHN1bGF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhIGNvbXBvbmVudCB0byB0aGUgcmVkdXggc3RvcmUsIGFzXG4vLyB3ZWxsIGFzIG5lc3Rpbmcgc3Vic2NyaXB0aW9ucyBvZiBkZXNjZW5kYW50IGNvbXBvbmVudHMsIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSB0aGVcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgcmUtcmVuZGVyIGJlZm9yZSBkZXNjZW5kYW50c1xuXG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7fVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICB2YXIgYmF0Y2ggPSBnZXRCYXRjaCgpO1xuICB2YXIgZmlyc3QgPSBudWxsO1xuICB2YXIgbGFzdCA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZmlyc3QgPSBudWxsO1xuICAgICAgbGFzdCA9IG51bGw7XG4gICAgfSxcbiAgICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIGJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZmlyc3Q7XG5cbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmaXJzdDtcblxuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGFzdCA9IHtcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuXG4gICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0ID0gbGlzdGVuZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTdWJzY3JpcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yikge1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLnBhcmVudFN1YiA9IHBhcmVudFN1YjtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgdGhpcy5oYW5kbGVDaGFuZ2VXcmFwcGVyID0gdGhpcy5oYW5kbGVDaGFuZ2VXcmFwcGVyLmJpbmQodGhpcyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3Vic2NyaXB0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkTmVzdGVkU3ViID0gZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8ubm90aWZ5TmVzdGVkU3VicyA9IGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMubm90aWZ5KCk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZUNoYW5nZVdyYXBwZXIgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmICh0aGlzLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudW5zdWJzY3JpYmUpO1xuICB9O1xuXG4gIF9wcm90by50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5wYXJlbnRTdWIgPyB0aGlzLnBhcmVudFN1Yi5hZGROZXN0ZWRTdWIodGhpcy5oYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHRoaXMuc3RvcmUuc3Vic2NyaWJlKHRoaXMuaGFuZGxlQ2hhbmdlV3JhcHBlcik7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG5leHBvcnQgeyBTdWJzY3JpcHRpb24gYXMgZGVmYXVsdCB9OyIsImltcG9ydCBSZWFjdCwgeyB1c2VNZW1vLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0IFN1YnNjcmlwdGlvbiBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nO1xuXG5mdW5jdGlvbiBQcm92aWRlcihfcmVmKSB7XG4gIHZhciBzdG9yZSA9IF9yZWYuc3RvcmUsXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgY29udGV4dFZhbHVlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uXG4gICAgfTtcbiAgfSwgW3N0b3JlXSk7XG4gIHZhciBwcmV2aW91c1N0YXRlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCk7XG4gIH0sIFtzdG9yZV0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjb250ZXh0VmFsdWUuc3Vic2NyaXB0aW9uO1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcblxuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIHZhciBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICAgIHN0b3JlOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgZGlzcGF0Y2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICBnZXRTdGF0ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLFxuICAgIGNvbnRleHQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnlcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvdmlkZXI7IiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7IC8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLiBXZSBuZWVkIHVzZUxheW91dEVmZmVjdCB0byBlbnN1cmUgdGhlIHN0b3JlXG4vLyBzdWJzY3JpcHRpb24gY2FsbGJhY2sgYWx3YXlzIGhhcyB0aGUgc2VsZWN0b3IgZnJvbSB0aGUgbGF0ZXN0IHJlbmRlciBjb21taXRcbi8vIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc3RvcmUgdXBkYXRlIG1heSBoYXBwZW4gYmV0d2VlbiByZW5kZXIgYW5kIHRoZSBlZmZlY3QsXG4vLyB3aGljaCBtYXkgY2F1c2UgbWlzc2VkIHVwZGF0ZXM7IHdlIGFsc28gbXVzdCBlbnN1cmUgdGhlIHN0b3JlIHN1YnNjcmlwdGlvblxuLy8gaXMgY3JlYXRlZCBzeW5jaHJvbm91c2x5LCBvdGhlcndpc2UgYSBzdG9yZSB1cGRhdGUgbWF5IG9jY3VyIGJlZm9yZSB0aGVcbi8vIHN1YnNjcmlwdGlvbiBpcyBjcmVhdGVkIGFuZCBhbiBpbmNvbnNpc3RlbnQgc3RhdGUgbWF5IGJlIG9ic2VydmVkXG5cbmV4cG9ydCB2YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZVJlZiwgdXNlUmVkdWNlciB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50VHlwZSwgaXNDb250ZXh0Q29uc3VtZXIgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vQ29udGV4dCc7IC8vIERlZmluZSBzb21lIGNvbnN0YW50IGFycmF5cyBqdXN0IHRvIGF2b2lkIHJlLWNyZWF0aW5nIHRoZXNlXG5cbnZhciBFTVBUWV9BUlJBWSA9IFtdO1xudmFyIE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXTtcblxudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IGZ1bmN0aW9uIHN0cmluZ2lmeUNvbXBvbmVudChDb21wKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdG9yZVN0YXRlVXBkYXRlc1JlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICB2YXIgdXBkYXRlQ291bnQgPSBzdGF0ZVsxXTtcbiAgcmV0dXJuIFthY3Rpb24ucGF5bG9hZCwgdXBkYXRlQ291bnQgKyAxXTtcbn1cblxuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWZmZWN0RnVuYy5hcHBseSh2b2lkIDAsIGVmZmVjdEFyZ3MpO1xuICB9LCBkZXBlbmRlbmNpZXMpO1xufVxuXG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBhY3R1YWxDaGlsZFByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIC8vIFdlIHdhbnQgdG8gY2FwdHVyZSB0aGUgd3JhcHBlciBwcm9wcyBhbmQgY2hpbGQgcHJvcHMgd2UgdXNlZCBmb3IgbGF0ZXIgY29tcGFyaXNvbnNcbiAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50ID0gd3JhcHBlclByb3BzO1xuICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gYWN0dWFsQ2hpbGRQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlOyAvLyBJZiB0aGUgcmVuZGVyIHdhcyBmcm9tIGEgc3RvcmUgdXBkYXRlLCBjbGVhciBvdXQgdGhhdCByZWZlcmVuY2UgYW5kIGNhc2NhZGUgdGhlIHN1YnNjcmliZXIgdXBkYXRlXG5cbiAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCkge1xuICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG51bGw7XG4gICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgZm9yY2VDb21wb25lbnRVcGRhdGVEaXNwYXRjaCkge1xuICAvLyBJZiB3ZSdyZSBub3Qgc3Vic2NyaWJlZCB0byB0aGUgc3RvcmUsIG5vdGhpbmcgdG8gZG8gaGVyZVxuICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuOyAvLyBDYXB0dXJlIHZhbHVlcyBmb3IgY2hlY2tpbmcgaWYgYW5kIHdoZW4gdGhpcyBjb21wb25lbnQgdW5tb3VudHNcblxuICB2YXIgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RUaHJvd25FcnJvciA9IG51bGw7IC8vIFdlJ2xsIHJ1biB0aGlzIGNhbGxiYWNrIGV2ZXJ5IHRpbWUgYSBzdG9yZSBzdWJzY3JpcHRpb24gdXBkYXRlIHByb3BhZ2F0ZXMgdG8gdGhpcyBjb21wb25lbnRcblxuICB2YXIgY2hlY2tGb3JVcGRhdGVzID0gZnVuY3Rpb24gY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgIGlmIChkaWRVbnN1YnNjcmliZSkge1xuICAgICAgLy8gRG9uJ3QgcnVuIHN0YWxlIGxpc3RlbmVycy5cbiAgICAgIC8vIFJlZHV4IGRvZXNuJ3QgZ3VhcmFudGVlIHVuc3Vic2NyaXB0aW9ucyBoYXBwZW4gdW50aWwgbmV4dCBkaXNwYXRjaC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgdmFyIG5ld0NoaWxkUHJvcHMsIGVycm9yO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFjdHVhbGx5IHJ1biB0aGUgc2VsZWN0b3Igd2l0aCB0aGUgbW9zdCByZWNlbnQgc3RvcmUgc3RhdGUgYW5kIHdyYXBwZXIgcHJvcHNcbiAgICAgIC8vIHRvIGRldGVybWluZSB3aGF0IHRoZSBjaGlsZCBwcm9wcyBzaG91bGQgYmVcbiAgICAgIG5ld0NoaWxkUHJvcHMgPSBjaGlsZFByb3BzU2VsZWN0b3IobGF0ZXN0U3RvcmVTdGF0ZSwgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlO1xuICAgIH1cblxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfSAvLyBJZiB0aGUgY2hpbGQgcHJvcHMgaGF2ZW4ndCBjaGFuZ2VkLCBub3RoaW5nIHRvIGRvIGhlcmUgLSBjYXNjYWRlIHRoZSBzdWJzY3JpcHRpb24gdXBkYXRlXG5cblxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTYXZlIHJlZmVyZW5jZXMgdG8gdGhlIG5ldyBjaGlsZCBwcm9wcy4gIE5vdGUgdGhhdCB3ZSB0cmFjayB0aGUgXCJjaGlsZCBwcm9wcyBmcm9tIHN0b3JlIHVwZGF0ZVwiXG4gICAgICAvLyBhcyBhIHJlZiBpbnN0ZWFkIG9mIGEgdXNlU3RhdGUvdXNlUmVkdWNlciBiZWNhdXNlIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoYXQgdmFsdWUgaGFzXG4gICAgICAvLyBiZWVuIHByb2Nlc3NlZC4gIElmIHRoaXMgd2VudCBpbnRvIHVzZVN0YXRlL3VzZVJlZHVjZXIsIHdlIGNvdWxkbid0IGNsZWFyIG91dCB0aGUgdmFsdWUgd2l0aG91dFxuICAgICAgLy8gZm9yY2luZyBhbm90aGVyIHJlLXJlbmRlciwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSB0cnVlOyAvLyBJZiB0aGUgY2hpbGQgcHJvcHMgX2RpZF8gY2hhbmdlIChvciB3ZSBjYXVnaHQgYW4gZXJyb3IpLCB0aGlzIHdyYXBwZXIgY29tcG9uZW50IG5lZWRzIHRvIHJlLXJlbmRlclxuXG4gICAgICBmb3JjZUNvbXBvbmVudFVwZGF0ZURpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1NUT1JFX1VQREFURUQnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTsgLy8gQWN0dWFsbHkgc3Vic2NyaWJlIHRvIHRoZSBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3RvciAob3Igc3RvcmUpXG5cblxuICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IGNoZWNrRm9yVXBkYXRlcztcbiAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpOyAvLyBQdWxsIGRhdGEgZnJvbSB0aGUgc3RvcmUgYWZ0ZXIgZmlyc3QgcmVuZGVyIGluIGNhc2UgdGhlIHN0b3JlIGhhc1xuICAvLyBjaGFuZ2VkIHNpbmNlIHdlIGJlZ2FuLlxuXG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuXG4gIHZhciB1bnN1YnNjcmliZVdyYXBwZXIgPSBmdW5jdGlvbiB1bnN1YnNjcmliZVdyYXBwZXIoKSB7XG4gICAgZGlkVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcblxuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB3ZSBjYXVnaHQgYW4gZXJyb3IgZHVlIHRvIGEgYmFkIG1hcFN0YXRlIGZ1bmN0aW9uLCBidXQgdGhlXG4gICAgICAvLyBwYXJlbnQgcmUtcmVuZGVyZWQgd2l0aG91dCB0aGlzIGNvbXBvbmVudCBhbmQgd2UncmUgYWJvdXQgdG8gdW5tb3VudC5cbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBhcyBsb25nIGFzIHdlIGRvIHRvcC1kb3duIHN1YnNjcmlwdGlvbnMgY29ycmVjdGx5LCBidXRcbiAgICAgIC8vIGlmIHdlIGV2ZXIgZG8gdGhvc2Ugd3JvbmcsIHRoaXMgdGhyb3cgd2lsbCBzdXJmYWNlIHRoZSBlcnJvciBpbiBvdXIgdGVzdHMuXG4gICAgICAvLyBJbiB0aGF0IGNhc2UsIHRocm93IHRoZSBlcnJvciBmcm9tIGhlcmUgc28gaXQgZG9lc24ndCBnZXQgbG9zdC5cbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVuc3Vic2NyaWJlV3JhcHBlcjtcbn1cblxudmFyIGluaXRTdGF0ZVVwZGF0ZXMgPSBmdW5jdGlvbiBpbml0U3RhdGVVcGRhdGVzKCkge1xuICByZXR1cm4gW251bGwsIDBdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29ubmVjdEFkdmFuY2VkKFxuLypcbiAgc2VsZWN0b3JGYWN0b3J5IGlzIGEgZnVuYyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciByZXR1cm5pbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHVzZWQgdG9cbiAgY29tcHV0ZSBuZXcgcHJvcHMgZnJvbSBzdGF0ZSwgcHJvcHMsIGFuZCBkaXNwYXRjaC4gRm9yIGV4YW1wbGU6XG4gICAgIGV4cG9ydCBkZWZhdWx0IGNvbm5lY3RBZHZhbmNlZCgoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IChzdGF0ZSwgcHJvcHMpID0+ICh7XG4gICAgICB0aGluZzogc3RhdGUudGhpbmdzW3Byb3BzLnRoaW5nSWRdLFxuICAgICAgc2F2ZVRoaW5nOiBmaWVsZHMgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvcnMuc2F2ZVRoaW5nKHByb3BzLnRoaW5nSWQsIGZpZWxkcykpLFxuICAgIH0pKShZb3VyQ29tcG9uZW50KVxuICAgQWNjZXNzIHRvIGRpc3BhdGNoIGlzIHByb3ZpZGVkIHRvIHRoZSBmYWN0b3J5IHNvIHNlbGVjdG9yRmFjdG9yaWVzIGNhbiBiaW5kIGFjdGlvbkNyZWF0b3JzXG4gIG91dHNpZGUgb2YgdGhlaXIgc2VsZWN0b3IgYXMgYW4gb3B0aW1pemF0aW9uLiBPcHRpb25zIHBhc3NlZCB0byBjb25uZWN0QWR2YW5jZWQgYXJlIHBhc3NlZCB0b1xuICB0aGUgc2VsZWN0b3JGYWN0b3J5LCBhbG9uZyB3aXRoIGRpc3BsYXlOYW1lIGFuZCBXcmFwcGVkQ29tcG9uZW50LCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgTm90ZSB0aGF0IHNlbGVjdG9yRmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgYWxsIGNhY2hpbmcvbWVtb2l6YXRpb24gb2YgaW5ib3VuZCBhbmQgb3V0Ym91bmRcbiAgcHJvcHMuIERvIG5vdCB1c2UgY29ubmVjdEFkdmFuY2VkIGRpcmVjdGx5IHdpdGhvdXQgbWVtb2l6aW5nIHJlc3VsdHMgYmV0d2VlbiBjYWxscyB0byB5b3VyXG4gIHNlbGVjdG9yLCBvdGhlcndpc2UgdGhlIENvbm5lY3QgY29tcG9uZW50IHdpbGwgcmUtcmVuZGVyIG9uIGV2ZXJ5IHN0YXRlIG9yIHByb3BzIGNoYW5nZS5cbiovXG5zZWxlY3RvckZhY3RvcnksIC8vIG9wdGlvbnMgb2JqZWN0OlxuX3JlZikge1xuICBpZiAoX3JlZiA9PT0gdm9pZCAwKSB7XG4gICAgX3JlZiA9IHt9O1xuICB9XG5cbiAgdmFyIF9yZWYyID0gX3JlZixcbiAgICAgIF9yZWYyJGdldERpc3BsYXlOYW1lID0gX3JlZjIuZ2V0RGlzcGxheU5hbWUsXG4gICAgICBnZXREaXNwbGF5TmFtZSA9IF9yZWYyJGdldERpc3BsYXlOYW1lID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBcIkNvbm5lY3RBZHZhbmNlZChcIiArIG5hbWUgKyBcIilcIjtcbiAgfSA6IF9yZWYyJGdldERpc3BsYXlOYW1lLFxuICAgICAgX3JlZjIkbWV0aG9kTmFtZSA9IF9yZWYyLm1ldGhvZE5hbWUsXG4gICAgICBtZXRob2ROYW1lID0gX3JlZjIkbWV0aG9kTmFtZSA9PT0gdm9pZCAwID8gJ2Nvbm5lY3RBZHZhbmNlZCcgOiBfcmVmMiRtZXRob2ROYW1lLFxuICAgICAgX3JlZjIkcmVuZGVyQ291bnRQcm9wID0gX3JlZjIucmVuZGVyQ291bnRQcm9wLFxuICAgICAgcmVuZGVyQ291bnRQcm9wID0gX3JlZjIkcmVuZGVyQ291bnRQcm9wID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmMiRyZW5kZXJDb3VudFByb3AsXG4gICAgICBfcmVmMiRzaG91bGRIYW5kbGVTdGEgPSBfcmVmMi5zaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBfcmVmMiRzaG91bGRIYW5kbGVTdGEgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRzaG91bGRIYW5kbGVTdGEsXG4gICAgICBfcmVmMiRzdG9yZUtleSA9IF9yZWYyLnN0b3JlS2V5LFxuICAgICAgc3RvcmVLZXkgPSBfcmVmMiRzdG9yZUtleSA9PT0gdm9pZCAwID8gJ3N0b3JlJyA6IF9yZWYyJHN0b3JlS2V5LFxuICAgICAgX3JlZjIkd2l0aFJlZiA9IF9yZWYyLndpdGhSZWYsXG4gICAgICB3aXRoUmVmID0gX3JlZjIkd2l0aFJlZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiR3aXRoUmVmLFxuICAgICAgX3JlZjIkZm9yd2FyZFJlZiA9IF9yZWYyLmZvcndhcmRSZWYsXG4gICAgICBmb3J3YXJkUmVmID0gX3JlZjIkZm9yd2FyZFJlZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRmb3J3YXJkUmVmLFxuICAgICAgX3JlZjIkY29udGV4dCA9IF9yZWYyLmNvbnRleHQsXG4gICAgICBjb250ZXh0ID0gX3JlZjIkY29udGV4dCA9PT0gdm9pZCAwID8gUmVhY3RSZWR1eENvbnRleHQgOiBfcmVmMiRjb250ZXh0LFxuICAgICAgY29ubmVjdE9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiZ2V0RGlzcGxheU5hbWVcIiwgXCJtZXRob2ROYW1lXCIsIFwicmVuZGVyQ291bnRQcm9wXCIsIFwic2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzXCIsIFwic3RvcmVLZXlcIiwgXCJ3aXRoUmVmXCIsIFwiZm9yd2FyZFJlZlwiLCBcImNvbnRleHRcIl0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHJlbmRlckNvdW50UHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXJDb3VudFByb3AgaXMgcmVtb3ZlZC4gcmVuZGVyIGNvdW50aW5nIGlzIGJ1aWx0IGludG8gdGhlIGxhdGVzdCBSZWFjdCBEZXYgVG9vbHMgcHJvZmlsaW5nIGV4dGVuc2lvblwiKTtcbiAgICB9XG5cbiAgICBpZiAod2l0aFJlZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aXRoUmVmIGlzIHJlbW92ZWQuIFRvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgdXNlIGEgcmVmIG9uIHRoZSBjb25uZWN0ZWQgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgdmFyIGN1c3RvbVN0b3JlV2FybmluZ01lc3NhZ2UgPSAnVG8gdXNlIGEgY3VzdG9tIFJlZHV4IHN0b3JlIGZvciBzcGVjaWZpYyBjb21wb25lbnRzLCBjcmVhdGUgYSBjdXN0b20gUmVhY3QgY29udGV4dCB3aXRoICcgKyBcIlJlYWN0LmNyZWF0ZUNvbnRleHQoKSwgYW5kIHBhc3MgdGhlIGNvbnRleHQgb2JqZWN0IHRvIFJlYWN0IFJlZHV4J3MgUHJvdmlkZXIgYW5kIHNwZWNpZmljIGNvbXBvbmVudHNcIiArICcgbGlrZTogPFByb3ZpZGVyIGNvbnRleHQ9e015Q29udGV4dH0+PENvbm5lY3RlZENvbXBvbmVudCBjb250ZXh0PXtNeUNvbnRleHR9IC8+PC9Qcm92aWRlcj4uICcgKyAnWW91IG1heSBhbHNvIHBhc3MgYSB7Y29udGV4dCA6IE15Q29udGV4dH0gb3B0aW9uIHRvIGNvbm5lY3QnO1xuXG4gICAgaWYgKHN0b3JlS2V5ICE9PSAnc3RvcmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3JlS2V5IGhhcyBiZWVuIHJlbW92ZWQgYW5kIGRvZXMgbm90IGRvIGFueXRoaW5nLiAnICsgY3VzdG9tU3RvcmVXYXJuaW5nTWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIENvbnRleHQgPSBjb250ZXh0O1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBcIiArIChtZXRob2ROYW1lICsgXCIuIEluc3RlYWQgcmVjZWl2ZWQgXCIgKyBzdHJpbmdpZnlDb21wb25lbnQoV3JhcHBlZENvbXBvbmVudCkpKTtcbiAgICB9XG5cbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZSh3cmFwcGVkQ29tcG9uZW50TmFtZSk7XG5cbiAgICB2YXIgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBjb25uZWN0T3B0aW9ucywge1xuICAgICAgZ2V0RGlzcGxheU5hbWU6IGdldERpc3BsYXlOYW1lLFxuICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgIHJlbmRlckNvdW50UHJvcDogcmVuZGVyQ291bnRQcm9wLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzdG9yZUtleTogc3RvcmVLZXksXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZTogd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiBXcmFwcGVkQ29tcG9uZW50XG4gICAgfSk7XG5cbiAgICB2YXIgcHVyZSA9IGNvbm5lY3RPcHRpb25zLnB1cmU7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZFNlbGVjdG9yKHN0b3JlKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGYWN0b3J5KHN0b3JlLmRpc3BhdGNoLCBzZWxlY3RvckZhY3RvcnlPcHRpb25zKTtcbiAgICB9IC8vIElmIHdlIGFyZW4ndCBydW5uaW5nIGluIFwicHVyZVwiIG1vZGUsIHdlIGRvbid0IHdhbnQgdG8gbWVtb2l6ZSB2YWx1ZXMuXG4gICAgLy8gVG8gYXZvaWQgY29uZGl0aW9uYWxseSBjYWxsaW5nIGhvb2tzLCB3ZSBmYWxsIGJhY2sgdG8gYSB0aW55IHdyYXBwZXJcbiAgICAvLyB0aGF0IGp1c3QgZXhlY3V0ZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGltbWVkaWF0ZWx5LlxuXG5cbiAgICB2YXIgdXNlUHVyZU9ubHlNZW1vID0gcHVyZSA/IHVzZU1lbW8gOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDb25uZWN0RnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIHZhciBfdXNlTWVtbyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGFjdHVhbCBcImRhdGFcIiBwcm9wcyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVyIGNvbXBvbmVudCxcbiAgICAgICAgLy8gYW5kIHZhbHVlcyBuZWVkZWQgdG8gY29udHJvbCBiZWhhdmlvciAoZm9yd2FyZGVkIHJlZnMsIGFsdGVybmF0ZSBjb250ZXh0IGluc3RhbmNlcykuXG4gICAgICAgIC8vIFRvIG1haW50YWluIHRoZSB3cmFwcGVyUHJvcHMgb2JqZWN0IHJlZmVyZW5jZSwgbWVtb2l6ZSB0aGlzIGRlc3RydWN0dXJpbmcuXG4gICAgICAgIHZhciByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmID0gcHJvcHMucmVhY3RSZWR1eEZvcndhcmRlZFJlZixcbiAgICAgICAgICAgIHdyYXBwZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXCJdKTtcblxuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc107XG4gICAgICB9LCBbcHJvcHNdKSxcbiAgICAgICAgICBwcm9wc0NvbnRleHQgPSBfdXNlTWVtb1swXSxcbiAgICAgICAgICByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmID0gX3VzZU1lbW9bMV0sXG4gICAgICAgICAgd3JhcHBlclByb3BzID0gX3VzZU1lbW9bMl07XG5cbiAgICAgIHZhciBDb250ZXh0VG9Vc2UgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXNlcnMgbWF5IG9wdGlvbmFsbHkgcGFzcyBpbiBhIGN1c3RvbSBjb250ZXh0IGluc3RhbmNlIHRvIHVzZSBpbnN0ZWFkIG9mIG91ciBSZWFjdFJlZHV4Q29udGV4dC5cbiAgICAgICAgLy8gTWVtb2l6ZSB0aGUgY2hlY2sgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIGNvbnRleHQgaW5zdGFuY2Ugd2Ugc2hvdWxkIHVzZS5cbiAgICAgICAgcmV0dXJuIHByb3BzQ29udGV4dCAmJiBwcm9wc0NvbnRleHQuQ29uc3VtZXIgJiYgaXNDb250ZXh0Q29uc3VtZXIoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbCkpID8gcHJvcHNDb250ZXh0IDogQ29udGV4dDtcbiAgICAgIH0sIFtwcm9wc0NvbnRleHQsIENvbnRleHRdKTsgLy8gUmV0cmlldmUgdGhlIHN0b3JlIGFuZCBhbmNlc3RvciBzdWJzY3JpcHRpb24gdmlhIGNvbnRleHQsIGlmIGF2YWlsYWJsZVxuXG4gICAgICB2YXIgY29udGV4dFZhbHVlID0gdXNlQ29udGV4dChDb250ZXh0VG9Vc2UpOyAvLyBUaGUgc3RvcmUgX211c3RfIGV4aXN0IGFzIGVpdGhlciBhIHByb3Agb3IgaW4gY29udGV4dC5cbiAgICAgIC8vIFdlJ2xsIGNoZWNrIHRvIHNlZSBpZiBpdCBfbG9va3NfIGxpa2UgYSBSZWR1eCBzdG9yZSBmaXJzdC5cbiAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHBhc3MgdGhyb3VnaCBhIGBzdG9yZWAgcHJvcCB0aGF0IGlzIGp1c3QgYSBwbGFpbiB2YWx1ZS5cblxuICAgICAgdmFyIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9IEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZ2V0U3RhdGUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgdmFyIGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID0gQm9vbGVhbihjb250ZXh0VmFsdWUpICYmIEJvb2xlYW4oY29udGV4dFZhbHVlLnN0b3JlKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWRpZFN0b3JlQ29tZUZyb21Qcm9wcyAmJiAhZGlkU3RvcmVDb21lRnJvbUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgXFxcInN0b3JlXFxcIiBpbiB0aGUgY29udGV4dCBvZiBcIiArIChcIlxcXCJcIiArIGRpc3BsYXlOYW1lICsgXCJcXFwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBcIikgKyBcIm9yIHBhc3MgYSBjdXN0b20gUmVhY3QgY29udGV4dCBwcm92aWRlciB0byA8UHJvdmlkZXI+IGFuZCB0aGUgY29ycmVzcG9uZGluZyBcIiArIChcIlJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gXCIgKyBkaXNwbGF5TmFtZSArIFwiIGluIGNvbm5lY3Qgb3B0aW9ucy5cIikpO1xuICAgICAgfSAvLyBCYXNlZCBvbiB0aGUgcHJldmlvdXMgY2hlY2ssIG9uZSBvZiB0aGVzZSBtdXN0IGJlIHRydWVcblxuXG4gICAgICB2YXIgc3RvcmUgPSBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyBwcm9wcy5zdG9yZSA6IGNvbnRleHRWYWx1ZS5zdG9yZTtcbiAgICAgIHZhciBjaGlsZFByb3BzU2VsZWN0b3IgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhlIGNoaWxkIHByb3BzIHNlbGVjdG9yIG5lZWRzIHRoZSBzdG9yZSByZWZlcmVuY2UgYXMgYW4gaW5wdXQuXG4gICAgICAgIC8vIFJlLWNyZWF0ZSB0aGlzIHNlbGVjdG9yIHdoZW5ldmVyIHRoZSBzdG9yZSBjaGFuZ2VzLlxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGRTZWxlY3RvcihzdG9yZSk7XG4gICAgICB9LCBbc3RvcmVdKTtcblxuICAgICAgdmFyIF91c2VNZW1vMiA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWTsgLy8gVGhpcyBTdWJzY3JpcHRpb24ncyBzb3VyY2Ugc2hvdWxkIG1hdGNoIHdoZXJlIHN0b3JlIGNhbWUgZnJvbTogcHJvcHMgdnMuIGNvbnRleHQuIEEgY29tcG9uZW50XG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byB0aGUgc3RvcmUgdmlhIHByb3BzIHNob3VsZG4ndCB1c2Ugc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dCwgb3IgdmljZSB2ZXJzYS5cblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbihzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzID8gbnVsbCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb24pOyAvLyBgbm90aWZ5TmVzdGVkU3Vic2AgaXMgZHVwbGljYXRlZCB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AsIHdoZXJlIGBzdWJzY3JpcHRpb25gIHdpbGwgdGhlbiBiZSBudWxsLiBUaGlzIGNhblxuICAgICAgICAvLyBwcm9iYWJseSBiZSBhdm9pZGVkIGlmIFN1YnNjcmlwdGlvbidzIGxpc3RlbmVycyBsb2dpYyBpcyBjaGFuZ2VkIHRvIG5vdCBjYWxsIGxpc3RlbmVyc1xuICAgICAgICAvLyB0aGF0IGhhdmUgYmVlbiB1bnN1YnNjcmliZWQgaW4gdGhlICBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLlxuXG4gICAgICAgIHZhciBub3RpZnlOZXN0ZWRTdWJzID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic107XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSksXG4gICAgICAgICAgc3Vic2NyaXB0aW9uID0gX3VzZU1lbW8yWzBdLFxuICAgICAgICAgIG5vdGlmeU5lc3RlZFN1YnMgPSBfdXNlTWVtbzJbMV07IC8vIERldGVybWluZSB3aGF0IHtzdG9yZSwgc3Vic2NyaXB0aW9ufSB2YWx1ZSBzaG91bGQgYmUgcHV0IGludG8gbmVzdGVkIGNvbnRleHQsIGlmIG5lY2Vzc2FyeSxcbiAgICAgIC8vIGFuZCBtZW1vaXplIHRoYXQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29udGV4dCB1cGRhdGVzLlxuXG5cbiAgICAgIHZhciBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyBkaXJlY3RseSBzdWJzY3JpYmVkIHRvIGEgc3RvcmUgZnJvbSBwcm9wcy5cbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IGRlc2NlbmRhbnRzIHJlYWRpbmcgZnJvbSB0aGlzIHN0b3JlIC0gcGFzcyBkb3duIHdoYXRldmVyXG4gICAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGNvbnRleHQgdmFsdWUgaXMgZnJvbSB0aGUgbmVhcmVzdCBjb25uZWN0ZWQgYW5jZXN0b3IuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIHB1dCB0aGlzIGNvbXBvbmVudCdzIHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBpbnRvIGNvbnRleHQsIHNvIHRoYXRcbiAgICAgICAgLy8gY29ubmVjdGVkIGRlc2NlbmRhbnRzIHdvbid0IHVwZGF0ZSB1bnRpbCBhZnRlciB0aGlzIGNvbXBvbmVudCBpcyBkb25lXG5cblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHRWYWx1ZSwge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTsgLy8gV2UgbmVlZCB0byBmb3JjZSB0aGlzIHdyYXBwZXIgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuZXZlciBhIFJlZHV4IHN0b3JlIHVwZGF0ZVxuICAgICAgLy8gY2F1c2VzIGEgY2hhbmdlIHRvIHRoZSBjYWxjdWxhdGVkIGNoaWxkIGNvbXBvbmVudCBwcm9wcyAob3Igd2UgY2F1Z2h0IGFuIGVycm9yIGluIG1hcFN0YXRlKVxuXG4gICAgICB2YXIgX3VzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyKHN0b3JlU3RhdGVVcGRhdGVzUmVkdWNlciwgRU1QVFlfQVJSQVksIGluaXRTdGF0ZVVwZGF0ZXMpLFxuICAgICAgICAgIF91c2VSZWR1Y2VyJCA9IF91c2VSZWR1Y2VyWzBdLFxuICAgICAgICAgIHByZXZpb3VzU3RhdGVVcGRhdGVSZXN1bHQgPSBfdXNlUmVkdWNlciRbMF0sXG4gICAgICAgICAgZm9yY2VDb21wb25lbnRVcGRhdGVEaXNwYXRjaCA9IF91c2VSZWR1Y2VyWzFdOyAvLyBQcm9wYWdhdGUgYW55IG1hcFN0YXRlL21hcERpc3BhdGNoIGVycm9ycyB1cHdhcmRzXG5cblxuICAgICAgaWYgKHByZXZpb3VzU3RhdGVVcGRhdGVSZXN1bHQgJiYgcHJldmlvdXNTdGF0ZVVwZGF0ZVJlc3VsdC5lcnJvcikge1xuICAgICAgICB0aHJvdyBwcmV2aW91c1N0YXRlVXBkYXRlUmVzdWx0LmVycm9yO1xuICAgICAgfSAvLyBTZXQgdXAgcmVmcyB0byBjb29yZGluYXRlIHZhbHVlcyBiZXR3ZWVuIHRoZSBzdWJzY3JpcHRpb24gZWZmZWN0IGFuZCB0aGUgcmVuZGVyIGxvZ2ljXG5cblxuICAgICAgdmFyIGxhc3RDaGlsZFByb3BzID0gdXNlUmVmKCk7XG4gICAgICB2YXIgbGFzdFdyYXBwZXJQcm9wcyA9IHVzZVJlZih3cmFwcGVyUHJvcHMpO1xuICAgICAgdmFyIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUgPSB1c2VSZWYoKTtcbiAgICAgIHZhciByZW5kZXJJc1NjaGVkdWxlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgICB2YXIgYWN0dWFsQ2hpbGRQcm9wcyA9IHVzZVB1cmVPbmx5TWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRyaWNreSBsb2dpYyBoZXJlOlxuICAgICAgICAvLyAtIFRoaXMgcmVuZGVyIG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkIGJ5IGEgUmVkdXggc3RvcmUgdXBkYXRlIHRoYXQgcHJvZHVjZWQgbmV3IGNoaWxkIHByb3BzXG4gICAgICAgIC8vIC0gSG93ZXZlciwgd2UgbWF5IGhhdmUgZ290dGVuIG5ldyB3cmFwcGVyIHByb3BzIGFmdGVyIHRoYXRcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBuZXcgY2hpbGQgcHJvcHMsIGFuZCB0aGUgc2FtZSB3cmFwcGVyIHByb3BzLCB3ZSBrbm93IHdlIHNob3VsZCB1c2UgdGhlIG5ldyBjaGlsZCBwcm9wcyBhcy1pcy5cbiAgICAgICAgLy8gQnV0LCBpZiB3ZSBoYXZlIG5ldyB3cmFwcGVyIHByb3BzLCB0aG9zZSBtaWdodCBjaGFuZ2UgdGhlIGNoaWxkIHByb3BzLCBzbyB3ZSBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoaW5ncy5cbiAgICAgICAgLy8gU28sIHdlJ2xsIHVzZSB0aGUgY2hpbGQgcHJvcHMgZnJvbSBzdG9yZSB1cGRhdGUgb25seSBpZiB0aGUgd3JhcHBlciBwcm9wcyBhcmUgdGhlIHNhbWUgYXMgbGFzdCB0aW1lLlxuICAgICAgICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ICYmIHdyYXBwZXJQcm9wcyA9PT0gbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudDtcbiAgICAgICAgfSAvLyBUT0RPIFdlJ3JlIHJlYWRpbmcgdGhlIHN0b3JlIGRpcmVjdGx5IGluIHJlbmRlcigpIGhlcmUuIEJhZCBpZGVhP1xuICAgICAgICAvLyBUaGlzIHdpbGwgbGlrZWx5IGNhdXNlIEJhZCBUaGluZ3MgKFRNKSB0byBoYXBwZW4gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZG8gdGhpcyBiZWNhdXNlIG9uIHJlbmRlcnMgX25vdF8gY2F1c2VkIGJ5IHN0b3JlIHVwZGF0ZXMsIHdlIG5lZWQgdGhlIGxhdGVzdCBzdG9yZSBzdGF0ZVxuICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hpbGQgcHJvcHMgc2hvdWxkIGJlLlxuXG5cbiAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpO1xuICAgICAgfSwgW3N0b3JlLCBwcmV2aW91c1N0YXRlVXBkYXRlUmVzdWx0LCB3cmFwcGVyUHJvcHNdKTsgLy8gV2UgbmVlZCB0aGlzIHRvIGV4ZWN1dGUgc3luY2hyb25vdXNseSBldmVyeSB0aW1lIHdlIHJlLXJlbmRlci4gSG93ZXZlciwgUmVhY3Qgd2FybnNcbiAgICAgIC8vIGFib3V0IHVzZUxheW91dEVmZmVjdCBpbiBTU1IsIHNvIHdlIHRyeSB0byBkZXRlY3QgZW52aXJvbm1lbnQgYW5kIGZhbGwgYmFjayB0b1xuICAgICAgLy8ganVzdCB1c2VFZmZlY3QgaW5zdGVhZCB0byBhdm9pZCB0aGUgd2FybmluZywgc2luY2UgbmVpdGhlciB3aWxsIHJ1biBhbnl3YXkuXG5cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhjYXB0dXJlV3JhcHBlclByb3BzLCBbbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIGFjdHVhbENoaWxkUHJvcHMsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnNdKTsgLy8gT3VyIHJlLXN1YnNjcmliZSBsb2dpYyBvbmx5IHJ1bnMgd2hlbiB0aGUgc3RvcmUvc3Vic2NyaXB0aW9uIHNldHVwIGNoYW5nZXNcblxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKHN1YnNjcmliZVVwZGF0ZXMsIFtzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3RvciwgbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBmb3JjZUNvbXBvbmVudFVwZGF0ZURpc3BhdGNoXSwgW3N0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3Rvcl0pOyAvLyBOb3cgdGhhdCBhbGwgdGhhdCdzIGRvbmUsIHdlIGNhbiBmaW5hbGx5IHRyeSB0byBhY3R1YWxseSByZW5kZXIgdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgIC8vIFdlIG1lbW9pemUgdGhlIGVsZW1lbnRzIGZvciB0aGUgcmVuZGVyZWQgY2hpbGQgY29tcG9uZW50IGFzIGFuIG9wdGltaXphdGlvbi5cblxuICAgICAgdmFyIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIGFjdHVhbENoaWxkUHJvcHMsIHtcbiAgICAgICAgICByZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgfSkpO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTsgLy8gSWYgUmVhY3Qgc2VlcyB0aGUgZXhhY3Qgc2FtZSBlbGVtZW50IHJlZmVyZW5jZSBhcyBsYXN0IHRpbWUsIGl0IGJhaWxzIG91dCBvZiByZS1yZW5kZXJpbmdcbiAgICAgIC8vIHRoYXQgY2hpbGQsIHNhbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gUmVhY3QubWVtbygpIG9yIHJldHVybmVkIGZhbHNlIGZyb20gc2hvdWxkQ29tcG9uZW50VXBkYXRlLlxuXG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgaXMgc3Vic2NyaWJlZCB0byBzdG9yZSB1cGRhdGVzLCB3ZSBuZWVkIHRvIHBhc3MgaXRzIG93blxuICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBkb3duIHRvIG91ciBkZXNjZW5kYW50cy4gVGhhdCBtZWFucyByZW5kZXJpbmcgdGhlIHNhbWVcbiAgICAgICAgICAvLyBDb250ZXh0IGluc3RhbmNlLCBhbmQgcHV0dGluZyBhIGRpZmZlcmVudCB2YWx1ZSBpbnRvIHRoZSBjb250ZXh0LlxuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0VG9Vc2UuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlXG4gICAgICAgICAgfSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICB9LCBbQ29udGV4dFRvVXNlLCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQsIG92ZXJyaWRkZW5Db250ZXh0VmFsdWVdKTtcbiAgICAgIHJldHVybiByZW5kZXJlZENoaWxkO1xuICAgIH0gLy8gSWYgd2UncmUgaW4gXCJwdXJlXCIgbW9kZSwgZW5zdXJlIG91ciB3cmFwcGVyIGNvbXBvbmVudCBvbmx5IHJlLXJlbmRlcnMgd2hlbiBpbmNvbWluZyBwcm9wcyBoYXZlIGNoYW5nZWQuXG5cblxuICAgIHZhciBDb25uZWN0ID0gcHVyZSA/IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKSA6IENvbm5lY3RGdW5jdGlvbjtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcblxuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICB2YXIgZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgICByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWZcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgICBmb3J3YXJkZWQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIHJldHVybiBob2lzdFN0YXRpY3MoZm9yd2FyZGVkLCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9pc3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xufSIsImZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgIHZhciBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuXG4gICAgY29uc3RhbnRTZWxlY3Rvci5kZXBlbmRzT25Pd25Qcm9wcyA9IGZhbHNlO1xuICAgIHJldHVybiBjb25zdGFudFNlbGVjdG9yO1xuICB9O1xufSAvLyBkZXBlbmRzT25Pd25Qcm9wcyBpcyB1c2VkIGJ5IGNyZWF0ZU1hcFRvUHJvcHNQcm94eSB0byBkZXRlcm1pbmUgd2hldGhlciB0byBwYXNzIHByb3BzIGFzIGFyZ3Ncbi8vIHRvIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIHdyYXBwZWQuIEl0IGlzIGFsc28gdXNlZCBieSBtYWtlUHVyZVByb3BzU2VsZWN0b3IgdG8gZGV0ZXJtaW5lXG4vLyB3aGV0aGVyIG1hcFRvUHJvcHMgbmVlZHMgdG8gYmUgaW52b2tlZCB3aGVuIHByb3BzIGhhdmUgY2hhbmdlZC5cbi8vXG4vLyBBIGxlbmd0aCBvZiBvbmUgc2lnbmFscyB0aGF0IG1hcFRvUHJvcHMgZG9lcyBub3QgZGVwZW5kIG9uIHByb3BzIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQuXG4vLyBBIGxlbmd0aCBvZiB6ZXJvIGlzIGFzc3VtZWQgdG8gbWVhbiBtYXBUb1Byb3BzIGlzIGdldHRpbmcgYXJncyB2aWEgYXJndW1lbnRzIG9yIC4uLmFyZ3MgYW5kXG4vLyB0aGVyZWZvcmUgbm90IHJlcG9ydGluZyBpdHMgbGVuZ3RoIGFjY3VyYXRlbHkuLlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcykge1xuICByZXR1cm4gbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyAhPT0gbnVsbCAmJiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzICE9PSB1bmRlZmluZWQgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59IC8vIFVzZWQgYnkgd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24gYW5kIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLFxuLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBtYXBUb1Byb3BzIGluIGEgcHJveHkgZnVuY3Rpb24gd2hpY2ggZG9lcyBzZXZlcmFsIHRoaW5nczpcbi8vXG4vLyAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGRlcGVuZHMgb24gcHJvcHMsIHdoaWNoXG4vLyAgICBpcyB1c2VkIGJ5IHNlbGVjdG9yRmFjdG9yeSB0byBkZWNpZGUgaWYgaXQgc2hvdWxkIHJlaW52b2tlIG9uIHByb3BzIGNoYW5nZXMuXG4vL1xuLy8gICogT24gZmlyc3QgY2FsbCwgaGFuZGxlcyBtYXBUb1Byb3BzIGlmIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbiwgYW5kIHRyZWF0cyB0aGF0XG4vLyAgICBuZXcgZnVuY3Rpb24gYXMgdGhlIHRydWUgbWFwVG9Qcm9wcyBmb3Igc3Vic2VxdWVudCBjYWxscy5cbi8vXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCB2ZXJpZmllcyB0aGUgZmlyc3QgcmVzdWx0IGlzIGEgcGxhaW4gb2JqZWN0LCBpbiBvcmRlciB0byB3YXJuXG4vLyAgICB0aGUgZGV2ZWxvcGVyIHRoYXQgdGhlaXIgbWFwVG9Qcm9wcyBmdW5jdGlvbiBpcyBub3QgcmV0dXJuaW5nIGEgdmFsaWQgcmVzdWx0LlxuLy9cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBUb1Byb3BzLCBtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0UHJveHlTZWxlY3RvcihkaXNwYXRjaCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWU7XG5cbiAgICB2YXIgcHJveHkgPSBmdW5jdGlvbiBtYXBUb1Byb3BzUHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcmV0dXJuIHByb3h5LmRlcGVuZHNPbk93blByb3BzID8gcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSA6IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoKTtcbiAgICB9OyAvLyBhbGxvdyBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IHRvIGdldCBvd25Qcm9wc1xuXG5cbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG5cbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICB2YXIgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufSIsImltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaFxuICAgIH07XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc09iamVjdChtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnb2JqZWN0JyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcsIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc09iamVjdF07IiwiaW1wb3J0IHsgd3JhcE1hcFRvUHJvcHNDb25zdGFudCwgd3JhcE1hcFRvUHJvcHNGdW5jIH0gZnJvbSAnLi93cmFwTWFwVG9Qcm9wcyc7XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24obWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmcobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiwgd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZ107IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb3duUHJvcHMsIHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCBfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgICAgcHVyZSA9IF9yZWYucHVyZSxcbiAgICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IF9yZWYuYXJlTWVyZ2VkUHJvcHNFcXVhbDtcbiAgICB2YXIgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIHZhciBtZXJnZWRQcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICB2YXIgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghcHVyZSB8fCAhYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSkgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsICdtZXJnZVByb3BzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNGdW5jdGlvbihtZXJnZVByb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWVyZ2VQcm9wc0lzT21pdHRlZChtZXJnZVByb3BzKSB7XG4gIHJldHVybiAhbWVyZ2VQcm9wcyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1lcmdlUHJvcHM7XG4gIH0gOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZGVmYXVsdCBbd2hlbk1lcmdlUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWVyZ2VQcm9wc0lzT21pdHRlZF07IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgdmVyaWZ5U3Vic2VsZWN0b3JzIGZyb20gJy4vdmVyaWZ5U3Vic2VsZWN0b3JzJztcbmV4cG9ydCBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpLCBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKSwgb3duUHJvcHMpO1xuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwgX3JlZikge1xuICB2YXIgYXJlU3RhdGVzRXF1YWwgPSBfcmVmLmFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCA9IF9yZWYuYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCA9IF9yZWYuYXJlU3RhdGVQcm9wc0VxdWFsO1xuICB2YXIgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgdmFyIHN0YXRlO1xuICB2YXIgb3duUHJvcHM7XG4gIHZhciBzdGF0ZVByb3BzO1xuICB2YXIgZGlzcGF0Y2hQcm9wcztcbiAgdmFyIG1lcmdlZFByb3BzO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG4gICAgaWYgKHN0YXRlUHJvcHNDaGFuZ2VkKSBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHZhciBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVDaGFuZ2VkID0gIWFyZVN0YXRlc0VxdWFsKG5leHRTdGF0ZSwgc3RhdGUpO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpO1xuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59IC8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG4vLyBJZiBwdXJlIGlzIHRydWUsIHRoZSBzZWxlY3RvciByZXR1cm5lZCBieSBzZWxlY3RvckZhY3Rvcnkgd2lsbCBtZW1vaXplIGl0cyByZXN1bHRzLFxuLy8gYWxsb3dpbmcgY29ubmVjdEFkdmFuY2VkJ3Mgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHRvIHJldHVybiBmYWxzZSBpZiBmaW5hbFxuLy8gcHJvcHMgaGF2ZSBub3QgY2hhbmdlZC4gSWYgZmFsc2UsIHRoZSBzZWxlY3RvciB3aWxsIGFsd2F5cyByZXR1cm4gYSBuZXdcbi8vIG9iamVjdCBhbmQgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHdpbGwgYWx3YXlzIHJldHVybiB0cnVlLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KGRpc3BhdGNoLCBfcmVmMikge1xuICB2YXIgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IF9yZWYyLmluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gX3JlZjIuaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzID0gX3JlZjIuaW5pdE1lcmdlUHJvcHMsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjIsIFtcImluaXRNYXBTdGF0ZVRvUHJvcHNcIiwgXCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzXCIsIFwiaW5pdE1lcmdlUHJvcHNcIl0pO1xuXG4gIHZhciBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgdmFyIG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgb3B0aW9ucy5kaXNwbGF5TmFtZSk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGYWN0b3J5ID0gb3B0aW9ucy5wdXJlID8gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkgOiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5O1xuICByZXR1cm4gc2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwgb3B0aW9ucyk7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBjb25uZWN0QWR2YW5jZWQgZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQnO1xuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICcuLi91dGlscy9zaGFsbG93RXF1YWwnO1xuaW1wb3J0IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tYXBEaXNwYXRjaFRvUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tYXBTdGF0ZVRvUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRNZXJnZVByb3BzRmFjdG9yaWVzIGZyb20gJy4vbWVyZ2VQcm9wcyc7XG5pbXBvcnQgZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSBmcm9tICcuL3NlbGVjdG9yRmFjdG9yeSc7XG4vKlxuICBjb25uZWN0IGlzIGEgZmFjYWRlIG92ZXIgY29ubmVjdEFkdmFuY2VkLiBJdCB0dXJucyBpdHMgYXJncyBpbnRvIGEgY29tcGF0aWJsZVxuICBzZWxlY3RvckZhY3RvcnksIHdoaWNoIGhhcyB0aGUgc2lnbmF0dXJlOlxuXG4gICAgKGRpc3BhdGNoLCBvcHRpb25zKSA9PiAobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpID0+IG5leHRGaW5hbFByb3BzXG4gIFxuICBjb25uZWN0IHBhc3NlcyBpdHMgYXJncyB0byBjb25uZWN0QWR2YW5jZWQgYXMgb3B0aW9ucywgd2hpY2ggd2lsbCBpbiB0dXJuIHBhc3MgdGhlbSB0b1xuICBzZWxlY3RvckZhY3RvcnkgZWFjaCB0aW1lIGEgQ29ubmVjdCBjb21wb25lbnQgaW5zdGFuY2UgaXMgaW5zdGFudGlhdGVkIG9yIGhvdCByZWxvYWRlZC5cblxuICBzZWxlY3RvckZhY3RvcnkgcmV0dXJucyBhIGZpbmFsIHByb3BzIHNlbGVjdG9yIGZyb20gaXRzIG1hcFN0YXRlVG9Qcm9wcyxcbiAgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcywgbWVyZ2VQcm9wcyxcbiAgbWVyZ2VQcm9wc0ZhY3RvcmllcywgYW5kIHB1cmUgYXJncy5cblxuICBUaGUgcmVzdWx0aW5nIGZpbmFsIHByb3BzIHNlbGVjdG9yIGlzIGNhbGxlZCBieSB0aGUgQ29ubmVjdCBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbmV2ZXJcbiAgaXQgcmVjZWl2ZXMgbmV3IHByb3BzIG9yIHN0b3JlIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGFyZywgZmFjdG9yaWVzLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSBmYWN0b3JpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFjdG9yaWVzW2ldKGFyZyk7XG4gICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIG9mIHR5cGUgXCIgKyB0eXBlb2YgYXJnICsgXCIgZm9yIFwiICsgbmFtZSArIFwiIGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgXCIgKyBvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lICsgXCIuXCIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufSAvLyBjcmVhdGVDb25uZWN0IHdpdGggZGVmYXVsdCBhcmdzIGJ1aWxkcyB0aGUgJ29mZmljaWFsJyBjb25uZWN0IGJlaGF2aW9yLiBDYWxsaW5nIGl0IHdpdGhcbi8vIGRpZmZlcmVudCBvcHRpb25zIG9wZW5zIHVwIHNvbWUgdGVzdGluZyBhbmQgZXh0ZW5zaWJpbGl0eSBzY2VuYXJpb3NcblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29ubmVjdChfdGVtcCkge1xuICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgX3JlZiRjb25uZWN0SE9DID0gX3JlZi5jb25uZWN0SE9DLFxuICAgICAgY29ubmVjdEhPQyA9IF9yZWYkY29ubmVjdEhPQyA9PT0gdm9pZCAwID8gY29ubmVjdEFkdmFuY2VkIDogX3JlZiRjb25uZWN0SE9DLFxuICAgICAgX3JlZiRtYXBTdGF0ZVRvUHJvcHNGID0gX3JlZi5tYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YgPT09IHZvaWQgMCA/IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YsXG4gICAgICBfcmVmJG1hcERpc3BhdGNoVG9Qcm8gPSBfcmVmLm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWFwRGlzcGF0Y2hUb1BybyA9PT0gdm9pZCAwID8gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWFwRGlzcGF0Y2hUb1BybyxcbiAgICAgIF9yZWYkbWVyZ2VQcm9wc0ZhY3RvciA9IF9yZWYubWVyZ2VQcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1lcmdlUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1lcmdlUHJvcHNGYWN0b3IgPT09IHZvaWQgMCA/IGRlZmF1bHRNZXJnZVByb3BzRmFjdG9yaWVzIDogX3JlZiRtZXJnZVByb3BzRmFjdG9yLFxuICAgICAgX3JlZiRzZWxlY3RvckZhY3RvcnkgPSBfcmVmLnNlbGVjdG9yRmFjdG9yeSxcbiAgICAgIHNlbGVjdG9yRmFjdG9yeSA9IF9yZWYkc2VsZWN0b3JGYWN0b3J5ID09PSB2b2lkIDAgPyBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IDogX3JlZiRzZWxlY3RvckZhY3Rvcnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIF9yZWYyKSB7XG4gICAgaWYgKF9yZWYyID09PSB2b2lkIDApIHtcbiAgICAgIF9yZWYyID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9yZWYzID0gX3JlZjIsXG4gICAgICAgIF9yZWYzJHB1cmUgPSBfcmVmMy5wdXJlLFxuICAgICAgICBwdXJlID0gX3JlZjMkcHVyZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYzJHB1cmUsXG4gICAgICAgIF9yZWYzJGFyZVN0YXRlc0VxdWFsID0gX3JlZjMuYXJlU3RhdGVzRXF1YWwsXG4gICAgICAgIGFyZVN0YXRlc0VxdWFsID0gX3JlZjMkYXJlU3RhdGVzRXF1YWwgPT09IHZvaWQgMCA/IHN0cmljdEVxdWFsIDogX3JlZjMkYXJlU3RhdGVzRXF1YWwsXG4gICAgICAgIF9yZWYzJGFyZU93blByb3BzRXF1YSA9IF9yZWYzLmFyZU93blByb3BzRXF1YWwsXG4gICAgICAgIGFyZU93blByb3BzRXF1YWwgPSBfcmVmMyRhcmVPd25Qcm9wc0VxdWEgPT09IHZvaWQgMCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYzJGFyZU93blByb3BzRXF1YSxcbiAgICAgICAgX3JlZjMkYXJlU3RhdGVQcm9wc0VxID0gX3JlZjMuYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBfcmVmMyRhcmVTdGF0ZVByb3BzRXEgPT09IHZvaWQgMCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYzJGFyZVN0YXRlUHJvcHNFcSxcbiAgICAgICAgX3JlZjMkYXJlTWVyZ2VkUHJvcHNFID0gX3JlZjMuYXJlTWVyZ2VkUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IF9yZWYzJGFyZU1lcmdlZFByb3BzRSA9PT0gdm9pZCAwID8gc2hhbGxvd0VxdWFsIDogX3JlZjMkYXJlTWVyZ2VkUHJvcHNFLFxuICAgICAgICBleHRyYU9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMywgW1wicHVyZVwiLCBcImFyZVN0YXRlc0VxdWFsXCIsIFwiYXJlT3duUHJvcHNFcXVhbFwiLCBcImFyZVN0YXRlUHJvcHNFcXVhbFwiLCBcImFyZU1lcmdlZFByb3BzRXF1YWxcIl0pO1xuXG4gICAgdmFyIGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXRjaChtYXBTdGF0ZVRvUHJvcHMsIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcywgJ21hcFN0YXRlVG9Qcm9wcycpO1xuICAgIHZhciBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWF0Y2gobWFwRGlzcGF0Y2hUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKTtcbiAgICB2YXIgaW5pdE1lcmdlUHJvcHMgPSBtYXRjaChtZXJnZVByb3BzLCBtZXJnZVByb3BzRmFjdG9yaWVzLCAnbWVyZ2VQcm9wcycpO1xuICAgIHJldHVybiBjb25uZWN0SE9DKHNlbGVjdG9yRmFjdG9yeSwgX2V4dGVuZHMoe1xuICAgICAgLy8gdXNlZCBpbiBlcnJvciBtZXNzYWdlc1xuICAgICAgbWV0aG9kTmFtZTogJ2Nvbm5lY3QnLFxuICAgICAgLy8gdXNlZCB0byBjb21wdXRlIENvbm5lY3QncyBkaXNwbGF5TmFtZSBmcm9tIHRoZSB3cmFwcGVkIGNvbXBvbmVudCdzIGRpc3BsYXlOYW1lLlxuICAgICAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFwiQ29ubmVjdChcIiArIG5hbWUgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgICAvLyBpZiBtYXBTdGF0ZVRvUHJvcHMgaXMgZmFsc3ksIHRoZSBDb25uZWN0IGNvbXBvbmVudCBkb2Vzbid0IHN1YnNjcmliZSB0byBzdG9yZSBzdGF0ZSBjaGFuZ2VzXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKSxcbiAgICAgIC8vIHBhc3NlZCB0aHJvdWdoIHRvIHNlbGVjdG9yRmFjdG9yeVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wczogaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHM6IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wczogaW5pdE1lcmdlUHJvcHMsXG4gICAgICBwdXJlOiBwdXJlLFxuICAgICAgYXJlU3RhdGVzRXF1YWw6IGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbDogYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbDogYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbDogYXJlTWVyZ2VkUHJvcHNFcXVhbFxuICAgIH0sIGV4dHJhT3B0aW9ucykpO1xuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgLyojX19QVVJFX18qL2NyZWF0ZUNvbm5lY3QoKTsiLCJpbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnO1xuLyoqXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSB2YWx1ZSBvZiB0aGUgYFJlYWN0UmVkdXhDb250ZXh0YC4gVGhpcyBpcyBhIGxvdy1sZXZlbFxuICogaG9vayB0aGF0IHlvdSBzaG91bGQgdXN1YWxseSBub3QgbmVlZCB0byBjYWxsIGRpcmVjdGx5LlxuICpcbiAqIEByZXR1cm5zIHthbnl9IHRoZSB2YWx1ZSBvZiB0aGUgYFJlYWN0UmVkdXhDb250ZXh0YFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuICogaW1wb3J0IHsgdXNlUmVkdXhDb250ZXh0IH0gZnJvbSAncmVhY3QtcmVkdXgnXG4gKlxuICogZXhwb3J0IGNvbnN0IENvdW50ZXJDb21wb25lbnQgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gKiAgIGNvbnN0IHsgc3RvcmUgfSA9IHVzZVJlZHV4Q29udGV4dCgpXG4gKiAgIHJldHVybiA8ZGl2PntzdG9yZS5nZXRTdGF0ZSgpfTwvZGl2PlxuICogfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0VmFsdWUgPSB1c2VDb250ZXh0KFJlYWN0UmVkdXhDb250ZXh0KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZmluZCByZWFjdC1yZWR1eCBjb250ZXh0IHZhbHVlOyBwbGVhc2UgZW5zdXJlIHRoZSBjb21wb25lbnQgaXMgd3JhcHBlZCBpbiBhIDxQcm92aWRlcj4nKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0VmFsdWU7XG59IiwiaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0JztcbmltcG9ydCB7IHVzZVJlZHV4Q29udGV4dCBhcyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi91c2VSZWR1eENvbnRleHQnO1xuLyoqXG4gKiBIb29rIGZhY3RvcnksIHdoaWNoIGNyZWF0ZXMgYSBgdXNlU3RvcmVgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGB1c2VTdG9yZWAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQ7XG4gIH1cblxuICB2YXIgdXNlUmVkdXhDb250ZXh0ID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1c2VDb250ZXh0KGNvbnRleHQpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gICAgdmFyIF91c2VSZWR1eENvbnRleHQgPSB1c2VSZWR1eENvbnRleHQoKSxcbiAgICAgICAgc3RvcmUgPSBfdXNlUmVkdXhDb250ZXh0LnN0b3JlO1xuXG4gICAgcmV0dXJuIHN0b3JlO1xuICB9O1xufVxuLyoqXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7YW55fSB0aGUgcmVkdXggc3RvcmVcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbiAqIGltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAncmVhY3QtcmVkdXgnXG4gKlxuICogZXhwb3J0IGNvbnN0IEV4YW1wbGVDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKVxuICogICByZXR1cm4gPGRpdj57c3RvcmUuZ2V0U3RhdGUoKX08L2Rpdj5cbiAqIH1cbiAqL1xuXG5leHBvcnQgdmFyIHVzZVN0b3JlID0gLyojX19QVVJFX18qL2NyZWF0ZVN0b3JlSG9vaygpOyIsImltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0JztcbmltcG9ydCB7IHVzZVN0b3JlIGFzIHVzZURlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmVIb29rIH0gZnJvbSAnLi91c2VTdG9yZSc7XG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VEaXNwYXRjaGAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZURpc3BhdGNoYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dDtcbiAgfVxuXG4gIHZhciB1c2VTdG9yZSA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlRGVmYXVsdFN0b3JlIDogY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gdXNlRGlzcGF0Y2goKSB7XG4gICAgdmFyIHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2g7XG4gIH07XG59XG4vKipcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHJlZHV4IGBkaXNwYXRjaGAgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMge2FueXxmdW5jdGlvbn0gcmVkdXggc3RvcmUncyBgZGlzcGF0Y2hgIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcbiAqIGltcG9ydCB7IHVzZURpc3BhdGNoIH0gZnJvbSAncmVhY3QtcmVkdXgnXG4gKlxuICogZXhwb3J0IGNvbnN0IENvdW50ZXJDb21wb25lbnQgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gKiAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKVxuICogICBjb25zdCBpbmNyZWFzZUNvdW50ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdpbmNyZWFzZS1jb3VudGVyJyB9KSwgW10pXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxzcGFuPnt2YWx1ZX08L3NwYW4+XG4gKiAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2luY3JlYXNlQ291bnRlcn0+SW5jcmVhc2UgY291bnRlcjwvYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICApXG4gKiB9XG4gKi9cblxuZXhwb3J0IHZhciB1c2VEaXNwYXRjaCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEaXNwYXRjaEhvb2soKTsiLCJpbXBvcnQgeyB1c2VSZWR1Y2VyLCB1c2VSZWYsIHVzZU1lbW8sIHVzZUNvbnRleHQsIHVzZURlYnVnVmFsdWUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZWR1eENvbnRleHQgYXMgdXNlRGVmYXVsdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vdXNlUmVkdXhDb250ZXh0JztcbmltcG9ydCBTdWJzY3JpcHRpb24gZnJvbSAnLi4vdXRpbHMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0JztcblxudmFyIHJlZkVxdWFsaXR5ID0gZnVuY3Rpb24gcmVmRXF1YWxpdHkoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn07XG5cbmZ1bmN0aW9uIHVzZVNlbGVjdG9yV2l0aFN0b3JlQW5kU3Vic2NyaXB0aW9uKHNlbGVjdG9yLCBlcXVhbGl0eUZuLCBzdG9yZSwgY29udGV4dFN1Yikge1xuICB2YXIgX3VzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMgKyAxO1xuICB9LCAwKSxcbiAgICAgIGZvcmNlUmVuZGVyID0gX3VzZVJlZHVjZXJbMV07XG5cbiAgdmFyIHN1YnNjcmlwdGlvbiA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKHN0b3JlLCBjb250ZXh0U3ViKTtcbiAgfSwgW3N0b3JlLCBjb250ZXh0U3ViXSk7XG4gIHZhciBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gdXNlUmVmKCk7XG4gIHZhciBsYXRlc3RTZWxlY3RvciA9IHVzZVJlZigpO1xuICB2YXIgbGF0ZXN0U3RvcmVTdGF0ZSA9IHVzZVJlZigpO1xuICB2YXIgbGF0ZXN0U2VsZWN0ZWRTdGF0ZSA9IHVzZVJlZigpO1xuICB2YXIgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIHZhciBzZWxlY3RlZFN0YXRlO1xuXG4gIHRyeSB7XG4gICAgaWYgKHNlbGVjdG9yICE9PSBsYXRlc3RTZWxlY3Rvci5jdXJyZW50IHx8IHN0b3JlU3RhdGUgIT09IGxhdGVzdFN0b3JlU3RhdGUuY3VycmVudCB8fCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBzZWxlY3RvcihzdG9yZVN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRTdGF0ZSA9IGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgIGVyci5tZXNzYWdlICs9IFwiXFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcXG5cIiArIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFjayArIFwiXFxuXFxuXCI7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgbGF0ZXN0U2VsZWN0b3IuY3VycmVudCA9IHNlbGVjdG9yO1xuICAgIGxhdGVzdFN0b3JlU3RhdGUuY3VycmVudCA9IHN0b3JlU3RhdGU7XG4gICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gc2VsZWN0ZWRTdGF0ZTtcbiAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjaGVja0ZvclVwZGF0ZXMoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV3U2VsZWN0ZWRTdGF0ZSA9IGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQoc3RvcmUuZ2V0U3RhdGUoKSk7XG5cbiAgICAgICAgaWYgKGVxdWFsaXR5Rm4obmV3U2VsZWN0ZWRTdGF0ZSwgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCA9IG5ld1NlbGVjdGVkU3RhdGU7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gd2UgaWdub3JlIGFsbCBlcnJvcnMgaGVyZSwgc2luY2Ugd2hlbiB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIGlzIHJlLXJlbmRlcmVkLCB0aGUgc2VsZWN0b3JzIGFyZSBjYWxsZWQgYWdhaW4sIGFuZFxuICAgICAgICAvLyB3aWxsIHRocm93IGFnYWluLCBpZiBuZWl0aGVyIHByb3BzIG5vciBzdG9yZSBzdGF0ZVxuICAgICAgICAvLyBjaGFuZ2VkXG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IGVycjtcbiAgICAgIH1cblxuICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICB9XG5cbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IGNoZWNrRm9yVXBkYXRlcztcbiAgICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgY2hlY2tGb3JVcGRhdGVzKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbc3RvcmUsIHN1YnNjcmlwdGlvbl0pO1xuICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbn1cbi8qKlxuICogSG9vayBmYWN0b3J5LCB3aGljaCBjcmVhdGVzIGEgYHVzZVNlbGVjdG9yYCBob29rIGJvdW5kIHRvIGEgZ2l2ZW4gY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0LkNvbnRleHR9IFtjb250ZXh0PVJlYWN0UmVkdXhDb250ZXh0XSBDb250ZXh0IHBhc3NlZCB0byB5b3VyIGA8UHJvdmlkZXI+YC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBgdXNlU2VsZWN0b3JgIGhvb2sgYm91bmQgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQ7XG4gIH1cblxuICB2YXIgdXNlUmVkdXhDb250ZXh0ID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1c2VDb250ZXh0KGNvbnRleHQpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gdXNlU2VsZWN0b3Ioc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICBpZiAoZXF1YWxpdHlGbiA9PT0gdm9pZCAwKSB7XG4gICAgICBlcXVhbGl0eUZuID0gcmVmRXF1YWxpdHk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXNlbGVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JcIik7XG4gICAgfVxuXG4gICAgdmFyIF91c2VSZWR1eENvbnRleHQgPSB1c2VSZWR1eENvbnRleHQoKSxcbiAgICAgICAgc3RvcmUgPSBfdXNlUmVkdXhDb250ZXh0LnN0b3JlLFxuICAgICAgICBjb250ZXh0U3ViID0gX3VzZVJlZHV4Q29udGV4dC5zdWJzY3JpcHRpb247XG5cbiAgICB2YXIgc2VsZWN0ZWRTdGF0ZSA9IHVzZVNlbGVjdG9yV2l0aFN0b3JlQW5kU3Vic2NyaXB0aW9uKHNlbGVjdG9yLCBlcXVhbGl0eUZuLCBzdG9yZSwgY29udGV4dFN1Yik7XG4gICAgdXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbn1cbi8qKlxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgcmVkdXggc3RvcmUncyBzdGF0ZS4gVGhpcyBob29rIHRha2VzIGEgc2VsZWN0b3IgZnVuY3Rpb25cbiAqIGFzIGFuIGFyZ3VtZW50LiBUaGUgc2VsZWN0b3IgaXMgY2FsbGVkIHdpdGggdGhlIHN0b3JlIHN0YXRlLlxuICpcbiAqIFRoaXMgaG9vayB0YWtlcyBhbiBvcHRpb25hbCBlcXVhbGl0eSBjb21wYXJpc29uIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gKiB0aGF0IGFsbG93cyB5b3UgdG8gY3VzdG9taXplIHRoZSB3YXkgdGhlIHNlbGVjdGVkIHN0YXRlIGlzIGNvbXBhcmVkIHRvIGRldGVybWluZVxuICogd2hldGhlciB0aGUgY29tcG9uZW50IG5lZWRzIHRvIGJlIHJlLXJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbGVjdG9yIHRoZSBzZWxlY3RvciBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbj19IGVxdWFsaXR5Rm4gdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eVxuICpcbiAqIEByZXR1cm5zIHthbnl9IHRoZSBzZWxlY3RlZCBzdGF0ZVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuICogaW1wb3J0IHsgdXNlU2VsZWN0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCdcbiAqXG4gKiBleHBvcnQgY29uc3QgQ291bnRlckNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgY291bnRlciA9IHVzZVNlbGVjdG9yKHN0YXRlID0+IHN0YXRlLmNvdW50ZXIpXG4gKiAgIHJldHVybiA8ZGl2Pntjb3VudGVyfTwvZGl2PlxuICogfVxuICovXG5cbmV4cG9ydCB2YXIgdXNlU2VsZWN0b3IgPSAvKiNfX1BVUkVfXyovY3JlYXRlU2VsZWN0b3JIb29rKCk7IiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLXVucmVzb2x2ZWQgKi9cbmV4cG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSAncmVhY3QtZG9tJzsiLCJpbXBvcnQgUHJvdmlkZXIgZnJvbSAnLi9jb21wb25lbnRzL1Byb3ZpZGVyJztcbmltcG9ydCBjb25uZWN0QWR2YW5jZWQgZnJvbSAnLi9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9Db250ZXh0JztcbmltcG9ydCBjb25uZWN0IGZyb20gJy4vY29ubmVjdC9jb25uZWN0JztcbmltcG9ydCB7IHVzZURpc3BhdGNoLCBjcmVhdGVEaXNwYXRjaEhvb2sgfSBmcm9tICcuL2hvb2tzL3VzZURpc3BhdGNoJztcbmltcG9ydCB7IHVzZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3Rvckhvb2sgfSBmcm9tICcuL2hvb2tzL3VzZVNlbGVjdG9yJztcbmltcG9ydCB7IHVzZVN0b3JlLCBjcmVhdGVTdG9yZUhvb2sgfSBmcm9tICcuL2hvb2tzL3VzZVN0b3JlJztcbmltcG9ydCB7IHNldEJhdGNoIH0gZnJvbSAnLi91dGlscy9iYXRjaCc7XG5pbXBvcnQgeyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhcyBiYXRjaCB9IGZyb20gJy4vdXRpbHMvcmVhY3RCYXRjaGVkVXBkYXRlcyc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJy4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbnNldEJhdGNoKGJhdGNoKTtcbmV4cG9ydCB7IFByb3ZpZGVyLCBjb25uZWN0QWR2YW5jZWQsIFJlYWN0UmVkdXhDb250ZXh0LCBjb25uZWN0LCBiYXRjaCwgdXNlRGlzcGF0Y2gsIGNyZWF0ZURpc3BhdGNoSG9vaywgdXNlU2VsZWN0b3IsIGNyZWF0ZVNlbGVjdG9ySG9vaywgdXNlU3RvcmUsIGNyZWF0ZVN0b3JlSG9vaywgc2hhbGxvd0VxdWFsIH07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///703\n")},359:(__unused_webpack_module,exports)=>{"use strict";eval('var __webpack_unused_export__;\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?\nSymbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;\nfunction z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}__webpack_unused_export__=l;__webpack_unused_export__=m;__webpack_unused_export__=k;__webpack_unused_export__=h;__webpack_unused_export__=c;__webpack_unused_export__=n;__webpack_unused_export__=e;__webpack_unused_export__=t;__webpack_unused_export__=r;__webpack_unused_export__=d;\n__webpack_unused_export__=g;__webpack_unused_export__=f;__webpack_unused_export__=p;__webpack_unused_export__=function(a){return A(a)||z(a)===l};__webpack_unused_export__=A;exports.isContextConsumer=function(a){return z(a)===k};__webpack_unused_export__=function(a){return z(a)===h};__webpack_unused_export__=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};__webpack_unused_export__=function(a){return z(a)===n};__webpack_unused_export__=function(a){return z(a)===e};__webpack_unused_export__=function(a){return z(a)===t};\n__webpack_unused_export__=function(a){return z(a)===r};__webpack_unused_export__=function(a){return z(a)===d};__webpack_unused_export__=function(a){return z(a)===g};__webpack_unused_export__=function(a){return z(a)===f};__webpack_unused_export__=function(a){return z(a)===p};\n__webpack_unused_export__=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};__webpack_unused_export__=z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcz8wZDRjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2I7QUFDQSxjQUFjLGtDQUFrQyxpQkFBaUIsVUFBVSwwQkFBMEIsbURBQW1ELGtDQUFrQyw0Q0FBNEMsa0JBQWtCLGtCQUFrQixjQUFjLGdCQUFnQix5QkFBaUIsR0FBRyx5QkFBc0IsR0FBRyx5QkFBdUIsR0FBRyx5QkFBdUIsR0FBRyx5QkFBZSxHQUFHLHlCQUFrQixHQUFHLHlCQUFnQixHQUFHLHlCQUFZLEdBQUcseUJBQVksR0FBRyx5QkFBYztBQUMvZSx5QkFBZ0IsR0FBRyx5QkFBa0IsR0FBRyx5QkFBZ0IsR0FBRyx5QkFBbUIsYUFBYSx1QkFBdUIseUJBQXdCLEdBQUcseUJBQXlCLGFBQWEsaUJBQWlCLHlCQUF5QixhQUFhLGlCQUFpQix5QkFBaUIsYUFBYSxxREFBcUQseUJBQW9CLGFBQWEsaUJBQWlCLHlCQUFrQixhQUFhLGlCQUFpQix5QkFBYyxhQUFhO0FBQzNjLHlCQUFjLGFBQWEsaUJBQWlCLHlCQUFnQixhQUFhLGlCQUFpQix5QkFBa0IsYUFBYSxpQkFBaUIseUJBQW9CLGFBQWEsaUJBQWlCLHlCQUFrQixhQUFhO0FBQzNOLHlCQUEwQixhQUFhLDZRQUE2USx5QkFBYyIsImZpbGUiOiIzNTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBiPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IsYz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLGQ9Yj9TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LGU9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsZj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTo2MDEwOCxnPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpOjYwMTE0LGg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik6NjAxMDksaz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpOjYwMTEwLGw9Yj9TeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKTo2MDExMSxtPWI/U3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKTo2MDExMSxuPWI/U3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpOjYwMTEyLHA9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik6NjAxMTMscT1iP1xuU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik6NjAxMjAscj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpOjYwMTE1LHQ9Yj9TeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTo2MDExNix2PWI/U3ltYm9sLmZvcihcInJlYWN0LmJsb2NrXCIpOjYwMTIxLHc9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZnVuZGFtZW50YWxcIik6NjAxMTcseD1iP1N5bWJvbC5mb3IoXCJyZWFjdC5yZXNwb25kZXJcIik6NjAxMTgseT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKTo2MDExOTtcbmZ1bmN0aW9uIHooYSl7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSl7dmFyIHU9YS4kJHR5cGVvZjtzd2l0Y2godSl7Y2FzZSBjOnN3aXRjaChhPWEudHlwZSxhKXtjYXNlIGw6Y2FzZSBtOmNhc2UgZTpjYXNlIGc6Y2FzZSBmOmNhc2UgcDpyZXR1cm4gYTtkZWZhdWx0OnN3aXRjaChhPWEmJmEuJCR0eXBlb2YsYSl7Y2FzZSBrOmNhc2UgbjpjYXNlIHQ6Y2FzZSByOmNhc2UgaDpyZXR1cm4gYTtkZWZhdWx0OnJldHVybiB1fX1jYXNlIGQ6cmV0dXJuIHV9fX1mdW5jdGlvbiBBKGEpe3JldHVybiB6KGEpPT09bX1leHBvcnRzLkFzeW5jTW9kZT1sO2V4cG9ydHMuQ29uY3VycmVudE1vZGU9bTtleHBvcnRzLkNvbnRleHRDb25zdW1lcj1rO2V4cG9ydHMuQ29udGV4dFByb3ZpZGVyPWg7ZXhwb3J0cy5FbGVtZW50PWM7ZXhwb3J0cy5Gb3J3YXJkUmVmPW47ZXhwb3J0cy5GcmFnbWVudD1lO2V4cG9ydHMuTGF6eT10O2V4cG9ydHMuTWVtbz1yO2V4cG9ydHMuUG9ydGFsPWQ7XG5leHBvcnRzLlByb2ZpbGVyPWc7ZXhwb3J0cy5TdHJpY3RNb2RlPWY7ZXhwb3J0cy5TdXNwZW5zZT1wO2V4cG9ydHMuaXNBc3luY01vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIEEoYSl8fHooYSk9PT1sfTtleHBvcnRzLmlzQ29uY3VycmVudE1vZGU9QTtleHBvcnRzLmlzQ29udGV4dENvbnN1bWVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09a307ZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWh9O2V4cG9ydHMuaXNFbGVtZW50PWZ1bmN0aW9uKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1jfTtleHBvcnRzLmlzRm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PW59O2V4cG9ydHMuaXNGcmFnbWVudD1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWV9O2V4cG9ydHMuaXNMYXp5PWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09dH07XG5leHBvcnRzLmlzTWVtbz1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXJ9O2V4cG9ydHMuaXNQb3J0YWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1kfTtleHBvcnRzLmlzUHJvZmlsZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1nfTtleHBvcnRzLmlzU3RyaWN0TW9kZT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWZ9O2V4cG9ydHMuaXNTdXNwZW5zZT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXB9O1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGU9ZnVuY3Rpb24oYSl7cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBhfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgYXx8YT09PWV8fGE9PT1tfHxhPT09Z3x8YT09PWZ8fGE9PT1wfHxhPT09cXx8XCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmKGEuJCR0eXBlb2Y9PT10fHxhLiQkdHlwZW9mPT09cnx8YS4kJHR5cGVvZj09PWh8fGEuJCR0eXBlb2Y9PT1rfHxhLiQkdHlwZW9mPT09bnx8YS4kJHR5cGVvZj09PXd8fGEuJCR0eXBlb2Y9PT14fHxhLiQkdHlwZW9mPT09eXx8YS4kJHR5cGVvZj09PXYpfTtleHBvcnRzLnR5cGVPZj16O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///359\n')},973:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(359);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzP2QyZmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QyxFQUFFLHlDQUE0RDtBQUM5RCxDQUFDLE1BQU0sRUFFTiIsImZpbGUiOiI5NzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///973\n")},251:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/** @license React v17.0.1\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n__webpack_require__(418);var f=__webpack_require__(294),g=60103;exports.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");exports.Fragment=h("react.fragment")}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzP2QzMWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLG1CQUFPLENBQUMsR0FBZSxFQUFFLE1BQU0sbUJBQU8sQ0FBQyxHQUFPLFVBQVUsZ0JBQWdCLE9BQU8sMkNBQTJDLGlCQUFpQixxQkFBcUIsZ0JBQWdCLHFCQUFxQixrSEFBa0g7QUFDcFUsa0JBQWtCLFVBQVUsZUFBZSxxQkFBcUIsNkJBQTZCLDBCQUEwQiwwREFBMEQsNEVBQTRFLE9BQU8sd0RBQXdELFdBQVcsR0FBRyxZQUFZIiwiZmlsZSI6IjI1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIik7dmFyIGY9cmVxdWlyZShcInJlYWN0XCIpLGc9NjAxMDM7ZXhwb3J0cy5GcmFnbWVudD02MDEwNztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yKXt2YXIgaD1TeW1ib2wuZm9yO2c9aChcInJlYWN0LmVsZW1lbnRcIik7ZXhwb3J0cy5GcmFnbWVudD1oKFwicmVhY3QuZnJhZ21lbnRcIil9dmFyIG09Zi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcixuPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkscD17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gcShjLGEsayl7dmFyIGIsZD17fSxlPW51bGwsbD1udWxsO3ZvaWQgMCE9PWsmJihlPVwiXCIrayk7dm9pZCAwIT09YS5rZXkmJihlPVwiXCIrYS5rZXkpO3ZvaWQgMCE9PWEucmVmJiYobD1hLnJlZik7Zm9yKGIgaW4gYSluLmNhbGwoYSxiKSYmIXAuaGFzT3duUHJvcGVydHkoYikmJihkW2JdPWFbYl0pO2lmKGMmJmMuZGVmYXVsdFByb3BzKWZvcihiIGluIGE9Yy5kZWZhdWx0UHJvcHMsYSl2b2lkIDA9PT1kW2JdJiYoZFtiXT1hW2JdKTtyZXR1cm57JCR0eXBlb2Y6Zyx0eXBlOmMsa2V5OmUscmVmOmwscHJvcHM6ZCxfb3duZXI6bS5jdXJyZW50fX1leHBvcnRzLmpzeD1xO2V4cG9ydHMuanN4cz1xO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///251\n')},893:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(251);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/OWNhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDLEVBQUUseUNBQXFFO0FBQ3ZFLENBQUMsTUFBTSxFQUVOIiwiZmlsZSI6Ijg5My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///893\n")}},0,[[352,382,868,712]]]);