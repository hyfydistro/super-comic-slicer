/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksuper_comic_slicer"] = self["webpackChunksuper_comic_slicer"] || []).push([["reactreactBeautifulDnd"],{

/***/ "ngQI":
/*!**************************************************************************!*\
  !*** ./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DragDropContext\": () => (/* binding */ DragDropContext),\n/* harmony export */   \"Draggable\": () => (/* binding */ PublicDraggable),\n/* harmony export */   \"Droppable\": () => (/* binding */ ConnectedDroppable),\n/* harmony export */   \"resetServerContext\": () => (/* binding */ resetServerContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"q1tI\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"dI71\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"wx14\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! redux */ \"ANjH\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-redux */ \"/MKj\");\n/* harmony import */ var use_memo_one__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! use-memo-one */ \"mHlH\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! css-box-model */ \"jj+N\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! memoize-one */ \"Wwog\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! raf-schd */ \"w95p\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"i8i4\");\n\n\n\n\n\n\n\n\n\n\n\nvar isProduction = \"development\" === 'production';\nvar spacesAndTabs = /[ \\t]{2,}/g;\nvar lineStartWithSpaces = /^[ \\t]*/gm;\n\nvar clean = function clean(value) {\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\n};\n\nvar getDevMessage = function getDevMessage(message) {\n  return clean(\"\\n  %creact-beautiful-dnd\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77\\u200D This is a development only message. It will be removed in production builds.\\n\");\n};\n\nvar getFormattedMessage = function getFormattedMessage(message) {\n  return [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];\n};\nvar isDisabledFlag = '__react-beautiful-dnd-disable-dev-warnings';\nfunction log(type, message) {\n  var _console;\n\n  if (isProduction) {\n    return;\n  }\n\n  if (typeof window !== 'undefined' && window[isDisabledFlag]) {\n    return;\n  }\n\n  (_console = console)[type].apply(_console, getFormattedMessage(message));\n}\nvar warning = log.bind(null, 'warn');\nvar error = log.bind(null, 'error');\n\nfunction noop() {}\n\nfunction getOptions(shared, fromBinding) {\n  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, shared, {}, fromBinding);\n}\n\nfunction bindEvents(el, bindings, sharedOptions) {\n  var unbindings = bindings.map(function (binding) {\n    var options = getOptions(sharedOptions, binding.options);\n    el.addEventListener(binding.eventName, binding.fn, options);\n    return function unbind() {\n      el.removeEventListener(binding.eventName, binding.fn, options);\n    };\n  });\n  return function unbindAll() {\n    unbindings.forEach(function (unbind) {\n      unbind();\n    });\n  };\n}\n\nvar isProduction$1 = \"development\" === 'production';\nvar prefix = 'Invariant failed';\nfunction RbdInvariant(message) {\n  this.message = message;\n}\n\nRbdInvariant.prototype.toString = function toString() {\n  return this.message;\n};\n\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction$1) {\n    throw new RbdInvariant(prefix);\n  } else {\n    throw new RbdInvariant(prefix + \": \" + (message || ''));\n  }\n}\n\nvar ErrorBoundary = function (_React$Component) {\n  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__.default)(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.callbacks = null;\n    _this.unbind = noop;\n\n    _this.onWindowError = function (event) {\n      var callbacks = _this.getCallbacks();\n\n      if (callbacks.isDragging()) {\n        callbacks.tryAbort();\n         true ? warning(\"\\n        An error was caught by our window 'error' event listener while a drag was occurring.\\n        The active drag has been aborted.\\n      \") : 0;\n      }\n\n      var err = event.error;\n\n      if (err instanceof RbdInvariant) {\n        event.preventDefault();\n\n        if (true) {\n          error(err.message);\n        }\n      }\n    };\n\n    _this.getCallbacks = function () {\n      if (!_this.callbacks) {\n        throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');\n      }\n\n      return _this.callbacks;\n    };\n\n    _this.setCallbacks = function (callbacks) {\n      _this.callbacks = callbacks;\n    };\n\n    return _this;\n  }\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.unbind = bindEvents(window, [{\n      eventName: 'error',\n      fn: this.onWindowError\n    }]);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unbind();\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(err) {\n    if (err instanceof RbdInvariant) {\n      if (true) {\n        error(err.message);\n      }\n\n      this.setState({});\n      return;\n    }\n\n    throw err;\n  };\n\n  _proto.render = function render() {\n    return this.props.children(this.setCallbacks);\n  };\n\n  return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nvar dragHandleUsageInstructions = \"\\n  Press space bar to start a drag.\\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\\n  Some screen readers may require you to be in focus mode or to use your pass through key\\n\";\n\nvar position = function position(index) {\n  return index + 1;\n};\n\nvar onDragStart = function onDragStart(start) {\n  return \"\\n  You have lifted an item in position \" + position(start.source.index) + \"\\n\";\n};\n\nvar withLocation = function withLocation(source, destination) {\n  var isInHomeList = source.droppableId === destination.droppableId;\n  var startPosition = position(source.index);\n  var endPosition = position(destination.index);\n\n  if (isInHomeList) {\n    return \"\\n      You have moved the item from position \" + startPosition + \"\\n      to position \" + endPosition + \"\\n    \";\n  }\n\n  return \"\\n    You have moved the item from position \" + startPosition + \"\\n    in list \" + source.droppableId + \"\\n    to list \" + destination.droppableId + \"\\n    in position \" + endPosition + \"\\n  \";\n};\n\nvar withCombine = function withCombine(id, source, combine) {\n  var inHomeList = source.droppableId === combine.droppableId;\n\n  if (inHomeList) {\n    return \"\\n      The item \" + id + \"\\n      has been combined with \" + combine.draggableId;\n  }\n\n  return \"\\n      The item \" + id + \"\\n      in list \" + source.droppableId + \"\\n      has been combined with \" + combine.draggableId + \"\\n      in list \" + combine.droppableId + \"\\n    \";\n};\n\nvar onDragUpdate = function onDragUpdate(update) {\n  var location = update.destination;\n\n  if (location) {\n    return withLocation(update.source, location);\n  }\n\n  var combine = update.combine;\n\n  if (combine) {\n    return withCombine(update.draggableId, update.source, combine);\n  }\n\n  return 'You are over an area that cannot be dropped on';\n};\n\nvar returnedToStart = function returnedToStart(source) {\n  return \"\\n  The item has returned to its starting position\\n  of \" + position(source.index) + \"\\n\";\n};\n\nvar onDragEnd = function onDragEnd(result) {\n  if (result.reason === 'CANCEL') {\n    return \"\\n      Movement cancelled.\\n      \" + returnedToStart(result.source) + \"\\n    \";\n  }\n\n  var location = result.destination;\n  var combine = result.combine;\n\n  if (location) {\n    return \"\\n      You have dropped the item.\\n      \" + withLocation(result.source, location) + \"\\n    \";\n  }\n\n  if (combine) {\n    return \"\\n      You have dropped the item.\\n      \" + withCombine(result.draggableId, result.source, combine) + \"\\n    \";\n  }\n\n  return \"\\n    The item has been dropped while not over a drop area.\\n    \" + returnedToStart(result.source) + \"\\n  \";\n};\n\nvar preset = {\n  dragHandleUsageInstructions: dragHandleUsageInstructions,\n  onDragStart: onDragStart,\n  onDragUpdate: onDragUpdate,\n  onDragEnd: onDragEnd\n};\n\nvar origin = {\n  x: 0,\n  y: 0\n};\nvar add = function add(point1, point2) {\n  return {\n    x: point1.x + point2.x,\n    y: point1.y + point2.y\n  };\n};\nvar subtract = function subtract(point1, point2) {\n  return {\n    x: point1.x - point2.x,\n    y: point1.y - point2.y\n  };\n};\nvar isEqual = function isEqual(point1, point2) {\n  return point1.x === point2.x && point1.y === point2.y;\n};\nvar negate = function negate(point) {\n  return {\n    x: point.x !== 0 ? -point.x : 0,\n    y: point.y !== 0 ? -point.y : 0\n  };\n};\nvar patch = function patch(line, value, otherValue) {\n  var _ref;\n\n  if (otherValue === void 0) {\n    otherValue = 0;\n  }\n\n  return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;\n};\nvar distance = function distance(point1, point2) {\n  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n};\nvar closest = function closest(target, points) {\n  return Math.min.apply(Math, points.map(function (point) {\n    return distance(target, point);\n  }));\n};\nvar apply = function apply(fn) {\n  return function (point) {\n    return {\n      x: fn(point.x),\n      y: fn(point.y)\n    };\n  };\n};\n\nvar executeClip = (function (frame, subject) {\n  var result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n    top: Math.max(subject.top, frame.top),\n    right: Math.min(subject.right, frame.right),\n    bottom: Math.min(subject.bottom, frame.bottom),\n    left: Math.max(subject.left, frame.left)\n  });\n\n  if (result.width <= 0 || result.height <= 0) {\n    return null;\n  }\n\n  return result;\n});\n\nvar offsetByPosition = function offsetByPosition(spacing, point) {\n  return {\n    top: spacing.top + point.y,\n    left: spacing.left + point.x,\n    bottom: spacing.bottom + point.y,\n    right: spacing.right + point.x\n  };\n};\nvar getCorners = function getCorners(spacing) {\n  return [{\n    x: spacing.left,\n    y: spacing.top\n  }, {\n    x: spacing.right,\n    y: spacing.top\n  }, {\n    x: spacing.left,\n    y: spacing.bottom\n  }, {\n    x: spacing.right,\n    y: spacing.bottom\n  }];\n};\nvar noSpacing = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n};\n\nvar scroll = function scroll(target, frame) {\n  if (!frame) {\n    return target;\n  }\n\n  return offsetByPosition(target, frame.scroll.diff.displacement);\n};\n\nvar increase = function increase(target, axis, withPlaceholder) {\n  if (withPlaceholder && withPlaceholder.increasedBy) {\n    var _extends2;\n\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));\n  }\n\n  return target;\n};\n\nvar clip = function clip(target, frame) {\n  if (frame && frame.shouldClipSubject) {\n    return executeClip(frame.pageMarginBox, target);\n  }\n\n  return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(target);\n};\n\nvar getSubject = (function (_ref) {\n  var page = _ref.page,\n      withPlaceholder = _ref.withPlaceholder,\n      axis = _ref.axis,\n      frame = _ref.frame;\n  var scrolled = scroll(page.marginBox, frame);\n  var increased = increase(scrolled, axis, withPlaceholder);\n  var clipped = clip(increased, frame);\n  return {\n    page: page,\n    withPlaceholder: withPlaceholder,\n    active: clipped\n  };\n});\n\nvar scrollDroppable = (function (droppable, newScroll) {\n  !droppable.frame ?  true ? invariant(false) : 0 : void 0;\n  var scrollable = droppable.frame;\n  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n  var scrollDisplacement = negate(scrollDiff);\n\n  var frame = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, scrollable, {\n    scroll: {\n      initial: scrollable.scroll.initial,\n      current: newScroll,\n      diff: {\n        value: scrollDiff,\n        displacement: scrollDisplacement\n      },\n      max: scrollable.scroll.max\n    }\n  });\n\n  var subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: droppable.subject.withPlaceholder,\n    axis: droppable.axis,\n    frame: frame\n  });\n\n  var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, droppable, {\n    frame: frame,\n    subject: subject\n  });\n\n  return result;\n});\n\nfunction isInteger(value) {\n  if (Number.isInteger) {\n    return Number.isInteger(value);\n  }\n\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\nfunction values(map) {\n  if (Object.values) {\n    return Object.values(map);\n  }\n\n  return Object.keys(map).map(function (key) {\n    return map[key];\n  });\n}\nfunction findIndex(list, predicate) {\n  if (list.findIndex) {\n    return list.findIndex(predicate);\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (predicate(list[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n}\nfunction find(list, predicate) {\n  if (list.find) {\n    return list.find(predicate);\n  }\n\n  var index = findIndex(list, predicate);\n\n  if (index !== -1) {\n    return list[index];\n  }\n\n  return undefined;\n}\nfunction toArray(list) {\n  return Array.prototype.slice.call(list);\n}\n\nvar toDroppableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (droppables) {\n  return droppables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDraggableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (draggables) {\n  return draggables.reduce(function (previous, current) {\n    previous[current.descriptor.id] = current;\n    return previous;\n  }, {});\n});\nvar toDroppableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (droppables) {\n  return values(droppables);\n});\nvar toDraggableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (draggables) {\n  return values(draggables);\n});\n\nvar getDraggablesInsideDroppable = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (droppableId, draggables) {\n  var result = toDraggableList(draggables).filter(function (draggable) {\n    return droppableId === draggable.descriptor.droppableId;\n  }).sort(function (a, b) {\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return result;\n});\n\nfunction tryGetDestination(impact) {\n  if (impact.at && impact.at.type === 'REORDER') {\n    return impact.at.destination;\n  }\n\n  return null;\n}\nfunction tryGetCombine(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at.combine;\n  }\n\n  return null;\n}\n\nvar removeDraggableFromList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (remove, list) {\n  return list.filter(function (item) {\n    return item.descriptor.id !== remove.descriptor.id;\n  });\n});\n\nvar moveToNextCombine = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var location = tryGetDestination(previousImpact);\n\n  if (!location) {\n    return null;\n  }\n\n  function getImpact(target) {\n    var at = {\n      type: 'COMBINE',\n      combine: {\n        draggableId: target,\n        droppableId: destination.descriptor.id\n      }\n    };\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, previousImpact, {\n      at: at\n    });\n  }\n\n  var all = previousImpact.displaced.all;\n  var closestId = all.length ? all[0] : null;\n\n  if (isMovingForward) {\n    return closestId ? getImpact(closestId) : null;\n  }\n\n  var withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n\n  if (!closestId) {\n    if (!withoutDraggable.length) {\n      return null;\n    }\n\n    var last = withoutDraggable[withoutDraggable.length - 1];\n    return getImpact(last.descriptor.id);\n  }\n\n  var indexOfClosest = findIndex(withoutDraggable, function (d) {\n    return d.descriptor.id === closestId;\n  });\n  !(indexOfClosest !== -1) ?  true ? invariant(false, 'Could not find displaced item in set') : 0 : void 0;\n  var proposedIndex = indexOfClosest - 1;\n\n  if (proposedIndex < 0) {\n    return null;\n  }\n\n  var before = withoutDraggable[proposedIndex];\n  return getImpact(before.descriptor.id);\n});\n\nvar isHomeOf = (function (draggable, destination) {\n  return draggable.descriptor.droppableId === destination.descriptor.id;\n});\n\nvar noDisplacedBy = {\n  point: origin,\n  value: 0\n};\nvar emptyGroups = {\n  invisible: {},\n  visible: {},\n  all: []\n};\nvar noImpact = {\n  displaced: emptyGroups,\n  displacedBy: noDisplacedBy,\n  at: null\n};\n\nvar isWithin = (function (lowerBound, upperBound) {\n  return function (value) {\n    return lowerBound <= value && value <= upperBound;\n  };\n});\n\nvar isPartiallyVisibleThroughFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n\n    if (isContained) {\n      return true;\n    }\n\n    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n\n    if (isPartiallyContained) {\n      return true;\n    }\n\n    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n\n    if (isTargetBiggerThanFrame) {\n      return true;\n    }\n\n    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n    return isTargetBiggerOnOneAxis;\n  };\n});\n\nvar isTotallyVisibleThroughFrame = (function (frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function (subject) {\n    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    return isContained;\n  };\n});\n\nvar vertical = {\n  direction: 'vertical',\n  line: 'y',\n  crossAxisLine: 'x',\n  start: 'top',\n  end: 'bottom',\n  size: 'height',\n  crossAxisStart: 'left',\n  crossAxisEnd: 'right',\n  crossAxisSize: 'width'\n};\nvar horizontal = {\n  direction: 'horizontal',\n  line: 'x',\n  crossAxisLine: 'y',\n  start: 'left',\n  end: 'right',\n  size: 'width',\n  crossAxisStart: 'top',\n  crossAxisEnd: 'bottom',\n  crossAxisSize: 'height'\n};\n\nvar isTotallyVisibleThroughFrameOnAxis = (function (axis) {\n  return function (frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function (subject) {\n      if (axis === vertical) {\n        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n      }\n\n      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    };\n  };\n});\n\nvar getDroppableDisplaced = function getDroppableDisplaced(target, destination) {\n  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n  return offsetByPosition(target, displacement);\n};\n\nvar isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {\n  if (!destination.subject.active) {\n    return false;\n  }\n\n  return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\n\nvar isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {\n  return isVisibleThroughFrameFn(viewport)(target);\n};\n\nvar isVisible = function isVisible(_ref) {\n  var toBeDisplaced = _ref.target,\n      destination = _ref.destination,\n      viewport = _ref.viewport,\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\n      isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\n  var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\n\nvar isPartiallyVisible = function isPartiallyVisible(args) {\n  return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, args, {\n    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n  }));\n};\nvar isTotallyVisible = function isTotallyVisible(args) {\n  return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, args, {\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n  }));\n};\nvar isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {\n  return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, args, {\n    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n  }));\n};\n\nvar getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {\n  if (typeof forceShouldAnimate === 'boolean') {\n    return forceShouldAnimate;\n  }\n\n  if (!last) {\n    return true;\n  }\n\n  var invisible = last.invisible,\n      visible = last.visible;\n\n  if (invisible[id]) {\n    return false;\n  }\n\n  var previous = visible[id];\n  return previous ? previous.shouldAnimate : true;\n};\n\nfunction getTarget(draggable, displacedBy) {\n  var marginBox = draggable.page.marginBox;\n  var expandBy = {\n    top: displacedBy.point.y,\n    right: 0,\n    bottom: 0,\n    left: displacedBy.point.x\n  };\n  return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.expand)(marginBox, expandBy));\n}\n\nfunction getDisplacementGroups(_ref) {\n  var afterDragging = _ref.afterDragging,\n      destination = _ref.destination,\n      displacedBy = _ref.displacedBy,\n      viewport = _ref.viewport,\n      forceShouldAnimate = _ref.forceShouldAnimate,\n      last = _ref.last;\n  return afterDragging.reduce(function process(groups, draggable) {\n    var target = getTarget(draggable, displacedBy);\n    var id = draggable.descriptor.id;\n    groups.all.push(id);\n    var isVisible = isPartiallyVisible({\n      target: target,\n      destination: destination,\n      viewport: viewport,\n      withDroppableDisplacement: true\n    });\n\n    if (!isVisible) {\n      groups.invisible[draggable.descriptor.id] = true;\n      return groups;\n    }\n\n    var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n    var displacement = {\n      draggableId: id,\n      shouldAnimate: shouldAnimate\n    };\n    groups.visible[id] = displacement;\n    return groups;\n  }, {\n    all: [],\n    visible: {},\n    invisible: {}\n  });\n}\n\nfunction getIndexOfLastItem(draggables, options) {\n  if (!draggables.length) {\n    return 0;\n  }\n\n  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\n\nfunction goAtEnd(_ref) {\n  var insideDestination = _ref.insideDestination,\n      inHomeList = _ref.inHomeList,\n      displacedBy = _ref.displacedBy,\n      destination = _ref.destination;\n  var newIndex = getIndexOfLastItem(insideDestination, {\n    inHomeList: inHomeList\n  });\n  return {\n    displaced: emptyGroups,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: newIndex\n      }\n    }\n  };\n}\n\nfunction calculateReorderImpact(_ref2) {\n  var draggable = _ref2.draggable,\n      insideDestination = _ref2.insideDestination,\n      destination = _ref2.destination,\n      viewport = _ref2.viewport,\n      displacedBy = _ref2.displacedBy,\n      last = _ref2.last,\n      index = _ref2.index,\n      forceShouldAnimate = _ref2.forceShouldAnimate;\n  var inHomeList = isHomeOf(draggable, destination);\n\n  if (index == null) {\n    return goAtEnd({\n      insideDestination: insideDestination,\n      inHomeList: inHomeList,\n      displacedBy: displacedBy,\n      destination: destination\n    });\n  }\n\n  var match = find(insideDestination, function (item) {\n    return item.descriptor.index === index;\n  });\n\n  if (!match) {\n    return goAtEnd({\n      insideDestination: insideDestination,\n      inHomeList: inHomeList,\n      displacedBy: displacedBy,\n      destination: destination\n    });\n  }\n\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  var sliceFrom = insideDestination.indexOf(match);\n  var impacted = withoutDragging.slice(sliceFrom);\n  var displaced = getDisplacementGroups({\n    afterDragging: impacted,\n    destination: destination,\n    displacedBy: displacedBy,\n    last: last,\n    viewport: viewport.frame,\n    forceShouldAnimate: forceShouldAnimate\n  });\n  return {\n    displaced: displaced,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: index\n      }\n    }\n  };\n}\n\nfunction didStartAfterCritical(draggableId, afterCritical) {\n  return Boolean(afterCritical.effected[draggableId]);\n}\n\nvar fromCombine = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      combine = _ref.combine,\n      afterCritical = _ref.afterCritical;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var combineId = combine.draggableId;\n  var combineWith = draggables[combineId];\n  var combineWithIndex = combineWith.descriptor.index;\n  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n\n  if (didCombineWithStartAfterCritical) {\n    if (isMovingForward) {\n      return combineWithIndex;\n    }\n\n    return combineWithIndex - 1;\n  }\n\n  if (isMovingForward) {\n    return combineWithIndex + 1;\n  }\n\n  return combineWithIndex;\n});\n\nvar fromReorder = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      insideDestination = _ref.insideDestination,\n      location = _ref.location;\n\n  if (!insideDestination.length) {\n    return null;\n  }\n\n  var currentIndex = location.index;\n  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n  var firstIndex = insideDestination[0].descriptor.index;\n  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n\n  if (proposedIndex < firstIndex) {\n    return null;\n  }\n\n  if (proposedIndex > upperBound) {\n    return null;\n  }\n\n  return proposedIndex;\n});\n\nvar moveToNextIndex = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      isInHomeList = _ref.isInHomeList,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var wasAt = previousImpact.at;\n  !wasAt ?  true ? invariant(false, 'Cannot move in direction without previous impact location') : 0 : void 0;\n\n  if (wasAt.type === 'REORDER') {\n    var _newIndex = fromReorder({\n      isMovingForward: isMovingForward,\n      isInHomeList: isInHomeList,\n      location: wasAt.destination,\n      insideDestination: insideDestination\n    });\n\n    if (_newIndex == null) {\n      return null;\n    }\n\n    return calculateReorderImpact({\n      draggable: draggable,\n      insideDestination: insideDestination,\n      destination: destination,\n      viewport: viewport,\n      last: previousImpact.displaced,\n      displacedBy: previousImpact.displacedBy,\n      index: _newIndex\n    });\n  }\n\n  var newIndex = fromCombine({\n    isMovingForward: isMovingForward,\n    destination: destination,\n    displaced: previousImpact.displaced,\n    draggables: draggables,\n    combine: wasAt.combine,\n    afterCritical: afterCritical\n  });\n\n  if (newIndex == null) {\n    return null;\n  }\n\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    last: previousImpact.displaced,\n    displacedBy: previousImpact.displacedBy,\n    index: newIndex\n  });\n});\n\nvar getCombinedItemDisplacement = (function (_ref) {\n  var displaced = _ref.displaced,\n      afterCritical = _ref.afterCritical,\n      combineWith = _ref.combineWith,\n      displacedBy = _ref.displacedBy;\n  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n\n  if (didStartAfterCritical(combineWith, afterCritical)) {\n    return isDisplaced ? origin : negate(displacedBy.point);\n  }\n\n  return isDisplaced ? displacedBy.point : origin;\n});\n\nvar whenCombining = (function (_ref) {\n  var afterCritical = _ref.afterCritical,\n      impact = _ref.impact,\n      draggables = _ref.draggables;\n  var combine = tryGetCombine(impact);\n  !combine ?  true ? invariant(false) : 0 : void 0;\n  var combineWith = combine.draggableId;\n  var center = draggables[combineWith].page.borderBox.center;\n  var displaceBy = getCombinedItemDisplacement({\n    displaced: impact.displaced,\n    afterCritical: afterCritical,\n    combineWith: combineWith,\n    displacedBy: impact.displacedBy\n  });\n  return add(center, displaceBy);\n});\n\nvar distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {\n  return box.margin[axis.start] + box.borderBox[axis.size] / 2;\n};\n\nvar distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {\n  return box.margin[axis.end] + box.borderBox[axis.size] / 2;\n};\n\nvar getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {\n  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\n};\n\nvar goAfter = function goAfter(_ref) {\n  var axis = _ref.axis,\n      moveRelativeTo = _ref.moveRelativeTo,\n      isMoving = _ref.isMoving;\n  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goBefore = function goBefore(_ref2) {\n  var axis = _ref2.axis,\n      moveRelativeTo = _ref2.moveRelativeTo,\n      isMoving = _ref2.isMoving;\n  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goIntoStart = function goIntoStart(_ref3) {\n  var axis = _ref3.axis,\n      moveInto = _ref3.moveInto,\n      isMoving = _ref3.isMoving;\n  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n};\n\nvar whenReordering = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppable = _ref.droppable,\n      afterCritical = _ref.afterCritical;\n  var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  var draggablePage = draggable.page;\n  var axis = droppable.axis;\n\n  if (!insideDestination.length) {\n    return goIntoStart({\n      axis: axis,\n      moveInto: droppable.page,\n      isMoving: draggablePage\n    });\n  }\n\n  var displaced = impact.displaced,\n      displacedBy = impact.displacedBy;\n  var closestAfter = displaced.all[0];\n\n  if (closestAfter) {\n    var closest = draggables[closestAfter];\n\n    if (didStartAfterCritical(closestAfter, afterCritical)) {\n      return goBefore({\n        axis: axis,\n        moveRelativeTo: closest.page,\n        isMoving: draggablePage\n      });\n    }\n\n    var withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(closest.page, displacedBy.point);\n    return goBefore({\n      axis: axis,\n      moveRelativeTo: withDisplacement,\n      isMoving: draggablePage\n    });\n  }\n\n  var last = insideDestination[insideDestination.length - 1];\n\n  if (last.descriptor.id === draggable.descriptor.id) {\n    return draggablePage.borderBox.center;\n  }\n\n  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n    var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(last.page, negate(afterCritical.displacedBy.point));\n    return goAfter({\n      axis: axis,\n      moveRelativeTo: page,\n      isMoving: draggablePage\n    });\n  }\n\n  return goAfter({\n    axis: axis,\n    moveRelativeTo: last.page,\n    isMoving: draggablePage\n  });\n});\n\nvar withDroppableDisplacement = (function (droppable, point) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return point;\n  }\n\n  return add(point, frame.scroll.diff.displacement);\n});\n\nvar getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      afterCritical = _ref.afterCritical;\n  var original = draggable.page.borderBox.center;\n  var at = impact.at;\n\n  if (!droppable) {\n    return original;\n  }\n\n  if (!at) {\n    return original;\n  }\n\n  if (at.type === 'REORDER') {\n    return whenReordering({\n      impact: impact,\n      draggable: draggable,\n      draggables: draggables,\n      droppable: droppable,\n      afterCritical: afterCritical\n    });\n  }\n\n  return whenCombining({\n    impact: impact,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n};\n\nvar getPageBorderBoxCenterFromImpact = (function (args) {\n  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n  var droppable = args.droppable;\n  var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n  return withDisplacement;\n});\n\nvar scrollViewport = (function (viewport, newScroll) {\n  var diff = subtract(newScroll, viewport.scroll.initial);\n  var displacement = negate(diff);\n  var frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n    top: newScroll.y,\n    bottom: newScroll.y + viewport.frame.height,\n    left: newScroll.x,\n    right: newScroll.x + viewport.frame.width\n  });\n  var updated = {\n    frame: frame,\n    scroll: {\n      initial: viewport.scroll.initial,\n      max: viewport.scroll.max,\n      current: newScroll,\n      diff: {\n        value: diff,\n        displacement: displacement\n      }\n    }\n  };\n  return updated;\n});\n\nfunction getDraggables(ids, draggables) {\n  return ids.map(function (id) {\n    return draggables[id];\n  });\n}\n\nfunction tryGetVisible(id, groups) {\n  for (var i = 0; i < groups.length; i++) {\n    var displacement = groups[i].visible[id];\n\n    if (displacement) {\n      return displacement;\n    }\n  }\n\n  return null;\n}\n\nvar speculativelyIncrease = (function (_ref) {\n  var impact = _ref.impact,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      maxScrollChange = _ref.maxScrollChange;\n  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n  var last = impact.displaced;\n  var withViewportScroll = getDisplacementGroups({\n    afterDragging: getDraggables(last.all, draggables),\n    destination: destination,\n    displacedBy: impact.displacedBy,\n    viewport: scrolledViewport.frame,\n    last: last,\n    forceShouldAnimate: false\n  });\n  var withDroppableScroll = getDisplacementGroups({\n    afterDragging: getDraggables(last.all, draggables),\n    destination: scrolledDroppable,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    last: last,\n    forceShouldAnimate: false\n  });\n  var invisible = {};\n  var visible = {};\n  var groups = [last, withViewportScroll, withDroppableScroll];\n  last.all.forEach(function (id) {\n    var displacement = tryGetVisible(id, groups);\n\n    if (displacement) {\n      visible[id] = displacement;\n      return;\n    }\n\n    invisible[id] = true;\n  });\n\n  var newImpact = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, impact, {\n    displaced: {\n      all: last.all,\n      invisible: invisible,\n      visible: visible\n    }\n  });\n\n  return newImpact;\n});\n\nvar withViewportDisplacement = (function (viewport, point) {\n  return add(viewport.scroll.diff.displacement, point);\n});\n\nvar getClientFromPageBorderBoxCenter = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      draggable = _ref.draggable,\n      viewport = _ref.viewport;\n  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n  var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n  return add(draggable.client.borderBox.center, offset);\n});\n\nvar isTotallyVisibleInNewLocation = (function (_ref) {\n  var draggable = _ref.draggable,\n      destination = _ref.destination,\n      newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,\n      viewport = _ref.viewport,\n      withDroppableDisplacement = _ref.withDroppableDisplacement,\n      _ref$onlyOnMainAxis = _ref.onlyOnMainAxis,\n      onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;\n  var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n  var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n  var args = {\n    target: shifted,\n    destination: destination,\n    withDroppableDisplacement: withDroppableDisplacement,\n    viewport: viewport\n  };\n  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n});\n\nvar moveToNextPlace = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      draggable = _ref.draggable,\n      destination = _ref.destination,\n      draggables = _ref.draggables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      previousClientSelection = _ref.previousClientSelection,\n      afterCritical = _ref.afterCritical;\n\n  if (!destination.isEnabled) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var isInHomeList = isHomeOf(draggable, destination);\n  var impact = moveToNextCombine({\n    isMovingForward: isMovingForward,\n    draggable: draggable,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact\n  }) || moveToNextIndex({\n    isMovingForward: isMovingForward,\n    isInHomeList: isInHomeList,\n    draggable: draggable,\n    draggables: draggables,\n    destination: destination,\n    insideDestination: insideDestination,\n    previousImpact: previousImpact,\n    viewport: viewport,\n    afterCritical: afterCritical\n  });\n\n  if (!impact) {\n    return null;\n  }\n\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n    draggable: draggable,\n    destination: destination,\n    newPageBorderBoxCenter: pageBorderBoxCenter,\n    viewport: viewport.frame,\n    withDroppableDisplacement: false,\n    onlyOnMainAxis: true\n  });\n\n  if (isVisibleInNewLocation) {\n    var clientSelection = getClientFromPageBorderBoxCenter({\n      pageBorderBoxCenter: pageBorderBoxCenter,\n      draggable: draggable,\n      viewport: viewport\n    });\n    return {\n      clientSelection: clientSelection,\n      impact: impact,\n      scrollJumpRequest: null\n    };\n  }\n\n  var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n  var cautious = speculativelyIncrease({\n    impact: impact,\n    viewport: viewport,\n    destination: destination,\n    draggables: draggables,\n    maxScrollChange: distance\n  });\n  return {\n    clientSelection: previousClientSelection,\n    impact: cautious,\n    scrollJumpRequest: distance\n  };\n});\n\nvar getKnownActive = function getKnownActive(droppable) {\n  var rect = droppable.subject.active;\n  !rect ?  true ? invariant(false, 'Cannot get clipped area from droppable') : 0 : void 0;\n  return rect;\n};\n\nvar getBestCrossAxisDroppable = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      source = _ref.source,\n      droppables = _ref.droppables,\n      viewport = _ref.viewport;\n  var active = source.subject.active;\n\n  if (!active) {\n    return null;\n  }\n\n  var axis = source.axis;\n  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n  var candidates = toDroppableList(droppables).filter(function (droppable) {\n    return droppable !== source;\n  }).filter(function (droppable) {\n    return droppable.isEnabled;\n  }).filter(function (droppable) {\n    return Boolean(droppable.subject.active);\n  }).filter(function (droppable) {\n    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));\n  }).filter(function (droppable) {\n    var activeOfTarget = getKnownActive(droppable);\n\n    if (isMovingForward) {\n      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n    }\n\n    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n  }).filter(function (droppable) {\n    var activeOfTarget = getKnownActive(droppable);\n    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n  }).sort(function (a, b) {\n    var first = getKnownActive(a)[axis.crossAxisStart];\n    var second = getKnownActive(b)[axis.crossAxisStart];\n\n    if (isMovingForward) {\n      return first - second;\n    }\n\n    return second - first;\n  }).filter(function (droppable, index, array) {\n    return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];\n  });\n\n  if (!candidates.length) {\n    return null;\n  }\n\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n\n  var contains = candidates.filter(function (droppable) {\n    var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n  });\n\n  if (contains.length === 1) {\n    return contains[0];\n  }\n\n  if (contains.length > 1) {\n    return contains.sort(function (a, b) {\n      return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n  }\n\n  return candidates.sort(function (a, b) {\n    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n\n    if (first !== second) {\n      return first - second;\n    }\n\n    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n  })[0];\n});\n\nvar getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {\n  var original = draggable.page.borderBox.center;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nvar getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {\n  var original = draggable.page.borderBox;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\n\nvar getClosestDraggable = (function (_ref) {\n  var pageBorderBoxCenter = _ref.pageBorderBoxCenter,\n      viewport = _ref.viewport,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      afterCritical = _ref.afterCritical;\n  var sorted = insideDestination.filter(function (draggable) {\n    return isTotallyVisible({\n      target: getCurrentPageBorderBox(draggable, afterCritical),\n      destination: destination,\n      viewport: viewport.frame,\n      withDroppableDisplacement: true\n    });\n  }).sort(function (a, b) {\n    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n\n    if (distanceToA < distanceToB) {\n      return -1;\n    }\n\n    if (distanceToB < distanceToA) {\n      return 1;\n    }\n\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return sorted[0] || null;\n});\n\nvar getDisplacedBy = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function getDisplacedBy(axis, displaceBy) {\n  var displacement = displaceBy[axis.line];\n  return {\n    value: displacement,\n    point: patch(axis.line, displacement)\n  };\n});\n\nvar getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {\n  var axis = droppable.axis;\n\n  if (droppable.descriptor.mode === 'virtual') {\n    return patch(axis.line, placeholderSize[axis.line]);\n  }\n\n  var availableSpace = droppable.subject.page.contentBox[axis.size];\n  var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  var spaceUsed = insideDroppable.reduce(function (sum, dimension) {\n    return sum + dimension.client.marginBox[axis.size];\n  }, 0);\n  var requiredSpace = spaceUsed + placeholderSize[axis.line];\n  var needsToGrowBy = requiredSpace - availableSpace;\n\n  if (needsToGrowBy <= 0) {\n    return null;\n  }\n\n  return patch(axis.line, needsToGrowBy);\n};\n\nvar withMaxScroll = function withMaxScroll(frame, max) {\n  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, frame, {\n    scroll: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, frame.scroll, {\n      max: max\n    })\n  });\n};\n\nvar addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {\n  var frame = droppable.frame;\n  !!isHomeOf(draggable, droppable) ?  true ? invariant(false, 'Should not add placeholder space to home list') : 0 : void 0;\n  !!droppable.subject.withPlaceholder ?  true ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : 0 : void 0;\n  var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n  var added = {\n    placeholderSize: placeholderSize,\n    increasedBy: requiredGrowth,\n    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n  };\n\n  if (!frame) {\n    var _subject = getSubject({\n      page: droppable.subject.page,\n      withPlaceholder: added,\n      axis: droppable.axis,\n      frame: droppable.frame\n    });\n\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, droppable, {\n      subject: _subject\n    });\n  }\n\n  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n  var newFrame = withMaxScroll(frame, maxScroll);\n  var subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: added,\n    axis: droppable.axis,\n    frame: newFrame\n  });\n  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, droppable, {\n    subject: subject,\n    frame: newFrame\n  });\n};\nvar removePlaceholder = function removePlaceholder(droppable) {\n  var added = droppable.subject.withPlaceholder;\n  !added ?  true ? invariant(false, 'Cannot remove placeholder form subject when there was none') : 0 : void 0;\n  var frame = droppable.frame;\n\n  if (!frame) {\n    var _subject2 = getSubject({\n      page: droppable.subject.page,\n      axis: droppable.axis,\n      frame: null,\n      withPlaceholder: null\n    });\n\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, droppable, {\n      subject: _subject2\n    });\n  }\n\n  var oldMaxScroll = added.oldFrameMaxScroll;\n  !oldMaxScroll ?  true ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : 0 : void 0;\n  var newFrame = withMaxScroll(frame, oldMaxScroll);\n  var subject = getSubject({\n    page: droppable.subject.page,\n    axis: droppable.axis,\n    frame: newFrame,\n    withPlaceholder: null\n  });\n  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, droppable, {\n    subject: subject,\n    frame: newFrame\n  });\n};\n\nvar moveToNewDroppable = (function (_ref) {\n  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      moveRelativeTo = _ref.moveRelativeTo,\n      insideDestination = _ref.insideDestination,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n\n  if (!moveRelativeTo) {\n    if (insideDestination.length) {\n      return null;\n    }\n\n    var proposed = {\n      displaced: emptyGroups,\n      displacedBy: noDisplacedBy,\n      at: {\n        type: 'REORDER',\n        destination: {\n          droppableId: destination.descriptor.id,\n          index: 0\n        }\n      }\n    };\n    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n      impact: proposed,\n      draggable: draggable,\n      droppable: destination,\n      draggables: draggables,\n      afterCritical: afterCritical\n    });\n    var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n      draggable: draggable,\n      destination: withPlaceholder,\n      newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n      viewport: viewport.frame,\n      withDroppableDisplacement: false,\n      onlyOnMainAxis: true\n    });\n    return isVisibleInNewLocation ? proposed : null;\n  }\n\n  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n\n  var proposedIndex = function () {\n    var relativeTo = moveRelativeTo.descriptor.index;\n\n    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n      return relativeTo;\n    }\n\n    if (isGoingBeforeTarget) {\n      return relativeTo;\n    }\n\n    return relativeTo + 1;\n  }();\n\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    displacedBy: displacedBy,\n    last: emptyGroups,\n    index: proposedIndex\n  });\n});\n\nvar moveCrossAxis = (function (_ref) {\n  var isMovingForward = _ref.isMovingForward,\n      previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,\n      draggable = _ref.draggable,\n      isOver = _ref.isOver,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var destination = getBestCrossAxisDroppable({\n    isMovingForward: isMovingForward,\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    source: isOver,\n    droppables: droppables,\n    viewport: viewport\n  });\n\n  if (!destination) {\n    return null;\n  }\n\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var moveRelativeTo = getClosestDraggable({\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    viewport: viewport,\n    destination: destination,\n    insideDestination: insideDestination,\n    afterCritical: afterCritical\n  });\n  var impact = moveToNewDroppable({\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    destination: destination,\n    draggable: draggable,\n    draggables: draggables,\n    moveRelativeTo: moveRelativeTo,\n    insideDestination: insideDestination,\n    viewport: viewport,\n    afterCritical: afterCritical\n  });\n\n  if (!impact) {\n    return null;\n  }\n\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    afterCritical: afterCritical\n  });\n  var clientSelection = getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    viewport: viewport\n  });\n  return {\n    clientSelection: clientSelection,\n    impact: impact,\n    scrollJumpRequest: null\n  };\n});\n\nvar whatIsDraggedOver = (function (impact) {\n  var at = impact.at;\n\n  if (!at) {\n    return null;\n  }\n\n  if (at.type === 'REORDER') {\n    return at.destination.droppableId;\n  }\n\n  return at.combine.droppableId;\n});\n\nvar getDroppableOver = function getDroppableOver(impact, droppables) {\n  var id = whatIsDraggedOver(impact);\n  return id ? droppables[id] : null;\n};\n\nvar moveInDirection = (function (_ref) {\n  var state = _ref.state,\n      type = _ref.type;\n  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);\n  var isMainAxisMovementAllowed = Boolean(isActuallyOver);\n  var home = state.dimensions.droppables[state.critical.droppable.id];\n  var isOver = isActuallyOver || home;\n  var direction = isOver.axis.direction;\n  var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\n\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n    return null;\n  }\n\n  var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\n  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n  var _state$dimensions = state.dimensions,\n      draggables = _state$dimensions.draggables,\n      droppables = _state$dimensions.droppables;\n  return isMovingOnMainAxis ? moveToNextPlace({\n    isMovingForward: isMovingForward,\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    draggable: draggable,\n    destination: isOver,\n    draggables: draggables,\n    viewport: state.viewport,\n    previousClientSelection: state.current.client.selection,\n    previousImpact: state.impact,\n    afterCritical: state.afterCritical\n  }) : moveCrossAxis({\n    isMovingForward: isMovingForward,\n    previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n    draggable: draggable,\n    isOver: isOver,\n    draggables: draggables,\n    droppables: droppables,\n    viewport: state.viewport,\n    afterCritical: state.afterCritical\n  });\n});\n\nfunction isMovementAllowed(state) {\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\n}\n\nfunction isPositionInFrame(frame) {\n  var isWithinVertical = isWithin(frame.top, frame.bottom);\n  var isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function run(point) {\n    return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n  };\n}\n\nfunction getHasOverlap(first, second) {\n  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\n\nfunction getFurthestAway(_ref) {\n  var pageBorderBox = _ref.pageBorderBox,\n      draggable = _ref.draggable,\n      candidates = _ref.candidates;\n  var startCenter = draggable.page.borderBox.center;\n  var sorted = candidates.map(function (candidate) {\n    var axis = candidate.axis;\n    var target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n    return {\n      id: candidate.descriptor.id,\n      distance: distance(startCenter, target)\n    };\n  }).sort(function (a, b) {\n    return b.distance - a.distance;\n  });\n  return sorted[0] ? sorted[0].id : null;\n}\n\nfunction getDroppableOver$1(_ref2) {\n  var pageBorderBox = _ref2.pageBorderBox,\n      draggable = _ref2.draggable,\n      droppables = _ref2.droppables;\n  var candidates = toDroppableList(droppables).filter(function (item) {\n    if (!item.isEnabled) {\n      return false;\n    }\n\n    var active = item.subject.active;\n\n    if (!active) {\n      return false;\n    }\n\n    if (!getHasOverlap(pageBorderBox, active)) {\n      return false;\n    }\n\n    if (isPositionInFrame(active)(pageBorderBox.center)) {\n      return true;\n    }\n\n    var axis = item.axis;\n    var childCenter = active.center[axis.crossAxisLine];\n    var crossAxisStart = pageBorderBox[axis.crossAxisStart];\n    var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n    var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n    var isStartContained = isContained(crossAxisStart);\n    var isEndContained = isContained(crossAxisEnd);\n\n    if (!isStartContained && !isEndContained) {\n      return true;\n    }\n\n    if (isStartContained) {\n      return crossAxisStart < childCenter;\n    }\n\n    return crossAxisEnd > childCenter;\n  });\n\n  if (!candidates.length) {\n    return null;\n  }\n\n  if (candidates.length === 1) {\n    return candidates[0].descriptor.id;\n  }\n\n  return getFurthestAway({\n    pageBorderBox: pageBorderBox,\n    draggable: draggable,\n    candidates: candidates\n  });\n}\n\nvar offsetRectByPosition = function offsetRectByPosition(rect, point) {\n  return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(offsetByPosition(rect, point));\n};\n\nvar withDroppableScroll = (function (droppable, area) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return area;\n  }\n\n  return offsetRectByPosition(area, frame.scroll.diff.value);\n});\n\nfunction getIsDisplaced(_ref) {\n  var displaced = _ref.displaced,\n      id = _ref.id;\n  return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\n\nfunction atIndex(_ref) {\n  var draggable = _ref.draggable,\n      closest = _ref.closest,\n      inHomeList = _ref.inHomeList;\n\n  if (!closest) {\n    return null;\n  }\n\n  if (!inHomeList) {\n    return closest.descriptor.index;\n  }\n\n  if (closest.descriptor.index > draggable.descriptor.index) {\n    return closest.descriptor.index - 1;\n  }\n\n  return closest.descriptor.index;\n}\n\nvar getReorderImpact = (function (_ref2) {\n  var targetRect = _ref2.pageBorderBoxWithDroppableScroll,\n      draggable = _ref2.draggable,\n      destination = _ref2.destination,\n      insideDestination = _ref2.insideDestination,\n      last = _ref2.last,\n      viewport = _ref2.viewport,\n      afterCritical = _ref2.afterCritical;\n  var axis = destination.axis;\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  var displacement = displacedBy.value;\n  var targetStart = targetRect[axis.start];\n  var targetEnd = targetRect[axis.end];\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  var closest = find(withoutDragging, function (child) {\n    var id = child.descriptor.id;\n    var childCenter = child.page.borderBox.center[axis.line];\n    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n    var isDisplaced = getIsDisplaced({\n      displaced: last,\n      id: id\n    });\n\n    if (didStartAfterCritical$1) {\n      if (isDisplaced) {\n        return targetEnd <= childCenter;\n      }\n\n      return targetStart < childCenter - displacement;\n    }\n\n    if (isDisplaced) {\n      return targetEnd <= childCenter + displacement;\n    }\n\n    return targetStart < childCenter;\n  });\n  var newIndex = atIndex({\n    draggable: draggable,\n    closest: closest,\n    inHomeList: isHomeOf(draggable, destination)\n  });\n  return calculateReorderImpact({\n    draggable: draggable,\n    insideDestination: insideDestination,\n    destination: destination,\n    viewport: viewport,\n    last: last,\n    displacedBy: displacedBy,\n    index: newIndex\n  });\n});\n\nvar combineThresholdDivisor = 4;\nvar getCombineImpact = (function (_ref) {\n  var draggable = _ref.draggable,\n      targetRect = _ref.pageBorderBoxWithDroppableScroll,\n      previousImpact = _ref.previousImpact,\n      destination = _ref.destination,\n      insideDestination = _ref.insideDestination,\n      afterCritical = _ref.afterCritical;\n\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n\n  var axis = destination.axis;\n  var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  var displacement = displacedBy.value;\n  var targetStart = targetRect[axis.start];\n  var targetEnd = targetRect[axis.end];\n  var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  var combineWith = find(withoutDragging, function (child) {\n    var id = child.descriptor.id;\n    var childRect = child.page.borderBox;\n    var childSize = childRect[axis.size];\n    var threshold = childSize / combineThresholdDivisor;\n    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n    var isDisplaced = getIsDisplaced({\n      displaced: previousImpact.displaced,\n      id: id\n    });\n\n    if (didStartAfterCritical$1) {\n      if (isDisplaced) {\n        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n      }\n\n      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n    }\n\n    if (isDisplaced) {\n      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n    }\n\n    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n  });\n\n  if (!combineWith) {\n    return null;\n  }\n\n  var impact = {\n    displacedBy: displacedBy,\n    displaced: previousImpact.displaced,\n    at: {\n      type: 'COMBINE',\n      combine: {\n        draggableId: combineWith.descriptor.id,\n        droppableId: destination.descriptor.id\n      }\n    }\n  };\n  return impact;\n});\n\nvar getDragImpact = (function (_ref) {\n  var pageOffset = _ref.pageOffset,\n      draggable = _ref.draggable,\n      draggables = _ref.draggables,\n      droppables = _ref.droppables,\n      previousImpact = _ref.previousImpact,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n  var destinationId = getDroppableOver$1({\n    pageBorderBox: pageBorderBox,\n    draggable: draggable,\n    droppables: droppables\n  });\n\n  if (!destinationId) {\n    return noImpact;\n  }\n\n  var destination = droppables[destinationId];\n  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n  return getCombineImpact({\n    pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,\n    draggable: draggable,\n    previousImpact: previousImpact,\n    destination: destination,\n    insideDestination: insideDestination,\n    afterCritical: afterCritical\n  }) || getReorderImpact({\n    pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,\n    draggable: draggable,\n    destination: destination,\n    insideDestination: insideDestination,\n    last: previousImpact.displaced,\n    viewport: viewport,\n    afterCritical: afterCritical\n  });\n});\n\nvar patchDroppableMap = (function (droppables, updated) {\n  var _extends2;\n\n  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));\n});\n\nvar clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {\n  var previousImpact = _ref.previousImpact,\n      impact = _ref.impact,\n      droppables = _ref.droppables;\n  var last = whatIsDraggedOver(previousImpact);\n  var now = whatIsDraggedOver(impact);\n\n  if (!last) {\n    return droppables;\n  }\n\n  if (last === now) {\n    return droppables;\n  }\n\n  var lastDroppable = droppables[last];\n\n  if (!lastDroppable.subject.withPlaceholder) {\n    return droppables;\n  }\n\n  var updated = removePlaceholder(lastDroppable);\n  return patchDroppableMap(droppables, updated);\n};\n\nvar recomputePlaceholders = (function (_ref2) {\n  var draggable = _ref2.draggable,\n      draggables = _ref2.draggables,\n      droppables = _ref2.droppables,\n      previousImpact = _ref2.previousImpact,\n      impact = _ref2.impact;\n  var cleaned = clearUnusedPlaceholder({\n    previousImpact: previousImpact,\n    impact: impact,\n    droppables: droppables\n  });\n  var isOver = whatIsDraggedOver(impact);\n\n  if (!isOver) {\n    return cleaned;\n  }\n\n  var droppable = droppables[isOver];\n\n  if (isHomeOf(draggable, droppable)) {\n    return cleaned;\n  }\n\n  if (droppable.subject.withPlaceholder) {\n    return cleaned;\n  }\n\n  var patched = addPlaceholder(droppable, draggable, draggables);\n  return patchDroppableMap(cleaned, patched);\n});\n\nvar update = (function (_ref) {\n  var state = _ref.state,\n      forcedClientSelection = _ref.clientSelection,\n      forcedDimensions = _ref.dimensions,\n      forcedViewport = _ref.viewport,\n      forcedImpact = _ref.impact,\n      scrollJumpRequest = _ref.scrollJumpRequest;\n  var viewport = forcedViewport || state.viewport;\n  var dimensions = forcedDimensions || state.dimensions;\n  var clientSelection = forcedClientSelection || state.current.client.selection;\n  var offset = subtract(clientSelection, state.initial.client.selection);\n  var client = {\n    offset: offset,\n    selection: clientSelection,\n    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n  };\n  var page = {\n    selection: add(client.selection, viewport.scroll.current),\n    borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n    offset: add(client.offset, viewport.scroll.diff.value)\n  };\n  var current = {\n    client: client,\n    page: page\n  };\n\n  if (state.phase === 'COLLECTING') {\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n      phase: 'COLLECTING'\n    }, state, {\n      dimensions: dimensions,\n      viewport: viewport,\n      current: current\n    });\n  }\n\n  var draggable = dimensions.draggables[state.critical.draggable.id];\n  var newImpact = forcedImpact || getDragImpact({\n    pageOffset: page.offset,\n    draggable: draggable,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: state.impact,\n    viewport: viewport,\n    afterCritical: state.afterCritical\n  });\n  var withUpdatedPlaceholders = recomputePlaceholders({\n    draggable: draggable,\n    impact: newImpact,\n    previousImpact: state.impact,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables\n  });\n\n  var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, state, {\n    current: current,\n    dimensions: {\n      draggables: dimensions.draggables,\n      droppables: withUpdatedPlaceholders\n    },\n    impact: newImpact,\n    viewport: viewport,\n    scrollJumpRequest: scrollJumpRequest || null,\n    forceShouldAnimate: scrollJumpRequest ? false : null\n  });\n\n  return result;\n});\n\nfunction getDraggables$1(ids, draggables) {\n  return ids.map(function (id) {\n    return draggables[id];\n  });\n}\n\nvar recompute = (function (_ref) {\n  var impact = _ref.impact,\n      viewport = _ref.viewport,\n      draggables = _ref.draggables,\n      destination = _ref.destination,\n      forceShouldAnimate = _ref.forceShouldAnimate;\n  var last = impact.displaced;\n  var afterDragging = getDraggables$1(last.all, draggables);\n  var displaced = getDisplacementGroups({\n    afterDragging: afterDragging,\n    destination: destination,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    forceShouldAnimate: forceShouldAnimate,\n    last: last\n  });\n  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, impact, {\n    displaced: displaced\n  });\n});\n\nvar getClientBorderBoxCenter = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      droppable = _ref.droppable,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact: impact,\n    draggable: draggable,\n    draggables: draggables,\n    droppable: droppable,\n    afterCritical: afterCritical\n  });\n  return getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter: pageBorderBoxCenter,\n    draggable: draggable,\n    viewport: viewport\n  });\n});\n\nvar refreshSnap = (function (_ref) {\n  var state = _ref.state,\n      forcedDimensions = _ref.dimensions,\n      forcedViewport = _ref.viewport;\n  !(state.movementMode === 'SNAP') ?  true ? invariant(false) : 0 : void 0;\n  var needsVisibilityCheck = state.impact;\n  var viewport = forcedViewport || state.viewport;\n  var dimensions = forcedDimensions || state.dimensions;\n  var draggables = dimensions.draggables,\n      droppables = dimensions.droppables;\n  var draggable = draggables[state.critical.draggable.id];\n  var isOver = whatIsDraggedOver(needsVisibilityCheck);\n  !isOver ?  true ? invariant(false, 'Must be over a destination in SNAP movement mode') : 0 : void 0;\n  var destination = droppables[isOver];\n  var impact = recompute({\n    impact: needsVisibilityCheck,\n    viewport: viewport,\n    destination: destination,\n    draggables: draggables\n  });\n  var clientSelection = getClientBorderBoxCenter({\n    impact: impact,\n    draggable: draggable,\n    droppable: destination,\n    draggables: draggables,\n    viewport: viewport,\n    afterCritical: state.afterCritical\n  });\n  return update({\n    impact: impact,\n    clientSelection: clientSelection,\n    state: state,\n    dimensions: dimensions,\n    viewport: viewport\n  });\n});\n\nvar getHomeLocation = (function (descriptor) {\n  return {\n    index: descriptor.index,\n    droppableId: descriptor.droppableId\n  };\n});\n\nvar getLiftEffect = (function (_ref) {\n  var draggable = _ref.draggable,\n      home = _ref.home,\n      draggables = _ref.draggables,\n      viewport = _ref.viewport;\n  var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n  var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n  var rawIndex = insideHome.indexOf(draggable);\n  !(rawIndex !== -1) ?  true ? invariant(false, 'Expected draggable to be inside home list') : 0 : void 0;\n  var afterDragging = insideHome.slice(rawIndex + 1);\n  var effected = afterDragging.reduce(function (previous, item) {\n    previous[item.descriptor.id] = true;\n    return previous;\n  }, {});\n  var afterCritical = {\n    inVirtualList: home.descriptor.mode === 'virtual',\n    displacedBy: displacedBy,\n    effected: effected\n  };\n  var displaced = getDisplacementGroups({\n    afterDragging: afterDragging,\n    destination: home,\n    displacedBy: displacedBy,\n    last: null,\n    viewport: viewport.frame,\n    forceShouldAnimate: false\n  });\n  var impact = {\n    displaced: displaced,\n    displacedBy: displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: getHomeLocation(draggable.descriptor)\n    }\n  };\n  return {\n    impact: impact,\n    afterCritical: afterCritical\n  };\n});\n\nvar patchDimensionMap = (function (dimensions, updated) {\n  return {\n    draggables: dimensions.draggables,\n    droppables: patchDroppableMap(dimensions.droppables, updated)\n  };\n});\n\nvar start = function start(key) {\n  if (true) {\n    {\n      return;\n    }\n  }\n};\nvar finish = function finish(key) {\n  if (true) {\n    {\n      return;\n    }\n  }\n};\n\nvar offsetDraggable = (function (_ref) {\n  var draggable = _ref.draggable,\n      offset$1 = _ref.offset,\n      initialWindowScroll = _ref.initialWindowScroll;\n  var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(draggable.client, offset$1);\n  var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, initialWindowScroll);\n\n  var moved = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, draggable, {\n    placeholder: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, draggable.placeholder, {\n      client: client\n    }),\n    client: client,\n    page: page\n  });\n\n  return moved;\n});\n\nvar getFrame = (function (droppable) {\n  var frame = droppable.frame;\n  !frame ?  true ? invariant(false, 'Expected Droppable to have a frame') : 0 : void 0;\n  return frame;\n});\n\nvar adjustAdditionsForScrollChanges = (function (_ref) {\n  var additions = _ref.additions,\n      updatedDroppables = _ref.updatedDroppables,\n      viewport = _ref.viewport;\n  var windowScrollChange = viewport.scroll.diff.value;\n  return additions.map(function (draggable) {\n    var droppableId = draggable.descriptor.droppableId;\n    var modified = updatedDroppables[droppableId];\n    var frame = getFrame(modified);\n    var droppableScrollChange = frame.scroll.diff.value;\n    var totalChange = add(windowScrollChange, droppableScrollChange);\n    var moved = offsetDraggable({\n      draggable: draggable,\n      offset: totalChange,\n      initialWindowScroll: viewport.scroll.initial\n    });\n    return moved;\n  });\n});\n\nvar publishWhileDraggingInVirtual = (function (_ref) {\n  var state = _ref.state,\n      published = _ref.published;\n  start();\n  var withScrollChange = published.modified.map(function (update) {\n    var existing = state.dimensions.droppables[update.droppableId];\n    var scrolled = scrollDroppable(existing, update.scroll);\n    return scrolled;\n  });\n\n  var droppables = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));\n\n  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n    additions: published.additions,\n    updatedDroppables: droppables,\n    viewport: state.viewport\n  }));\n\n  var draggables = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, state.dimensions.draggables, {}, updatedAdditions);\n\n  published.removals.forEach(function (id) {\n    delete draggables[id];\n  });\n  var dimensions = {\n    droppables: droppables,\n    draggables: draggables\n  };\n  var wasOverId = whatIsDraggedOver(state.impact);\n  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n  var draggable = dimensions.draggables[state.critical.draggable.id];\n  var home = dimensions.droppables[state.critical.droppable.id];\n\n  var _getLiftEffect = getLiftEffect({\n    draggable: draggable,\n    home: home,\n    draggables: draggables,\n    viewport: state.viewport\n  }),\n      onLiftImpact = _getLiftEffect.impact,\n      afterCritical = _getLiftEffect.afterCritical;\n\n  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n  var impact = getDragImpact({\n    pageOffset: state.current.page.offset,\n    draggable: dimensions.draggables[state.critical.draggable.id],\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: previousImpact,\n    viewport: state.viewport,\n    afterCritical: afterCritical\n  });\n  finish();\n\n  var draggingState = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n    phase: 'DRAGGING'\n  }, state, {\n    phase: 'DRAGGING',\n    impact: impact,\n    onLiftImpact: onLiftImpact,\n    dimensions: dimensions,\n    afterCritical: afterCritical,\n    forceShouldAnimate: false\n  });\n\n  if (state.phase === 'COLLECTING') {\n    return draggingState;\n  }\n\n  var dropPending = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n    phase: 'DROP_PENDING'\n  }, draggingState, {\n    phase: 'DROP_PENDING',\n    reason: state.reason,\n    isWaiting: false\n  });\n\n  return dropPending;\n});\n\nvar isSnapping = function isSnapping(state) {\n  return state.movementMode === 'SNAP';\n};\n\nvar postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {\n  var dimensions = patchDimensionMap(state.dimensions, updated);\n\n  if (!isSnapping(state) || isEnabledChanging) {\n    return update({\n      state: state,\n      dimensions: dimensions\n    });\n  }\n\n  return refreshSnap({\n    state: state,\n    dimensions: dimensions\n  });\n};\n\nfunction removeScrollJumpRequest(state) {\n  if (state.isDragging && state.movementMode === 'SNAP') {\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n      phase: 'DRAGGING'\n    }, state, {\n      scrollJumpRequest: null\n    });\n  }\n\n  return state;\n}\n\nvar idle = {\n  phase: 'IDLE',\n  completed: null,\n  shouldFlush: false\n};\nvar reducer = (function (state, action) {\n  if (state === void 0) {\n    state = idle;\n  }\n\n  if (action.type === 'FLUSH') {\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, idle, {\n      shouldFlush: true\n    });\n  }\n\n  if (action.type === 'INITIAL_PUBLISH') {\n    !(state.phase === 'IDLE') ?  true ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : 0 : void 0;\n    var _action$payload = action.payload,\n        critical = _action$payload.critical,\n        clientSelection = _action$payload.clientSelection,\n        viewport = _action$payload.viewport,\n        dimensions = _action$payload.dimensions,\n        movementMode = _action$payload.movementMode;\n    var draggable = dimensions.draggables[critical.draggable.id];\n    var home = dimensions.droppables[critical.droppable.id];\n    var client = {\n      selection: clientSelection,\n      borderBoxCenter: draggable.client.borderBox.center,\n      offset: origin\n    };\n    var initial = {\n      client: client,\n      page: {\n        selection: add(client.selection, viewport.scroll.initial),\n        borderBoxCenter: add(client.selection, viewport.scroll.initial),\n        offset: add(client.selection, viewport.scroll.diff.value)\n      }\n    };\n    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function (item) {\n      return !item.isFixedOnPage;\n    });\n\n    var _getLiftEffect = getLiftEffect({\n      draggable: draggable,\n      home: home,\n      draggables: dimensions.draggables,\n      viewport: viewport\n    }),\n        impact = _getLiftEffect.impact,\n        afterCritical = _getLiftEffect.afterCritical;\n\n    var result = {\n      phase: 'DRAGGING',\n      isDragging: true,\n      critical: critical,\n      movementMode: movementMode,\n      dimensions: dimensions,\n      initial: initial,\n      current: initial,\n      isWindowScrollAllowed: isWindowScrollAllowed,\n      impact: impact,\n      afterCritical: afterCritical,\n      onLiftImpact: impact,\n      viewport: viewport,\n      scrollJumpRequest: null,\n      forceShouldAnimate: null\n    };\n    return result;\n  }\n\n  if (action.type === 'COLLECTION_STARTING') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ?  true ? invariant(false, \"Collection cannot start from phase \" + state.phase) : 0 : void 0;\n\n    var _result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n      phase: 'COLLECTING'\n    }, state, {\n      phase: 'COLLECTING'\n    });\n\n    return _result;\n  }\n\n  if (action.type === 'PUBLISH_WHILE_DRAGGING') {\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, \"Unexpected \" + action.type + \" received in phase \" + state.phase) : 0 : void 0;\n    return publishWhileDraggingInVirtual({\n      state: state,\n      published: action.payload\n    });\n  }\n\n  if (action.type === 'MOVE') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ?  true ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : 0 : void 0;\n    var _clientSelection = action.payload.client;\n\n    if (isEqual(_clientSelection, state.current.client.selection)) {\n      return state;\n    }\n\n    return update({\n      state: state,\n      clientSelection: _clientSelection,\n      impact: isSnapping(state) ? state.impact : null\n    });\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\n    if (state.phase === 'DROP_PENDING') {\n      return removeScrollJumpRequest(state);\n    }\n\n    if (state.phase === 'COLLECTING') {\n      return removeScrollJumpRequest(state);\n    }\n\n    !isMovementAllowed(state) ?  true ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : 0 : void 0;\n    var _action$payload2 = action.payload,\n        id = _action$payload2.id,\n        newScroll = _action$payload2.newScroll;\n    var target = state.dimensions.droppables[id];\n\n    if (!target) {\n      return state;\n    }\n\n    var scrolled = scrollDroppable(target, newScroll);\n    return postDroppableChange(state, scrolled, false);\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ?  true ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : 0 : void 0;\n    var _action$payload3 = action.payload,\n        _id = _action$payload3.id,\n        isEnabled = _action$payload3.isEnabled;\n    var _target = state.dimensions.droppables[_id];\n    !_target ?  true ? invariant(false, \"Cannot find Droppable[id: \" + _id + \"] to toggle its enabled state\") : 0 : void 0;\n    !(_target.isEnabled !== isEnabled) ?  true ? invariant(false, \"Trying to set droppable isEnabled to \" + String(isEnabled) + \"\\n      but it is already \" + String(_target.isEnabled)) : 0 : void 0;\n\n    var updated = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, _target, {\n      isEnabled: isEnabled\n    });\n\n    return postDroppableChange(state, updated, true);\n  }\n\n  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ?  true ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : 0 : void 0;\n    var _action$payload4 = action.payload,\n        _id2 = _action$payload4.id,\n        isCombineEnabled = _action$payload4.isCombineEnabled;\n    var _target2 = state.dimensions.droppables[_id2];\n    !_target2 ?  true ? invariant(false, \"Cannot find Droppable[id: \" + _id2 + \"] to toggle its isCombineEnabled state\") : 0 : void 0;\n    !(_target2.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, \"Trying to set droppable isCombineEnabled to \" + String(isCombineEnabled) + \"\\n      but it is already \" + String(_target2.isCombineEnabled)) : 0 : void 0;\n\n    var _updated = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, _target2, {\n      isCombineEnabled: isCombineEnabled\n    });\n\n    return postDroppableChange(state, _updated, true);\n  }\n\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\n      return state;\n    }\n\n    !isMovementAllowed(state) ?  true ? invariant(false, \"Cannot move by window in phase \" + state.phase) : 0 : void 0;\n    !state.isWindowScrollAllowed ?  true ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : 0 : void 0;\n    var _newScroll = action.payload.newScroll;\n\n    if (isEqual(state.viewport.scroll.current, _newScroll)) {\n      return removeScrollJumpRequest(state);\n    }\n\n    var _viewport = scrollViewport(state.viewport, _newScroll);\n\n    if (isSnapping(state)) {\n      return refreshSnap({\n        state: state,\n        viewport: _viewport\n      });\n    }\n\n    return update({\n      state: state,\n      viewport: _viewport\n    });\n  }\n\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\n    if (!isMovementAllowed(state)) {\n      return state;\n    }\n\n    var maxScroll = action.payload.maxScroll;\n\n    if (isEqual(maxScroll, state.viewport.scroll.max)) {\n      return state;\n    }\n\n    var withMaxScroll = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, state.viewport, {\n      scroll: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, state.viewport.scroll, {\n        max: maxScroll\n      })\n    });\n\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n      phase: 'DRAGGING'\n    }, state, {\n      viewport: withMaxScroll\n    });\n  }\n\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n\n    !(state.phase === 'DRAGGING') ?  true ? invariant(false, action.type + \" received while not in DRAGGING phase\") : 0 : void 0;\n\n    var _result2 = moveInDirection({\n      state: state,\n      type: action.type\n    });\n\n    if (!_result2) {\n      return state;\n    }\n\n    return update({\n      state: state,\n      impact: _result2.impact,\n      clientSelection: _result2.clientSelection,\n      scrollJumpRequest: _result2.scrollJumpRequest\n    });\n  }\n\n  if (action.type === 'DROP_PENDING') {\n    var reason = action.payload.reason;\n    !(state.phase === 'COLLECTING') ?  true ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : 0 : void 0;\n\n    var newState = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n      phase: 'DROP_PENDING'\n    }, state, {\n      phase: 'DROP_PENDING',\n      isWaiting: true,\n      reason: reason\n    });\n\n    return newState;\n  }\n\n  if (action.type === 'DROP_ANIMATE') {\n    var _action$payload5 = action.payload,\n        completed = _action$payload5.completed,\n        dropDuration = _action$payload5.dropDuration,\n        newHomeClientOffset = _action$payload5.newHomeClientOffset;\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, \"Cannot animate drop from phase \" + state.phase) : 0 : void 0;\n    var _result3 = {\n      phase: 'DROP_ANIMATING',\n      completed: completed,\n      dropDuration: dropDuration,\n      newHomeClientOffset: newHomeClientOffset,\n      dimensions: state.dimensions\n    };\n    return _result3;\n  }\n\n  if (action.type === 'DROP_COMPLETE') {\n    var _completed = action.payload.completed;\n    return {\n      phase: 'IDLE',\n      completed: _completed,\n      shouldFlush: false\n    };\n  }\n\n  return state;\n});\n\nvar beforeInitialCapture = function beforeInitialCapture(args) {\n  return {\n    type: 'BEFORE_INITIAL_CAPTURE',\n    payload: args\n  };\n};\nvar lift = function lift(args) {\n  return {\n    type: 'LIFT',\n    payload: args\n  };\n};\nvar initialPublish = function initialPublish(args) {\n  return {\n    type: 'INITIAL_PUBLISH',\n    payload: args\n  };\n};\nvar publishWhileDragging = function publishWhileDragging(args) {\n  return {\n    type: 'PUBLISH_WHILE_DRAGGING',\n    payload: args\n  };\n};\nvar collectionStarting = function collectionStarting() {\n  return {\n    type: 'COLLECTION_STARTING',\n    payload: null\n  };\n};\nvar updateDroppableScroll = function updateDroppableScroll(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_SCROLL',\n    payload: args\n  };\n};\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_ENABLED',\n    payload: args\n  };\n};\nvar updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {\n  return {\n    type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',\n    payload: args\n  };\n};\nvar move = function move(args) {\n  return {\n    type: 'MOVE',\n    payload: args\n  };\n};\nvar moveByWindowScroll = function moveByWindowScroll(args) {\n  return {\n    type: 'MOVE_BY_WINDOW_SCROLL',\n    payload: args\n  };\n};\nvar updateViewportMaxScroll = function updateViewportMaxScroll(args) {\n  return {\n    type: 'UPDATE_VIEWPORT_MAX_SCROLL',\n    payload: args\n  };\n};\nvar moveUp = function moveUp() {\n  return {\n    type: 'MOVE_UP',\n    payload: null\n  };\n};\nvar moveDown = function moveDown() {\n  return {\n    type: 'MOVE_DOWN',\n    payload: null\n  };\n};\nvar moveRight = function moveRight() {\n  return {\n    type: 'MOVE_RIGHT',\n    payload: null\n  };\n};\nvar moveLeft = function moveLeft() {\n  return {\n    type: 'MOVE_LEFT',\n    payload: null\n  };\n};\nvar flush = function flush() {\n  return {\n    type: 'FLUSH',\n    payload: null\n  };\n};\nvar animateDrop = function animateDrop(args) {\n  return {\n    type: 'DROP_ANIMATE',\n    payload: args\n  };\n};\nvar completeDrop = function completeDrop(args) {\n  return {\n    type: 'DROP_COMPLETE',\n    payload: args\n  };\n};\nvar drop = function drop(args) {\n  return {\n    type: 'DROP',\n    payload: args\n  };\n};\nvar dropPending = function dropPending(args) {\n  return {\n    type: 'DROP_PENDING',\n    payload: args\n  };\n};\nvar dropAnimationFinished = function dropAnimationFinished() {\n  return {\n    type: 'DROP_ANIMATION_FINISHED',\n    payload: null\n  };\n};\n\nfunction checkIndexes(insideDestination) {\n  if (insideDestination.length <= 1) {\n    return;\n  }\n\n  var indexes = insideDestination.map(function (d) {\n    return d.descriptor.index;\n  });\n  var errors = {};\n\n  for (var i = 1; i < indexes.length; i++) {\n    var current = indexes[i];\n    var previous = indexes[i - 1];\n\n    if (current !== previous + 1) {\n      errors[current] = true;\n    }\n  }\n\n  if (!Object.keys(errors).length) {\n    return;\n  }\n\n  var formatted = indexes.map(function (index) {\n    var hasError = Boolean(errors[index]);\n    return hasError ? \"[\\uD83D\\uDD25\" + index + \"]\" : \"\" + index;\n  }).join(', ');\n   true ? warning(\"\\n    Detected non-consecutive <Draggable /> indexes.\\n\\n    (This can cause unexpected bugs)\\n\\n    \" + formatted + \"\\n  \") : 0;\n}\n\nfunction validateDimensions(critical, dimensions) {\n  if (true) {\n    var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n    checkIndexes(insideDestination);\n  }\n}\n\nvar lift$1 = (function (marshal) {\n  return function (_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n    return function (next) {\n      return function (action) {\n        if (action.type !== 'LIFT') {\n          next(action);\n          return;\n        }\n\n        var _action$payload = action.payload,\n            id = _action$payload.id,\n            clientSelection = _action$payload.clientSelection,\n            movementMode = _action$payload.movementMode;\n        var initial = getState();\n\n        if (initial.phase === 'DROP_ANIMATING') {\n          dispatch(completeDrop({\n            completed: initial.completed\n          }));\n        }\n\n        !(getState().phase === 'IDLE') ?  true ? invariant(false, 'Unexpected phase to start a drag') : 0 : void 0;\n        dispatch(flush());\n        dispatch(beforeInitialCapture({\n          draggableId: id,\n          movementMode: movementMode\n        }));\n        var scrollOptions = {\n          shouldPublishImmediately: movementMode === 'SNAP'\n        };\n        var request = {\n          draggableId: id,\n          scrollOptions: scrollOptions\n        };\n\n        var _marshal$startPublish = marshal.startPublishing(request),\n            critical = _marshal$startPublish.critical,\n            dimensions = _marshal$startPublish.dimensions,\n            viewport = _marshal$startPublish.viewport;\n\n        validateDimensions(critical, dimensions);\n        dispatch(initialPublish({\n          critical: critical,\n          dimensions: dimensions,\n          clientSelection: clientSelection,\n          movementMode: movementMode,\n          viewport: viewport\n        }));\n      };\n    };\n  };\n});\n\nvar style = (function (marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          marshal.dragging();\n        }\n\n        if (action.type === 'DROP_ANIMATE') {\n          marshal.dropping(action.payload.completed.result.reason);\n        }\n\n        if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {\n          marshal.resting();\n        }\n\n        next(action);\n      };\n    };\n  };\n});\n\nvar curves = {\n  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',\n  drop: 'cubic-bezier(.2,1,.1,1)'\n};\nvar combine = {\n  opacity: {\n    drop: 0,\n    combining: 0.7\n  },\n  scale: {\n    drop: 0.75\n  }\n};\nvar timings = {\n  outOfTheWay: 0.2,\n  minDropTime: 0.33,\n  maxDropTime: 0.55\n};\nvar outOfTheWayTiming = timings.outOfTheWay + \"s \" + curves.outOfTheWay;\nvar transitions = {\n  fluid: \"opacity \" + outOfTheWayTiming,\n  snap: \"transform \" + outOfTheWayTiming + \", opacity \" + outOfTheWayTiming,\n  drop: function drop(duration) {\n    var timing = duration + \"s \" + curves.drop;\n    return \"transform \" + timing + \", opacity \" + timing;\n  },\n  outOfTheWay: \"transform \" + outOfTheWayTiming,\n  placeholder: \"height \" + outOfTheWayTiming + \", width \" + outOfTheWayTiming + \", margin \" + outOfTheWayTiming\n};\n\nvar moveTo = function moveTo(offset) {\n  return isEqual(offset, origin) ? null : \"translate(\" + offset.x + \"px, \" + offset.y + \"px)\";\n};\n\nvar transforms = {\n  moveTo: moveTo,\n  drop: function drop(offset, isCombining) {\n    var translate = moveTo(offset);\n\n    if (!translate) {\n      return null;\n    }\n\n    if (!isCombining) {\n      return translate;\n    }\n\n    return translate + \" scale(\" + combine.scale.drop + \")\";\n  }\n};\n\nvar minDropTime = timings.minDropTime,\n    maxDropTime = timings.maxDropTime;\nvar dropTimeRange = maxDropTime - minDropTime;\nvar maxDropTimeAtDistance = 1500;\nvar cancelDropModifier = 0.6;\nvar getDropDuration = (function (_ref) {\n  var current = _ref.current,\n      destination = _ref.destination,\n      reason = _ref.reason;\n  var distance$1 = distance(current, destination);\n\n  if (distance$1 <= 0) {\n    return minDropTime;\n  }\n\n  if (distance$1 >= maxDropTimeAtDistance) {\n    return maxDropTime;\n  }\n\n  var percentage = distance$1 / maxDropTimeAtDistance;\n  var duration = minDropTime + dropTimeRange * percentage;\n  var withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;\n  return Number(withDuration.toFixed(2));\n});\n\nvar getNewHomeClientOffset = (function (_ref) {\n  var impact = _ref.impact,\n      draggable = _ref.draggable,\n      dimensions = _ref.dimensions,\n      viewport = _ref.viewport,\n      afterCritical = _ref.afterCritical;\n  var draggables = dimensions.draggables,\n      droppables = dimensions.droppables;\n  var droppableId = whatIsDraggedOver(impact);\n  var destination = droppableId ? droppables[droppableId] : null;\n  var home = droppables[draggable.descriptor.droppableId];\n  var newClientCenter = getClientBorderBoxCenter({\n    impact: impact,\n    draggable: draggable,\n    draggables: draggables,\n    afterCritical: afterCritical,\n    droppable: destination || home,\n    viewport: viewport\n  });\n  var offset = subtract(newClientCenter, draggable.client.borderBox.center);\n  return offset;\n});\n\nvar getDropImpact = (function (_ref) {\n  var draggables = _ref.draggables,\n      reason = _ref.reason,\n      lastImpact = _ref.lastImpact,\n      home = _ref.home,\n      viewport = _ref.viewport,\n      onLiftImpact = _ref.onLiftImpact;\n\n  if (!lastImpact.at || reason !== 'DROP') {\n    var recomputedHomeImpact = recompute({\n      draggables: draggables,\n      impact: onLiftImpact,\n      destination: home,\n      viewport: viewport,\n      forceShouldAnimate: true\n    });\n    return {\n      impact: recomputedHomeImpact,\n      didDropInsideDroppable: false\n    };\n  }\n\n  if (lastImpact.at.type === 'REORDER') {\n    return {\n      impact: lastImpact,\n      didDropInsideDroppable: true\n    };\n  }\n\n  var withoutMovement = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, lastImpact, {\n    displaced: emptyGroups\n  });\n\n  return {\n    impact: withoutMovement,\n    didDropInsideDroppable: true\n  };\n});\n\nvar drop$1 = (function (_ref) {\n  var getState = _ref.getState,\n      dispatch = _ref.dispatch;\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP') {\n        next(action);\n        return;\n      }\n\n      var state = getState();\n      var reason = action.payload.reason;\n\n      if (state.phase === 'COLLECTING') {\n        dispatch(dropPending({\n          reason: reason\n        }));\n        return;\n      }\n\n      if (state.phase === 'IDLE') {\n        return;\n      }\n\n      var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\n      !!isWaitingForDrop ?  true ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : 0 : void 0;\n      !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, \"Cannot drop in phase: \" + state.phase) : 0 : void 0;\n      var critical = state.critical;\n      var dimensions = state.dimensions;\n      var draggable = dimensions.draggables[state.critical.draggable.id];\n\n      var _getDropImpact = getDropImpact({\n        reason: reason,\n        lastImpact: state.impact,\n        afterCritical: state.afterCritical,\n        onLiftImpact: state.onLiftImpact,\n        home: state.dimensions.droppables[state.critical.droppable.id],\n        viewport: state.viewport,\n        draggables: state.dimensions.draggables\n      }),\n          impact = _getDropImpact.impact,\n          didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;\n\n      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n      var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n      var source = {\n        index: critical.draggable.index,\n        droppableId: critical.droppable.id\n      };\n      var result = {\n        draggableId: draggable.descriptor.id,\n        type: draggable.descriptor.type,\n        source: source,\n        reason: reason,\n        mode: state.movementMode,\n        destination: destination,\n        combine: combine\n      };\n      var newHomeClientOffset = getNewHomeClientOffset({\n        impact: impact,\n        draggable: draggable,\n        dimensions: dimensions,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n      });\n      var completed = {\n        critical: state.critical,\n        afterCritical: state.afterCritical,\n        result: result,\n        impact: impact\n      };\n      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n\n      if (!isAnimationRequired) {\n        dispatch(completeDrop({\n          completed: completed\n        }));\n        return;\n      }\n\n      var dropDuration = getDropDuration({\n        current: state.current.client.offset,\n        destination: newHomeClientOffset,\n        reason: reason\n      });\n      var args = {\n        newHomeClientOffset: newHomeClientOffset,\n        dropDuration: dropDuration,\n        completed: completed\n      };\n      dispatch(animateDrop(args));\n    };\n  };\n});\n\nvar getWindowScroll = (function () {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  };\n});\n\nfunction getWindowScrollBinding(update) {\n  return {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: function fn(event) {\n      if (event.target !== window && event.target !== window.document) {\n        return;\n      }\n\n      update();\n    }\n  };\n}\n\nfunction getScrollListener(_ref) {\n  var onWindowScroll = _ref.onWindowScroll;\n\n  function updateScroll() {\n    onWindowScroll(getWindowScroll());\n  }\n\n  var scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__.default)(updateScroll);\n  var binding = getWindowScrollBinding(scheduled);\n  var unbind = noop;\n\n  function isActive() {\n    return unbind !== noop;\n  }\n\n  function start() {\n    !!isActive() ?  true ? invariant(false, 'Cannot start scroll listener when already active') : 0 : void 0;\n    unbind = bindEvents(window, [binding]);\n  }\n\n  function stop() {\n    !isActive() ?  true ? invariant(false, 'Cannot stop scroll listener when not active') : 0 : void 0;\n    scheduled.cancel();\n    unbind();\n    unbind = noop;\n  }\n\n  return {\n    start: start,\n    stop: stop,\n    isActive: isActive\n  };\n}\n\nvar shouldEnd = function shouldEnd(action) {\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\n};\n\nvar scrollListener = (function (store) {\n  var listener = getScrollListener({\n    onWindowScroll: function onWindowScroll(newScroll) {\n      store.dispatch(moveByWindowScroll({\n        newScroll: newScroll\n      }));\n    }\n  });\n  return function (next) {\n    return function (action) {\n      if (!listener.isActive() && action.type === 'INITIAL_PUBLISH') {\n        listener.start();\n      }\n\n      if (listener.isActive() && shouldEnd(action)) {\n        listener.stop();\n      }\n\n      next(action);\n    };\n  };\n});\n\nvar getExpiringAnnounce = (function (announce) {\n  var wasCalled = false;\n  var isExpired = false;\n  var timeoutId = setTimeout(function () {\n    isExpired = true;\n  });\n\n  var result = function result(message) {\n    if (wasCalled) {\n       true ? warning('Announcement already made. Not making a second announcement') : 0;\n      return;\n    }\n\n    if (isExpired) {\n       true ? warning(\"\\n        Announcements cannot be made asynchronously.\\n        Default message has already been announced.\\n      \") : 0;\n      return;\n    }\n\n    wasCalled = true;\n    announce(message);\n    clearTimeout(timeoutId);\n  };\n\n  result.wasCalled = function () {\n    return wasCalled;\n  };\n\n  return result;\n});\n\nvar getAsyncMarshal = (function () {\n  var entries = [];\n\n  var execute = function execute(timerId) {\n    var index = findIndex(entries, function (item) {\n      return item.timerId === timerId;\n    });\n    !(index !== -1) ?  true ? invariant(false, 'Could not find timer') : 0 : void 0;\n\n    var _entries$splice = entries.splice(index, 1),\n        entry = _entries$splice[0];\n\n    entry.callback();\n  };\n\n  var add = function add(fn) {\n    var timerId = setTimeout(function () {\n      return execute(timerId);\n    });\n    var entry = {\n      timerId: timerId,\n      callback: fn\n    };\n    entries.push(entry);\n  };\n\n  var flush = function flush() {\n    if (!entries.length) {\n      return;\n    }\n\n    var shallow = [].concat(entries);\n    entries.length = 0;\n    shallow.forEach(function (entry) {\n      clearTimeout(entry.timerId);\n      entry.callback();\n    });\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n});\n\nvar areLocationsEqual = function areLocationsEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.droppableId === second.droppableId && first.index === second.index;\n};\nvar isCombineEqual = function isCombineEqual(first, second) {\n  if (first == null && second == null) {\n    return true;\n  }\n\n  if (first == null || second == null) {\n    return false;\n  }\n\n  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nvar isCriticalEqual = function isCriticalEqual(first, second) {\n  if (first === second) {\n    return true;\n  }\n\n  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n  return isDraggableEqual && isDroppableEqual;\n};\n\nvar withTimings = function withTimings(key, fn) {\n  start();\n  fn();\n  finish();\n};\n\nvar getDragStart = function getDragStart(critical, mode) {\n  return {\n    draggableId: critical.draggable.id,\n    type: critical.droppable.type,\n    source: {\n      droppableId: critical.droppable.id,\n      index: critical.draggable.index\n    },\n    mode: mode\n  };\n};\n\nvar execute = function execute(responder, data, announce, getDefaultMessage) {\n  if (!responder) {\n    announce(getDefaultMessage(data));\n    return;\n  }\n\n  var willExpire = getExpiringAnnounce(announce);\n  var provided = {\n    announce: willExpire\n  };\n  responder(data, provided);\n\n  if (!willExpire.wasCalled()) {\n    announce(getDefaultMessage(data));\n  }\n};\n\nvar getPublisher = (function (getResponders, announce) {\n  var asyncMarshal = getAsyncMarshal();\n  var dragging = null;\n\n  var beforeCapture = function beforeCapture(draggableId, mode) {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeCapture as a drag start has already been published') : 0 : void 0;\n    withTimings('onBeforeCapture', function () {\n      var fn = getResponders().onBeforeCapture;\n\n      if (fn) {\n        var before = {\n          draggableId: draggableId,\n          mode: mode\n        };\n        fn(before);\n      }\n    });\n  };\n\n  var beforeStart = function beforeStart(critical, mode) {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : 0 : void 0;\n    withTimings('onBeforeDragStart', function () {\n      var fn = getResponders().onBeforeDragStart;\n\n      if (fn) {\n        fn(getDragStart(critical, mode));\n      }\n    });\n  };\n\n  var start = function start(critical, mode) {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : 0 : void 0;\n    var data = getDragStart(critical, mode);\n    dragging = {\n      mode: mode,\n      lastCritical: critical,\n      lastLocation: data.source,\n      lastCombine: null\n    };\n    asyncMarshal.add(function () {\n      withTimings('onDragStart', function () {\n        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);\n      });\n    });\n  };\n\n  var update = function update(critical, impact) {\n    var location = tryGetDestination(impact);\n    var combine = tryGetCombine(impact);\n    !dragging ?  true ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : 0 : void 0;\n    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n\n    if (hasCriticalChanged) {\n      dragging.lastCritical = critical;\n    }\n\n    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n\n    if (hasLocationChanged) {\n      dragging.lastLocation = location;\n    }\n\n    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n\n    if (hasGroupingChanged) {\n      dragging.lastCombine = combine;\n    }\n\n    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n      return;\n    }\n\n    var data = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, getDragStart(critical, dragging.mode), {\n      combine: combine,\n      destination: location\n    });\n\n    asyncMarshal.add(function () {\n      withTimings('onDragUpdate', function () {\n        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);\n      });\n    });\n  };\n\n  var flush = function flush() {\n    !dragging ?  true ? invariant(false, 'Can only flush responders while dragging') : 0 : void 0;\n    asyncMarshal.flush();\n  };\n\n  var drop = function drop(result) {\n    !dragging ?  true ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : 0 : void 0;\n    dragging = null;\n    withTimings('onDragEnd', function () {\n      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);\n    });\n  };\n\n  var abort = function abort() {\n    if (!dragging) {\n      return;\n    }\n\n    var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, getDragStart(dragging.lastCritical, dragging.mode), {\n      combine: null,\n      destination: null,\n      reason: 'CANCEL'\n    });\n\n    drop(result);\n  };\n\n  return {\n    beforeCapture: beforeCapture,\n    beforeStart: beforeStart,\n    start: start,\n    update: update,\n    flush: flush,\n    drop: drop,\n    abort: abort\n  };\n});\n\nvar responders = (function (getResponders, announce) {\n  var publisher = getPublisher(getResponders, announce);\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'BEFORE_INITIAL_CAPTURE') {\n          publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n          return;\n        }\n\n        if (action.type === 'INITIAL_PUBLISH') {\n          var critical = action.payload.critical;\n          publisher.beforeStart(critical, action.payload.movementMode);\n          next(action);\n          publisher.start(critical, action.payload.movementMode);\n          return;\n        }\n\n        if (action.type === 'DROP_COMPLETE') {\n          var result = action.payload.completed.result;\n          publisher.flush();\n          next(action);\n          publisher.drop(result);\n          return;\n        }\n\n        next(action);\n\n        if (action.type === 'FLUSH') {\n          publisher.abort();\n          return;\n        }\n\n        var state = store.getState();\n\n        if (state.phase === 'DRAGGING') {\n          publisher.update(state.critical, state.impact);\n        }\n      };\n    };\n  };\n});\n\nvar dropAnimationFinish = (function (store) {\n  return function (next) {\n    return function (action) {\n      if (action.type !== 'DROP_ANIMATION_FINISHED') {\n        next(action);\n        return;\n      }\n\n      var state = store.getState();\n      !(state.phase === 'DROP_ANIMATING') ?  true ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : 0 : void 0;\n      store.dispatch(completeDrop({\n        completed: state.completed\n      }));\n    };\n  };\n});\n\nvar dropAnimationFlushOnScroll = (function (store) {\n  var unbind = null;\n  var frameId = null;\n\n  function clear() {\n    if (frameId) {\n      cancelAnimationFrame(frameId);\n      frameId = null;\n    }\n\n    if (unbind) {\n      unbind();\n      unbind = null;\n    }\n  }\n\n  return function (next) {\n    return function (action) {\n      if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATION_FINISHED') {\n        clear();\n      }\n\n      next(action);\n\n      if (action.type !== 'DROP_ANIMATE') {\n        return;\n      }\n\n      var binding = {\n        eventName: 'scroll',\n        options: {\n          capture: true,\n          passive: false,\n          once: true\n        },\n        fn: function flushDropAnimation() {\n          var state = store.getState();\n\n          if (state.phase === 'DROP_ANIMATING') {\n            store.dispatch(dropAnimationFinished());\n          }\n        }\n      };\n      frameId = requestAnimationFrame(function () {\n        frameId = null;\n        unbind = bindEvents(window, [binding]);\n      });\n    };\n  };\n});\n\nvar dimensionMarshalStopper = (function (marshal) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {\n          marshal.stopPublishing();\n        }\n\n        next(action);\n      };\n    };\n  };\n});\n\nvar focus = (function (marshal) {\n  var isWatching = false;\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type === 'INITIAL_PUBLISH') {\n          isWatching = true;\n          marshal.tryRecordFocus(action.payload.critical.draggable.id);\n          next(action);\n          marshal.tryRestoreFocusRecorded();\n          return;\n        }\n\n        next(action);\n\n        if (!isWatching) {\n          return;\n        }\n\n        if (action.type === 'FLUSH') {\n          isWatching = false;\n          marshal.tryRestoreFocusRecorded();\n          return;\n        }\n\n        if (action.type === 'DROP_COMPLETE') {\n          isWatching = false;\n          var result = action.payload.completed.result;\n\n          if (result.combine) {\n            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n          }\n\n          marshal.tryRestoreFocusRecorded();\n        }\n      };\n    };\n  };\n});\n\nvar shouldStop = function shouldStop(action) {\n  return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';\n};\n\nvar autoScroll = (function (autoScroller) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (shouldStop(action)) {\n          autoScroller.stop();\n          next(action);\n          return;\n        }\n\n        if (action.type === 'INITIAL_PUBLISH') {\n          next(action);\n          var state = store.getState();\n          !(state.phase === 'DRAGGING') ?  true ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : 0 : void 0;\n          autoScroller.start(state);\n          return;\n        }\n\n        next(action);\n        autoScroller.scroll(store.getState());\n      };\n    };\n  };\n});\n\nvar pendingDrop = (function (store) {\n  return function (next) {\n    return function (action) {\n      next(action);\n\n      if (action.type !== 'PUBLISH_WHILE_DRAGGING') {\n        return;\n      }\n\n      var postActionState = store.getState();\n\n      if (postActionState.phase !== 'DROP_PENDING') {\n        return;\n      }\n\n      if (postActionState.isWaiting) {\n        return;\n      }\n\n      store.dispatch(drop({\n        reason: postActionState.reason\n      }));\n    };\n  };\n});\n\nvar composeEnhancers =  true && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : redux__WEBPACK_IMPORTED_MODULE_8__.compose;\nvar createStore = (function (_ref) {\n  var dimensionMarshal = _ref.dimensionMarshal,\n      focusMarshal = _ref.focusMarshal,\n      styleMarshal = _ref.styleMarshal,\n      getResponders = _ref.getResponders,\n      announce = _ref.announce,\n      autoScroller = _ref.autoScroller;\n  return (0,redux__WEBPACK_IMPORTED_MODULE_8__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_8__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\n});\n\nvar clean$1 = function clean() {\n  return {\n    additions: {},\n    removals: {},\n    modified: {}\n  };\n};\nfunction createPublisher(_ref) {\n  var registry = _ref.registry,\n      callbacks = _ref.callbacks;\n  var staging = clean$1();\n  var frameId = null;\n\n  var collect = function collect() {\n    if (frameId) {\n      return;\n    }\n\n    callbacks.collectionStarting();\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      start();\n      var _staging = staging,\n          additions = _staging.additions,\n          removals = _staging.removals,\n          modified = _staging.modified;\n      var added = Object.keys(additions).map(function (id) {\n        return registry.draggable.getById(id).getDimension(origin);\n      }).sort(function (a, b) {\n        return a.descriptor.index - b.descriptor.index;\n      });\n      var updated = Object.keys(modified).map(function (id) {\n        var entry = registry.droppable.getById(id);\n        var scroll = entry.callbacks.getScrollWhileDragging();\n        return {\n          droppableId: id,\n          scroll: scroll\n        };\n      });\n      var result = {\n        additions: added,\n        removals: Object.keys(removals),\n        modified: updated\n      };\n      staging = clean$1();\n      finish();\n      callbacks.publish(result);\n    });\n  };\n\n  var add = function add(entry) {\n    var id = entry.descriptor.id;\n    staging.additions[id] = entry;\n    staging.modified[entry.descriptor.droppableId] = true;\n\n    if (staging.removals[id]) {\n      delete staging.removals[id];\n    }\n\n    collect();\n  };\n\n  var remove = function remove(entry) {\n    var descriptor = entry.descriptor;\n    staging.removals[descriptor.id] = true;\n    staging.modified[descriptor.droppableId] = true;\n\n    if (staging.additions[descriptor.id]) {\n      delete staging.additions[descriptor.id];\n    }\n\n    collect();\n  };\n\n  var stop = function stop() {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n    staging = clean$1();\n  };\n\n  return {\n    add: add,\n    remove: remove,\n    stop: stop\n  };\n}\n\nvar getMaxScroll = (function (_ref) {\n  var scrollHeight = _ref.scrollHeight,\n      scrollWidth = _ref.scrollWidth,\n      height = _ref.height,\n      width = _ref.width;\n  var maxScroll = subtract({\n    x: scrollWidth,\n    y: scrollHeight\n  }, {\n    x: width,\n    y: height\n  });\n  var adjustedMaxScroll = {\n    x: Math.max(0, maxScroll.x),\n    y: Math.max(0, maxScroll.y)\n  };\n  return adjustedMaxScroll;\n});\n\nvar getDocumentElement = (function () {\n  var doc = document.documentElement;\n  !doc ?  true ? invariant(false, 'Cannot find document.documentElement') : 0 : void 0;\n  return doc;\n});\n\nvar getMaxWindowScroll = (function () {\n  var doc = getDocumentElement();\n  var maxScroll = getMaxScroll({\n    scrollHeight: doc.scrollHeight,\n    scrollWidth: doc.scrollWidth,\n    width: doc.clientWidth,\n    height: doc.clientHeight\n  });\n  return maxScroll;\n});\n\nvar getViewport = (function () {\n  var scroll = getWindowScroll();\n  var maxScroll = getMaxWindowScroll();\n  var top = scroll.y;\n  var left = scroll.x;\n  var doc = getDocumentElement();\n  var width = doc.clientWidth;\n  var height = doc.clientHeight;\n  var right = left + width;\n  var bottom = top + height;\n  var frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom\n  });\n  var viewport = {\n    frame: frame,\n    scroll: {\n      initial: scroll,\n      current: scroll,\n      max: maxScroll,\n      diff: {\n        value: origin,\n        displacement: origin\n      }\n    }\n  };\n  return viewport;\n});\n\nvar getInitialPublish = (function (_ref) {\n  var critical = _ref.critical,\n      scrollOptions = _ref.scrollOptions,\n      registry = _ref.registry;\n  start();\n  var viewport = getViewport();\n  var windowScroll = viewport.scroll.current;\n  var home = critical.droppable;\n  var droppables = registry.droppable.getAllByType(home.type).map(function (entry) {\n    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\n  });\n  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function (entry) {\n    return entry.getDimension(windowScroll);\n  });\n  var dimensions = {\n    draggables: toDraggableMap(draggables),\n    droppables: toDroppableMap(droppables)\n  };\n  finish();\n  var result = {\n    dimensions: dimensions,\n    critical: critical,\n    viewport: viewport\n  };\n  return result;\n});\n\nfunction shouldPublishUpdate(registry, dragging, entry) {\n  if (entry.descriptor.id === dragging.id) {\n    return false;\n  }\n\n  if (entry.descriptor.type !== dragging.type) {\n    return false;\n  }\n\n  var home = registry.droppable.getById(entry.descriptor.droppableId);\n\n  if (home.descriptor.mode !== 'virtual') {\n     true ? warning(\"\\n      You are attempting to add or remove a Draggable [id: \" + entry.descriptor.id + \"]\\n      while a drag is occurring. This is only supported for virtual lists.\\n\\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\\n    \") : 0;\n    return false;\n  }\n\n  return true;\n}\n\nvar createDimensionMarshal = (function (registry, callbacks) {\n  var collection = null;\n  var publisher = createPublisher({\n    callbacks: {\n      publish: callbacks.publishWhileDragging,\n      collectionStarting: callbacks.collectionStarting\n    },\n    registry: registry\n  });\n\n  var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\n    !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update is enabled flag of Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n\n    if (!collection) {\n      return;\n    }\n\n    callbacks.updateDroppableIsEnabled({\n      id: id,\n      isEnabled: isEnabled\n    });\n  };\n\n  var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {\n    if (!collection) {\n      return;\n    }\n\n    !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update isCombineEnabled flag of Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n    callbacks.updateDroppableIsCombineEnabled({\n      id: id,\n      isCombineEnabled: isCombineEnabled\n    });\n  };\n\n  var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\n    if (!collection) {\n      return;\n    }\n\n    !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update the scroll on Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n    callbacks.updateDroppableScroll({\n      id: id,\n      newScroll: newScroll\n    });\n  };\n\n  var scrollDroppable = function scrollDroppable(id, change) {\n    if (!collection) {\n      return;\n    }\n\n    registry.droppable.getById(id).callbacks.scroll(change);\n  };\n\n  var stopPublishing = function stopPublishing() {\n    if (!collection) {\n      return;\n    }\n\n    publisher.stop();\n    var home = collection.critical.droppable;\n    registry.droppable.getAllByType(home.type).forEach(function (entry) {\n      return entry.callbacks.dragStopped();\n    });\n    collection.unsubscribe();\n    collection = null;\n  };\n\n  var subscriber = function subscriber(event) {\n    !collection ?  true ? invariant(false, 'Should only be subscribed when a collection is occurring') : 0 : void 0;\n    var dragging = collection.critical.draggable;\n\n    if (event.type === 'ADDITION') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.add(event.value);\n      }\n    }\n\n    if (event.type === 'REMOVAL') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.remove(event.value);\n      }\n    }\n  };\n\n  var startPublishing = function startPublishing(request) {\n    !!collection ?  true ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : 0 : void 0;\n    var entry = registry.draggable.getById(request.draggableId);\n    var home = registry.droppable.getById(entry.descriptor.droppableId);\n    var critical = {\n      draggable: entry.descriptor,\n      droppable: home.descriptor\n    };\n    var unsubscribe = registry.subscribe(subscriber);\n    collection = {\n      critical: critical,\n      unsubscribe: unsubscribe\n    };\n    return getInitialPublish({\n      critical: critical,\n      registry: registry,\n      scrollOptions: request.scrollOptions\n    });\n  };\n\n  var marshal = {\n    updateDroppableIsEnabled: updateDroppableIsEnabled,\n    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n    scrollDroppable: scrollDroppable,\n    updateDroppableScroll: updateDroppableScroll,\n    startPublishing: startPublishing,\n    stopPublishing: stopPublishing\n  };\n  return marshal;\n});\n\nvar canStartDrag = (function (state, id) {\n  if (state.phase === 'IDLE') {\n    return true;\n  }\n\n  if (state.phase !== 'DROP_ANIMATING') {\n    return false;\n  }\n\n  if (state.completed.result.draggableId === id) {\n    return false;\n  }\n\n  return state.completed.result.reason === 'DROP';\n});\n\nvar scrollWindow = (function (change) {\n  window.scrollBy(change.x, change.y);\n});\n\nvar getScrollableDroppables = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (droppables) {\n  return toDroppableList(droppables).filter(function (droppable) {\n    if (!droppable.isEnabled) {\n      return false;\n    }\n\n    if (!droppable.frame) {\n      return false;\n    }\n\n    return true;\n  });\n});\n\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\n  var maybe = find(getScrollableDroppables(droppables), function (droppable) {\n    !droppable.frame ?  true ? invariant(false, 'Invalid result') : 0 : void 0;\n    return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n  });\n  return maybe;\n};\n\nvar getBestScrollableDroppable = (function (_ref) {\n  var center = _ref.center,\n      destination = _ref.destination,\n      droppables = _ref.droppables;\n\n  if (destination) {\n    var _dimension = droppables[destination];\n\n    if (!_dimension.frame) {\n      return null;\n    }\n\n    return _dimension;\n  }\n\n  var dimension = getScrollableDroppableOver(center, droppables);\n  return dimension;\n});\n\nvar config = {\n  startFromPercentage: 0.25,\n  maxScrollAtPercentage: 0.05,\n  maxPixelScroll: 28,\n  ease: function ease(percentage) {\n    return Math.pow(percentage, 2);\n  },\n  durationDampening: {\n    stopDampeningAt: 1200,\n    accelerateAt: 360\n  }\n};\n\nvar getDistanceThresholds = (function (container, axis) {\n  var startScrollingFrom = container[axis.size] * config.startFromPercentage;\n  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;\n  var thresholds = {\n    startScrollingFrom: startScrollingFrom,\n    maxScrollValueAt: maxScrollValueAt\n  };\n  return thresholds;\n});\n\nvar getPercentage = (function (_ref) {\n  var startOfRange = _ref.startOfRange,\n      endOfRange = _ref.endOfRange,\n      current = _ref.current;\n  var range = endOfRange - startOfRange;\n\n  if (range === 0) {\n     true ? warning(\"\\n      Detected distance range of 0 in the fluid auto scroller\\n      This is unexpected and would cause a divide by 0 issue.\\n      Not allowing an auto scroll\\n    \") : 0;\n    return 0;\n  }\n\n  var currentInRange = current - startOfRange;\n  var percentage = currentInRange / range;\n  return percentage;\n});\n\nvar minScroll = 1;\n\nvar getValueFromDistance = (function (distanceToEdge, thresholds) {\n  if (distanceToEdge > thresholds.startScrollingFrom) {\n    return 0;\n  }\n\n  if (distanceToEdge <= thresholds.maxScrollValueAt) {\n    return config.maxPixelScroll;\n  }\n\n  if (distanceToEdge === thresholds.startScrollingFrom) {\n    return minScroll;\n  }\n\n  var percentageFromMaxScrollValueAt = getPercentage({\n    startOfRange: thresholds.maxScrollValueAt,\n    endOfRange: thresholds.startScrollingFrom,\n    current: distanceToEdge\n  });\n  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n  var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);\n  return Math.ceil(scroll);\n});\n\nvar accelerateAt = config.durationDampening.accelerateAt;\nvar stopAt = config.durationDampening.stopDampeningAt;\nvar dampenValueByTime = (function (proposedScroll, dragStartTime) {\n  var startOfRange = dragStartTime;\n  var endOfRange = stopAt;\n  var now = Date.now();\n  var runTime = now - startOfRange;\n\n  if (runTime >= stopAt) {\n    return proposedScroll;\n  }\n\n  if (runTime < accelerateAt) {\n    return minScroll;\n  }\n\n  var betweenAccelerateAtAndStopAtPercentage = getPercentage({\n    startOfRange: accelerateAt,\n    endOfRange: endOfRange,\n    current: runTime\n  });\n  var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);\n  return Math.ceil(scroll);\n});\n\nvar getValue = (function (_ref) {\n  var distanceToEdge = _ref.distanceToEdge,\n      thresholds = _ref.thresholds,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var scroll = getValueFromDistance(distanceToEdge, thresholds);\n\n  if (scroll === 0) {\n    return 0;\n  }\n\n  if (!shouldUseTimeDampening) {\n    return scroll;\n  }\n\n  return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);\n});\n\nvar getScrollOnAxis = (function (_ref) {\n  var container = _ref.container,\n      distanceToEdges = _ref.distanceToEdges,\n      dragStartTime = _ref.dragStartTime,\n      axis = _ref.axis,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var thresholds = getDistanceThresholds(container, axis);\n  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n\n  if (isCloserToEnd) {\n    return getValue({\n      distanceToEdge: distanceToEdges[axis.end],\n      thresholds: thresholds,\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n  }\n\n  return -1 * getValue({\n    distanceToEdge: distanceToEdges[axis.start],\n    thresholds: thresholds,\n    dragStartTime: dragStartTime,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n});\n\nvar adjustForSizeLimits = (function (_ref) {\n  var container = _ref.container,\n      subject = _ref.subject,\n      proposedScroll = _ref.proposedScroll;\n  var isTooBigVertically = subject.height > container.height;\n  var isTooBigHorizontally = subject.width > container.width;\n\n  if (!isTooBigHorizontally && !isTooBigVertically) {\n    return proposedScroll;\n  }\n\n  if (isTooBigHorizontally && isTooBigVertically) {\n    return null;\n  }\n\n  return {\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\n    y: isTooBigVertically ? 0 : proposedScroll.y\n  };\n});\n\nvar clean$2 = apply(function (value) {\n  return value === 0 ? 0 : value;\n});\nvar getScroll = (function (_ref) {\n  var dragStartTime = _ref.dragStartTime,\n      container = _ref.container,\n      subject = _ref.subject,\n      center = _ref.center,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var distanceToEdges = {\n    top: center.y - container.top,\n    right: container.right - center.x,\n    bottom: container.bottom - center.y,\n    left: center.x - container.left\n  };\n  var y = getScrollOnAxis({\n    container: container,\n    distanceToEdges: distanceToEdges,\n    dragStartTime: dragStartTime,\n    axis: vertical,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  var x = getScrollOnAxis({\n    container: container,\n    distanceToEdges: distanceToEdges,\n    dragStartTime: dragStartTime,\n    axis: horizontal,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  var required = clean$2({\n    x: x,\n    y: y\n  });\n\n  if (isEqual(required, origin)) {\n    return null;\n  }\n\n  var limited = adjustForSizeLimits({\n    container: container,\n    subject: subject,\n    proposedScroll: required\n  });\n\n  if (!limited) {\n    return null;\n  }\n\n  return isEqual(limited, origin) ? null : limited;\n});\n\nvar smallestSigned = apply(function (value) {\n  if (value === 0) {\n    return 0;\n  }\n\n  return value > 0 ? 1 : -1;\n});\nvar getOverlap = function () {\n  var getRemainder = function getRemainder(target, max) {\n    if (target < 0) {\n      return target;\n    }\n\n    if (target > max) {\n      return target - max;\n    }\n\n    return 0;\n  };\n\n  return function (_ref) {\n    var current = _ref.current,\n        max = _ref.max,\n        change = _ref.change;\n    var targetScroll = add(current, change);\n    var overlap = {\n      x: getRemainder(targetScroll.x, max.x),\n      y: getRemainder(targetScroll.y, max.y)\n    };\n\n    if (isEqual(overlap, origin)) {\n      return null;\n    }\n\n    return overlap;\n  };\n}();\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\n  var rawMax = _ref2.max,\n      current = _ref2.current,\n      change = _ref2.change;\n  var max = {\n    x: Math.max(current.x, rawMax.x),\n    y: Math.max(current.y, rawMax.y)\n  };\n  var smallestChange = smallestSigned(change);\n  var overlap = getOverlap({\n    max: max,\n    current: current,\n    change: smallestChange\n  });\n\n  if (!overlap) {\n    return true;\n  }\n\n  if (smallestChange.x !== 0 && overlap.x === 0) {\n    return true;\n  }\n\n  if (smallestChange.y !== 0 && overlap.y === 0) {\n    return true;\n  }\n\n  return false;\n};\nvar canScrollWindow = function canScrollWindow(viewport, change) {\n  return canPartiallyScroll({\n    current: viewport.scroll.current,\n    max: viewport.scroll.max,\n    change: change\n  });\n};\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\n  if (!canScrollWindow(viewport, change)) {\n    return null;\n  }\n\n  var max = viewport.scroll.max;\n  var current = viewport.scroll.current;\n  return getOverlap({\n    current: current,\n    max: max,\n    change: change\n  });\n};\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return false;\n  }\n\n  return canPartiallyScroll({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change: change\n  });\n};\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return null;\n  }\n\n  if (!canScrollDroppable(droppable, change)) {\n    return null;\n  }\n\n  return getOverlap({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change: change\n  });\n};\n\nvar getWindowScrollChange = (function (_ref) {\n  var viewport = _ref.viewport,\n      subject = _ref.subject,\n      center = _ref.center,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var scroll = getScroll({\n    dragStartTime: dragStartTime,\n    container: viewport.frame,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n});\n\nvar getDroppableScrollChange = (function (_ref) {\n  var droppable = _ref.droppable,\n      subject = _ref.subject,\n      center = _ref.center,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n  var frame = droppable.frame;\n\n  if (!frame) {\n    return null;\n  }\n\n  var scroll = getScroll({\n    dragStartTime: dragStartTime,\n    container: frame.pageMarginBox,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n});\n\nvar scroll$1 = (function (_ref) {\n  var state = _ref.state,\n      dragStartTime = _ref.dragStartTime,\n      shouldUseTimeDampening = _ref.shouldUseTimeDampening,\n      scrollWindow = _ref.scrollWindow,\n      scrollDroppable = _ref.scrollDroppable;\n  var center = state.current.page.borderBoxCenter;\n  var draggable = state.dimensions.draggables[state.critical.draggable.id];\n  var subject = draggable.page.marginBox;\n\n  if (state.isWindowScrollAllowed) {\n    var viewport = state.viewport;\n\n    var _change = getWindowScrollChange({\n      dragStartTime: dragStartTime,\n      viewport: viewport,\n      subject: subject,\n      center: center,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n\n    if (_change) {\n      scrollWindow(_change);\n      return;\n    }\n  }\n\n  var droppable = getBestScrollableDroppable({\n    center: center,\n    destination: whatIsDraggedOver(state.impact),\n    droppables: state.dimensions.droppables\n  });\n\n  if (!droppable) {\n    return;\n  }\n\n  var change = getDroppableScrollChange({\n    dragStartTime: dragStartTime,\n    droppable: droppable,\n    subject: subject,\n    center: center,\n    shouldUseTimeDampening: shouldUseTimeDampening\n  });\n\n  if (change) {\n    scrollDroppable(droppable.descriptor.id, change);\n  }\n});\n\nvar createFluidScroller = (function (_ref) {\n  var scrollWindow = _ref.scrollWindow,\n      scrollDroppable = _ref.scrollDroppable;\n  var scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__.default)(scrollWindow);\n  var scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__.default)(scrollDroppable);\n  var dragging = null;\n\n  var tryScroll = function tryScroll(state) {\n    !dragging ?  true ? invariant(false, 'Cannot fluid scroll if not dragging') : 0 : void 0;\n    var _dragging = dragging,\n        shouldUseTimeDampening = _dragging.shouldUseTimeDampening,\n        dragStartTime = _dragging.dragStartTime;\n    scroll$1({\n      state: state,\n      scrollWindow: scheduleWindowScroll,\n      scrollDroppable: scheduleDroppableScroll,\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: shouldUseTimeDampening\n    });\n  };\n\n  var start$1 = function start$1(state) {\n    start();\n    !!dragging ?  true ? invariant(false, 'Cannot start auto scrolling when already started') : 0 : void 0;\n    var dragStartTime = Date.now();\n    var wasScrollNeeded = false;\n\n    var fakeScrollCallback = function fakeScrollCallback() {\n      wasScrollNeeded = true;\n    };\n\n    scroll$1({\n      state: state,\n      dragStartTime: 0,\n      shouldUseTimeDampening: false,\n      scrollWindow: fakeScrollCallback,\n      scrollDroppable: fakeScrollCallback\n    });\n    dragging = {\n      dragStartTime: dragStartTime,\n      shouldUseTimeDampening: wasScrollNeeded\n    };\n    finish();\n\n    if (wasScrollNeeded) {\n      tryScroll(state);\n    }\n  };\n\n  var stop = function stop() {\n    if (!dragging) {\n      return;\n    }\n\n    scheduleWindowScroll.cancel();\n    scheduleDroppableScroll.cancel();\n    dragging = null;\n  };\n\n  return {\n    start: start$1,\n    stop: stop,\n    scroll: tryScroll\n  };\n});\n\nvar createJumpScroller = (function (_ref) {\n  var move = _ref.move,\n      scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow;\n\n  var moveByOffset = function moveByOffset(state, offset) {\n    var client = add(state.current.client.selection, offset);\n    move({\n      client: client\n    });\n  };\n\n  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\n    if (!canScrollDroppable(droppable, change)) {\n      return change;\n    }\n\n    var overlap = getDroppableOverlap(droppable, change);\n\n    if (!overlap) {\n      scrollDroppable(droppable.descriptor.id, change);\n      return null;\n    }\n\n    var whatTheDroppableCanScroll = subtract(change, overlap);\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n    var remainder = subtract(change, whatTheDroppableCanScroll);\n    return remainder;\n  };\n\n  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {\n    if (!isWindowScrollAllowed) {\n      return change;\n    }\n\n    if (!canScrollWindow(viewport, change)) {\n      return change;\n    }\n\n    var overlap = getWindowOverlap(viewport, change);\n\n    if (!overlap) {\n      scrollWindow(change);\n      return null;\n    }\n\n    var whatTheWindowCanScroll = subtract(change, overlap);\n    scrollWindow(whatTheWindowCanScroll);\n    var remainder = subtract(change, whatTheWindowCanScroll);\n    return remainder;\n  };\n\n  var jumpScroller = function jumpScroller(state) {\n    var request = state.scrollJumpRequest;\n\n    if (!request) {\n      return;\n    }\n\n    var destination = whatIsDraggedOver(state.impact);\n    !destination ?  true ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : 0 : void 0;\n    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n\n    if (!droppableRemainder) {\n      return;\n    }\n\n    var viewport = state.viewport;\n    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n\n    if (!windowRemainder) {\n      return;\n    }\n\n    moveByOffset(state, windowRemainder);\n  };\n\n  return jumpScroller;\n});\n\nvar createAutoScroller = (function (_ref) {\n  var scrollDroppable = _ref.scrollDroppable,\n      scrollWindow = _ref.scrollWindow,\n      move = _ref.move;\n  var fluidScroller = createFluidScroller({\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n  var jumpScroll = createJumpScroller({\n    move: move,\n    scrollWindow: scrollWindow,\n    scrollDroppable: scrollDroppable\n  });\n\n  var scroll = function scroll(state) {\n    if (state.phase !== 'DRAGGING') {\n      return;\n    }\n\n    if (state.movementMode === 'FLUID') {\n      fluidScroller.scroll(state);\n      return;\n    }\n\n    if (!state.scrollJumpRequest) {\n      return;\n    }\n\n    jumpScroll(state);\n  };\n\n  var scroller = {\n    scroll: scroll,\n    start: fluidScroller.start,\n    stop: fluidScroller.stop\n  };\n  return scroller;\n});\n\nvar prefix$1 = 'data-rbd';\nvar dragHandle = function () {\n  var base = prefix$1 + \"-drag-handle\";\n  return {\n    base: base,\n    draggableId: base + \"-draggable-id\",\n    contextId: base + \"-context-id\"\n  };\n}();\nvar draggable = function () {\n  var base = prefix$1 + \"-draggable\";\n  return {\n    base: base,\n    contextId: base + \"-context-id\",\n    id: base + \"-id\"\n  };\n}();\nvar droppable = function () {\n  var base = prefix$1 + \"-droppable\";\n  return {\n    base: base,\n    contextId: base + \"-context-id\",\n    id: base + \"-id\"\n  };\n}();\nvar scrollContainer = {\n  contextId: prefix$1 + \"-scroll-container-context-id\"\n};\n\nvar makeGetSelector = function makeGetSelector(context) {\n  return function (attribute) {\n    return \"[\" + attribute + \"=\\\"\" + context + \"\\\"]\";\n  };\n};\n\nvar getStyles = function getStyles(rules, property) {\n  return rules.map(function (rule) {\n    var value = rule.styles[property];\n\n    if (!value) {\n      return '';\n    }\n\n    return rule.selector + \" { \" + value + \" }\";\n  }).join(' ');\n};\n\nvar noPointerEvents = 'pointer-events: none;';\nvar getStyles$1 = (function (contextId) {\n  var getSelector = makeGetSelector(contextId);\n\n  var dragHandle$1 = function () {\n    var grabCursor = \"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \";\n    return {\n      selector: getSelector(dragHandle.contextId),\n      styles: {\n        always: \"\\n          -webkit-touch-callout: none;\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\n          touch-action: manipulation;\\n        \",\n        resting: grabCursor,\n        dragging: noPointerEvents,\n        dropAnimating: grabCursor\n      }\n    };\n  }();\n\n  var draggable$1 = function () {\n    var transition = \"\\n      transition: \" + transitions.outOfTheWay + \";\\n    \";\n    return {\n      selector: getSelector(draggable.contextId),\n      styles: {\n        dragging: transition,\n        dropAnimating: transition,\n        userCancel: transition\n      }\n    };\n  }();\n\n  var droppable$1 = {\n    selector: getSelector(droppable.contextId),\n    styles: {\n      always: \"overflow-anchor: none;\"\n    }\n  };\n  var body = {\n    selector: 'body',\n    styles: {\n      dragging: \"\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        overflow-anchor: none;\\n      \"\n    }\n  };\n  var rules = [draggable$1, dragHandle$1, droppable$1, body];\n  return {\n    always: getStyles(rules, 'always'),\n    resting: getStyles(rules, 'resting'),\n    dragging: getStyles(rules, 'dragging'),\n    dropAnimating: getStyles(rules, 'dropAnimating'),\n    userCancel: getStyles(rules, 'userCancel')\n  };\n});\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\nvar getHead = function getHead() {\n  var head = document.querySelector('head');\n  !head ?  true ? invariant(false, 'Cannot find the head to append a style to') : 0 : void 0;\n  return head;\n};\n\nvar createStyleEl = function createStyleEl(nonce) {\n  var el = document.createElement('style');\n\n  if (nonce) {\n    el.setAttribute('nonce', nonce);\n  }\n\n  el.type = 'text/css';\n  return el;\n};\n\nfunction useStyleMarshal(contextId, nonce) {\n  var styles = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return getStyles$1(contextId);\n  }, [contextId]);\n  var alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var setDynamicStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)((0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (proposed) {\n    var el = dynamicRef.current;\n    !el ?  true ? invariant(false, 'Cannot set dynamic style element if it is not set') : 0 : void 0;\n    el.textContent = proposed;\n  }), []);\n  var setAlwaysStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (proposed) {\n    var el = alwaysRef.current;\n    !el ?  true ? invariant(false, 'Cannot set dynamic style element if it is not set') : 0 : void 0;\n    el.textContent = proposed;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, 'style elements already mounted') : 0 : void 0;\n    var always = createStyleEl(nonce);\n    var dynamic = createStyleEl(nonce);\n    alwaysRef.current = always;\n    dynamicRef.current = dynamic;\n    always.setAttribute(prefix$1 + \"-always\", contextId);\n    dynamic.setAttribute(prefix$1 + \"-dynamic\", contextId);\n    getHead().appendChild(always);\n    getHead().appendChild(dynamic);\n    setAlwaysStyle(styles.always);\n    setDynamicStyle(styles.resting);\n    return function () {\n      var remove = function remove(ref) {\n        var current = ref.current;\n        !current ?  true ? invariant(false, 'Cannot unmount ref as it is not set') : 0 : void 0;\n        getHead().removeChild(current);\n        ref.current = null;\n      };\n\n      remove(alwaysRef);\n      remove(dynamicRef);\n    };\n  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);\n  var dragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    return setDynamicStyle(styles.dragging);\n  }, [setDynamicStyle, styles.dragging]);\n  var dropping = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (reason) {\n    if (reason === 'DROP') {\n      setDynamicStyle(styles.dropAnimating);\n      return;\n    }\n\n    setDynamicStyle(styles.userCancel);\n  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);\n  var resting = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    if (!dynamicRef.current) {\n      return;\n    }\n\n    setDynamicStyle(styles.resting);\n  }, [setDynamicStyle, styles.resting]);\n  var marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      dragging: dragging,\n      dropping: dropping,\n      resting: resting\n    };\n  }, [dragging, dropping, resting]);\n  return marshal;\n}\n\nvar getWindowFromEl = (function (el) {\n  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;\n});\n\nfunction isHtmlElement(el) {\n  return el instanceof getWindowFromEl(el).HTMLElement;\n}\n\nfunction findDragHandle(contextId, draggableId) {\n  var selector = \"[\" + dragHandle.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n  var possible = toArray(document.querySelectorAll(selector));\n\n  if (!possible.length) {\n     true ? warning(\"Unable to find any drag handles in the context \\\"\" + contextId + \"\\\"\") : 0;\n    return null;\n  }\n\n  var handle = find(possible, function (el) {\n    return el.getAttribute(dragHandle.draggableId) === draggableId;\n  });\n\n  if (!handle) {\n     true ? warning(\"Unable to find drag handle with id \\\"\" + draggableId + \"\\\" as no handle with a matching id was found\") : 0;\n    return null;\n  }\n\n  if (!isHtmlElement(handle)) {\n     true ? warning('drag handle needs to be a HTMLElement') : 0;\n    return null;\n  }\n\n  return handle;\n}\n\nfunction useFocusMarshal(contextId) {\n  var entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  var recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var register = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function register(id, focus) {\n    var entry = {\n      id: id,\n      focus: focus\n    };\n    entriesRef.current[id] = entry;\n    return function unregister() {\n      var entries = entriesRef.current;\n      var current = entries[id];\n\n      if (current !== entry) {\n        delete entries[id];\n      }\n    };\n  }, []);\n  var tryGiveFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryGiveFocus(tryGiveFocusTo) {\n    var handle = findDragHandle(contextId, tryGiveFocusTo);\n\n    if (handle && handle !== document.activeElement) {\n      handle.focus();\n    }\n  }, [contextId]);\n  var tryShiftRecord = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryShiftRecord(previous, redirectTo) {\n    if (recordRef.current === previous) {\n      recordRef.current = redirectTo;\n    }\n  }, []);\n  var tryRestoreFocusRecorded = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryRestoreFocusRecorded() {\n    if (restoreFocusFrameRef.current) {\n      return;\n    }\n\n    if (!isMountedRef.current) {\n      return;\n    }\n\n    restoreFocusFrameRef.current = requestAnimationFrame(function () {\n      restoreFocusFrameRef.current = null;\n      var record = recordRef.current;\n\n      if (record) {\n        tryGiveFocus(record);\n      }\n    });\n  }, [tryGiveFocus]);\n  var tryRecordFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryRecordFocus(id) {\n    recordRef.current = null;\n    var focused = document.activeElement;\n\n    if (!focused) {\n      return;\n    }\n\n    if (focused.getAttribute(dragHandle.draggableId) !== id) {\n      return;\n    }\n\n    recordRef.current = id;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    isMountedRef.current = true;\n    return function clearFrameOnUnmount() {\n      isMountedRef.current = false;\n      var frameId = restoreFocusFrameRef.current;\n\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }, []);\n  var marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      register: register,\n      tryRecordFocus: tryRecordFocus,\n      tryRestoreFocusRecorded: tryRestoreFocusRecorded,\n      tryShiftRecord: tryShiftRecord\n    };\n  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);\n  return marshal;\n}\n\nfunction createRegistry() {\n  var entries = {\n    draggables: {},\n    droppables: {}\n  };\n  var subscribers = [];\n\n  function subscribe(cb) {\n    subscribers.push(cb);\n    return function unsubscribe() {\n      var index = subscribers.indexOf(cb);\n\n      if (index === -1) {\n        return;\n      }\n\n      subscribers.splice(index, 1);\n    };\n  }\n\n  function notify(event) {\n    if (subscribers.length) {\n      subscribers.forEach(function (cb) {\n        return cb(event);\n      });\n    }\n  }\n\n  function findDraggableById(id) {\n    return entries.draggables[id] || null;\n  }\n\n  function getDraggableById(id) {\n    var entry = findDraggableById(id);\n    !entry ?  true ? invariant(false, \"Cannot find draggable entry with id [\" + id + \"]\") : 0 : void 0;\n    return entry;\n  }\n\n  var draggableAPI = {\n    register: function register(entry) {\n      entries.draggables[entry.descriptor.id] = entry;\n      notify({\n        type: 'ADDITION',\n        value: entry\n      });\n    },\n    update: function update(entry, last) {\n      var current = entries.draggables[last.descriptor.id];\n\n      if (!current) {\n        return;\n      }\n\n      if (current.uniqueId !== entry.uniqueId) {\n        return;\n      }\n\n      delete entries.draggables[last.descriptor.id];\n      entries.draggables[entry.descriptor.id] = entry;\n    },\n    unregister: function unregister(entry) {\n      var draggableId = entry.descriptor.id;\n      var current = findDraggableById(draggableId);\n\n      if (!current) {\n        return;\n      }\n\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n\n      delete entries.draggables[draggableId];\n      notify({\n        type: 'REMOVAL',\n        value: entry\n      });\n    },\n    getById: getDraggableById,\n    findById: findDraggableById,\n    exists: function exists(id) {\n      return Boolean(findDraggableById(id));\n    },\n    getAllByType: function getAllByType(type) {\n      return values(entries.draggables).filter(function (entry) {\n        return entry.descriptor.type === type;\n      });\n    }\n  };\n\n  function findDroppableById(id) {\n    return entries.droppables[id] || null;\n  }\n\n  function getDroppableById(id) {\n    var entry = findDroppableById(id);\n    !entry ?  true ? invariant(false, \"Cannot find droppable entry with id [\" + id + \"]\") : 0 : void 0;\n    return entry;\n  }\n\n  var droppableAPI = {\n    register: function register(entry) {\n      entries.droppables[entry.descriptor.id] = entry;\n    },\n    unregister: function unregister(entry) {\n      var current = findDroppableById(entry.descriptor.id);\n\n      if (!current) {\n        return;\n      }\n\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n\n      delete entries.droppables[entry.descriptor.id];\n    },\n    getById: getDroppableById,\n    findById: findDroppableById,\n    exists: function exists(id) {\n      return Boolean(findDroppableById(id));\n    },\n    getAllByType: function getAllByType(type) {\n      return values(entries.droppables).filter(function (entry) {\n        return entry.descriptor.type === type;\n      });\n    }\n  };\n\n  function clean() {\n    entries.draggables = {};\n    entries.droppables = {};\n    subscribers.length = 0;\n  }\n\n  return {\n    draggable: draggableAPI,\n    droppable: droppableAPI,\n    subscribe: subscribe,\n    clean: clean\n  };\n}\n\nfunction useRegistry() {\n  var registry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(createRegistry, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    return function unmount() {\n      requestAnimationFrame(registry.clean);\n    };\n  }, [registry]);\n  return registry;\n}\n\nvar StoreContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\nvar getBodyElement = (function () {\n  var body = document.body;\n  !body ?  true ? invariant(false, 'Cannot find document.body') : 0 : void 0;\n  return body;\n});\n\nvar visuallyHidden = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  margin: '-1px',\n  border: '0',\n  padding: '0',\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  'clip-path': 'inset(100%)'\n};\n\nvar getId = function getId(contextId) {\n  return \"rbd-announcement-\" + contextId;\n};\nfunction useAnnouncer(contextId) {\n  var id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return getId(contextId);\n  }, [contextId]);\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n    var el = document.createElement('div');\n    ref.current = el;\n    el.id = id;\n    el.setAttribute('aria-live', 'assertive');\n    el.setAttribute('aria-atomic', 'true');\n\n    (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)(el.style, visuallyHidden);\n\n    getBodyElement().appendChild(el);\n    return function cleanup() {\n      setTimeout(function remove() {\n        var body = getBodyElement();\n\n        if (body.contains(el)) {\n          body.removeChild(el);\n        }\n\n        if (el === ref.current) {\n          ref.current = null;\n        }\n      });\n    };\n  }, [id]);\n  var announce = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (message) {\n    var el = ref.current;\n\n    if (el) {\n      el.textContent = message;\n      return;\n    }\n\n     true ? warning(\"\\n      A screen reader message was trying to be announced but it was unable to do so.\\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\\n      Consider calling provided.announce() before the unmount so that the instruction will\\n      not be lost for users relying on a screen reader.\\n\\n      Message not passed to screen reader:\\n\\n      \\\"\" + message + \"\\\"\\n    \") : 0;\n  }, []);\n  return announce;\n}\n\nvar count = 0;\nvar defaults = {\n  separator: '::'\n};\nfunction reset() {\n  count = 0;\n}\nfunction useUniqueId(prefix, options) {\n  if (options === void 0) {\n    options = defaults;\n  }\n\n  return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return \"\" + prefix + options.separator + count++;\n  }, [options.separator, prefix]);\n}\n\nfunction getElementId(_ref) {\n  var contextId = _ref.contextId,\n      uniqueId = _ref.uniqueId;\n  return \"rbd-hidden-text-\" + contextId + \"-\" + uniqueId;\n}\nfunction useHiddenTextElement(_ref2) {\n  var contextId = _ref2.contextId,\n      text = _ref2.text;\n  var uniqueId = useUniqueId('hidden-text', {\n    separator: '-'\n  });\n  var id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return getElementId({\n      contextId: contextId,\n      uniqueId: uniqueId\n    });\n  }, [uniqueId, contextId]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n    var el = document.createElement('div');\n    el.id = id;\n    el.textContent = text;\n    el.style.display = 'none';\n    getBodyElement().appendChild(el);\n    return function unmount() {\n      var body = getBodyElement();\n\n      if (body.contains(el)) {\n        body.removeChild(el);\n      }\n    };\n  }, [id, text]);\n  return id;\n}\n\nvar AppContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\nvar peerDependencies = {\n\treact: \"^16.8.5\",\n\t\"react-dom\": \"^16.8.5\"\n};\n\nvar semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\n\nvar getVersion = function getVersion(value) {\n  var result = semver.exec(value);\n  !(result != null) ?  true ? invariant(false, \"Unable to parse React version \" + value) : 0 : void 0;\n  var major = Number(result[1]);\n  var minor = Number(result[2]);\n  var patch = Number(result[3]);\n  return {\n    major: major,\n    minor: minor,\n    patch: patch,\n    raw: value\n  };\n};\n\nvar isSatisfied = function isSatisfied(expected, actual) {\n  if (actual.major > expected.major) {\n    return true;\n  }\n\n  if (actual.major < expected.major) {\n    return false;\n  }\n\n  if (actual.minor > expected.minor) {\n    return true;\n  }\n\n  if (actual.minor < expected.minor) {\n    return false;\n  }\n\n  return actual.patch >= expected.patch;\n};\n\nvar checkReactVersion = (function (peerDepValue, actualValue) {\n  var peerDep = getVersion(peerDepValue);\n  var actual = getVersion(actualValue);\n\n  if (isSatisfied(peerDep, actual)) {\n    return;\n  }\n\n   true ? warning(\"\\n    React version: [\" + actual.raw + \"]\\n    does not satisfy expected peer dependency version: [\" + peerDep.raw + \"]\\n\\n    This can result in run time bugs, and even fatal crashes\\n  \") : 0;\n});\n\nvar suffix = \"\\n  We expect a html5 doctype: <!doctype html>\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\";\nvar checkDoctype = (function (doc) {\n  var doctype = doc.doctype;\n\n  if (!doctype) {\n     true ? warning(\"\\n      No <!doctype html> found.\\n\\n      \" + suffix + \"\\n    \") : 0;\n    return;\n  }\n\n  if (doctype.name.toLowerCase() !== 'html') {\n     true ? warning(\"\\n      Unexpected <!doctype> found: (\" + doctype.name + \")\\n\\n      \" + suffix + \"\\n    \") : 0;\n  }\n\n  if (doctype.publicId !== '') {\n     true ? warning(\"\\n      Unexpected <!doctype> publicId found: (\" + doctype.publicId + \")\\n      A html5 doctype does not have a publicId\\n\\n      \" + suffix + \"\\n    \") : 0;\n  }\n});\n\nfunction useDev(useHook) {\n  if (true) {\n    useHook();\n  }\n}\n\nfunction useDevSetupWarning(fn, inputs) {\n  useDev(function () {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      try {\n        fn();\n      } catch (e) {\n        error(\"\\n          A setup problem was encountered.\\n\\n          > \" + e.message + \"\\n        \");\n      }\n    }, inputs);\n  });\n}\n\nfunction useStartupValidation() {\n  useDevSetupWarning(function () {\n    checkReactVersion(peerDependencies.react, react__WEBPACK_IMPORTED_MODULE_0__.version);\n    checkDoctype(document);\n  }, []);\n}\n\nfunction usePrevious(current) {\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    ref.current = current;\n  });\n  return ref;\n}\n\nfunction create() {\n  var lock = null;\n\n  function isClaimed() {\n    return Boolean(lock);\n  }\n\n  function isActive(value) {\n    return value === lock;\n  }\n\n  function claim(abandon) {\n    !!lock ?  true ? invariant(false, 'Cannot claim lock as it is already claimed') : 0 : void 0;\n    var newLock = {\n      abandon: abandon\n    };\n    lock = newLock;\n    return newLock;\n  }\n\n  function release() {\n    !lock ?  true ? invariant(false, 'Cannot release lock when there is no lock') : 0 : void 0;\n    lock = null;\n  }\n\n  function tryAbandon() {\n    if (lock) {\n      lock.abandon();\n      release();\n    }\n  }\n\n  return {\n    isClaimed: isClaimed,\n    isActive: isActive,\n    claim: claim,\n    release: release,\n    tryAbandon: tryAbandon\n  };\n}\n\nvar tab = 9;\nvar enter = 13;\nvar escape = 27;\nvar space = 32;\nvar pageUp = 33;\nvar pageDown = 34;\nvar end = 35;\nvar home = 36;\nvar arrowLeft = 37;\nvar arrowUp = 38;\nvar arrowRight = 39;\nvar arrowDown = 40;\n\nvar _preventedKeys;\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\nvar preventStandardKeyEvents = (function (event) {\n  if (preventedKeys[event.keyCode]) {\n    event.preventDefault();\n  }\n});\n\nvar supportedEventName = function () {\n  var base = 'visibilitychange';\n\n  if (typeof document === 'undefined') {\n    return base;\n  }\n\n  var candidates = [base, \"ms\" + base, \"webkit\" + base, \"moz\" + base, \"o\" + base];\n  var supported = find(candidates, function (eventName) {\n    return \"on\" + eventName in document;\n  });\n  return supported || base;\n}();\n\nvar primaryButton = 0;\nvar sloppyClickThreshold = 5;\n\nfunction isSloppyClickThresholdExceeded(original, current) {\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\n\nvar idle$1 = {\n  type: 'IDLE'\n};\n\nfunction getCaptureBindings(_ref) {\n  var cancel = _ref.cancel,\n      completed = _ref.completed,\n      getPhase = _ref.getPhase,\n      setPhase = _ref.setPhase;\n  return [{\n    eventName: 'mousemove',\n    fn: function fn(event) {\n      var button = event.button,\n          clientX = event.clientX,\n          clientY = event.clientY;\n\n      if (button !== primaryButton) {\n        return;\n      }\n\n      var point = {\n        x: clientX,\n        y: clientY\n      };\n      var phase = getPhase();\n\n      if (phase.type === 'DRAGGING') {\n        event.preventDefault();\n        phase.actions.move(point);\n        return;\n      }\n\n      !(phase.type === 'PENDING') ?  true ? invariant(false, 'Cannot be IDLE') : 0 : void 0;\n      var pending = phase.point;\n\n      if (!isSloppyClickThresholdExceeded(pending, point)) {\n        return;\n      }\n\n      event.preventDefault();\n      var actions = phase.actions.fluidLift(point);\n      setPhase({\n        type: 'DRAGGING',\n        actions: actions\n      });\n    }\n  }, {\n    eventName: 'mouseup',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: function fn(event) {\n      if (getPhase().type === 'DRAGGING') {\n        event.preventDefault();\n      }\n\n      cancel();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type === 'PENDING') {\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: function fn() {\n      if (getPhase().type === 'PENDING') {\n        cancel();\n      }\n    }\n  }, {\n    eventName: 'webkitmouseforcedown',\n    fn: function fn(event) {\n      var phase = getPhase();\n      !(phase.type !== 'IDLE') ?  true ? invariant(false, 'Unexpected phase') : 0 : void 0;\n\n      if (phase.actions.shouldRespectForcePress()) {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useMouseSensor(api) {\n  var phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n  var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop);\n  var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      eventName: 'mousedown',\n      fn: function onMouseDown(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        if (event.button !== primaryButton) {\n          return;\n        }\n\n        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var actions = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!actions) {\n          return;\n        }\n\n        event.preventDefault();\n        var point = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        unbindEventsRef.current();\n        startPendingDrag(actions, point);\n      }\n    };\n  }, [api]);\n  var preventForcePressBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      eventName: 'webkitmouseforcewillbegin',\n      fn: function fn(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        var id = api.findClosestDraggableId(event);\n\n        if (!id) {\n          return;\n        }\n\n        var options = api.findOptionsForDraggable(id);\n\n        if (!options) {\n          return;\n        }\n\n        if (options.shouldRespectForcePress) {\n          return;\n        }\n\n        if (!api.canGetLock(id)) {\n          return;\n        }\n\n        event.preventDefault();\n      }\n    };\n  }, [api]);\n  var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function listenForCapture() {\n    var options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);\n  }, [preventForcePressBinding, startCaptureBinding]);\n  var stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var current = phaseRef.current;\n\n    if (current.type === 'IDLE') {\n      return;\n    }\n\n    phaseRef.current = idle$1;\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture]);\n  var cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var phase = phaseRef.current;\n    stop();\n\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  var bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function bindCapturingEvents() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    var bindings = getCaptureBindings({\n      cancel: cancel,\n      completed: stop,\n      getPhase: function getPhase() {\n        return phaseRef.current;\n      },\n      setPhase: function setPhase(phase) {\n        phaseRef.current = phase;\n      }\n    });\n    unbindEventsRef.current = bindEvents(window, bindings, options);\n  }, [cancel, stop]);\n  var startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startPendingDrag(actions, point) {\n    !(phaseRef.current.type === 'IDLE') ?  true ? invariant(false, 'Expected to move from IDLE to PENDING drag') : 0 : void 0;\n    phaseRef.current = {\n      type: 'PENDING',\n      point: point,\n      actions: actions\n    };\n    bindCapturingEvents();\n  }, [bindCapturingEvents]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nvar _scrollJumpKeys;\n\nfunction noop$1() {}\n\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\n\nfunction getDraggingBindings(actions, stop) {\n  function cancel() {\n    stop();\n    actions.cancel();\n  }\n\n  function drop() {\n    stop();\n    actions.drop();\n  }\n\n  return [{\n    eventName: 'keydown',\n    fn: function fn(event) {\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === space) {\n        event.preventDefault();\n        drop();\n        return;\n      }\n\n      if (event.keyCode === arrowDown) {\n        event.preventDefault();\n        actions.moveDown();\n        return;\n      }\n\n      if (event.keyCode === arrowUp) {\n        event.preventDefault();\n        actions.moveUp();\n        return;\n      }\n\n      if (event.keyCode === arrowRight) {\n        event.preventDefault();\n        actions.moveRight();\n        return;\n      }\n\n      if (event.keyCode === arrowLeft) {\n        event.preventDefault();\n        actions.moveLeft();\n        return;\n      }\n\n      if (scrollJumpKeys[event.keyCode]) {\n        event.preventDefault();\n        return;\n      }\n\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: cancel\n  }, {\n    eventName: 'mouseup',\n    fn: cancel\n  }, {\n    eventName: 'click',\n    fn: cancel\n  }, {\n    eventName: 'touchstart',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'wheel',\n    fn: cancel,\n    options: {\n      passive: true\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useKeyboardSensor(api) {\n  var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n  var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      eventName: 'keydown',\n      fn: function onKeyDown(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        if (event.keyCode !== space) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var preDrag = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!preDrag) {\n          return;\n        }\n\n        event.preventDefault();\n        var isCapturing = true;\n        var actions = preDrag.snapLift();\n        unbindEventsRef.current();\n\n        function stop() {\n          !isCapturing ?  true ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : 0 : void 0;\n          isCapturing = false;\n          unbindEventsRef.current();\n          listenForCapture();\n        }\n\n        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n          capture: true,\n          passive: false\n        });\n      }\n    };\n  }, [api]);\n  var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryStartCapture() {\n    var options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nvar idle$2 = {\n  type: 'IDLE'\n};\nvar timeForLongPress = 120;\nvar forcePressThreshold = 0.15;\n\nfunction getWindowBindings(_ref) {\n  var cancel = _ref.cancel,\n      getPhase = _ref.getPhase;\n  return [{\n    eventName: 'orientationchange',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'contextmenu',\n    fn: function fn(event) {\n      event.preventDefault();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: function fn(event) {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      if (event.keyCode === escape) {\n        event.preventDefault();\n      }\n\n      cancel();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction getHandleBindings(_ref2) {\n  var cancel = _ref2.cancel,\n      completed = _ref2.completed,\n      getPhase = _ref2.getPhase;\n  return [{\n    eventName: 'touchmove',\n    options: {\n      capture: false\n    },\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      phase.hasMoved = true;\n      var _event$touches$ = event.touches[0],\n          clientX = _event$touches$.clientX,\n          clientY = _event$touches$.clientY;\n      var point = {\n        x: clientX,\n        y: clientY\n      };\n      event.preventDefault();\n      phase.actions.move(point);\n    }\n  }, {\n    eventName: 'touchend',\n    fn: function fn(event) {\n      var phase = getPhase();\n\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'touchcancel',\n    fn: function fn(event) {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n      cancel();\n    }\n  }, {\n    eventName: 'touchforcechange',\n    fn: function fn(event) {\n      var phase = getPhase();\n      !(phase.type !== 'IDLE') ?  true ? invariant(false) : 0 : void 0;\n      var touch = event.touches[0];\n\n      if (!touch) {\n        return;\n      }\n\n      var isForcePress = touch.force >= forcePressThreshold;\n\n      if (!isForcePress) {\n        return;\n      }\n\n      var shouldRespect = phase.actions.shouldRespectForcePress();\n\n      if (phase.type === 'PENDING') {\n        if (shouldRespect) {\n          cancel();\n        }\n\n        return;\n      }\n\n      if (shouldRespect) {\n        if (phase.hasMoved) {\n          event.preventDefault();\n          return;\n        }\n\n        cancel();\n        return;\n      }\n\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\n\nfunction useMouseSensor$1(api) {\n  var phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$2);\n  var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop);\n  var getPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function getPhase() {\n    return phaseRef.current;\n  }, []);\n  var setPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function setPhase(phase) {\n    phaseRef.current = phase;\n  }, []);\n  var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      eventName: 'touchstart',\n      fn: function onTouchStart(event) {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        var draggableId = api.findClosestDraggableId(event);\n\n        if (!draggableId) {\n          return;\n        }\n\n        var actions = api.tryGetLock(draggableId, stop, {\n          sourceEvent: event\n        });\n\n        if (!actions) {\n          return;\n        }\n\n        var touch = event.touches[0];\n        var clientX = touch.clientX,\n            clientY = touch.clientY;\n        var point = {\n          x: clientX,\n          y: clientY\n        };\n        unbindEventsRef.current();\n        startPendingDrag(actions, point);\n      }\n    };\n  }, [api]);\n  var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function listenForCapture() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  var stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var current = phaseRef.current;\n\n    if (current.type === 'IDLE') {\n      return;\n    }\n\n    if (current.type === 'PENDING') {\n      clearTimeout(current.longPressTimerId);\n    }\n\n    setPhase(idle$2);\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture, setPhase]);\n  var cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var phase = phaseRef.current;\n    stop();\n\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  var bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function bindCapturingEvents() {\n    var options = {\n      capture: true,\n      passive: false\n    };\n    var args = {\n      cancel: cancel,\n      completed: stop,\n      getPhase: getPhase\n    };\n    var unbindTarget = bindEvents(window, getHandleBindings(args), options);\n    var unbindWindow = bindEvents(window, getWindowBindings(args), options);\n\n    unbindEventsRef.current = function unbindAll() {\n      unbindTarget();\n      unbindWindow();\n    };\n  }, [cancel, getPhase, stop]);\n  var startDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startDragging() {\n    var phase = getPhase();\n    !(phase.type === 'PENDING') ?  true ? invariant(false, \"Cannot start dragging from phase \" + phase.type) : 0 : void 0;\n    var actions = phase.actions.fluidLift(phase.point);\n    setPhase({\n      type: 'DRAGGING',\n      actions: actions,\n      hasMoved: false\n    });\n  }, [getPhase, setPhase]);\n  var startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startPendingDrag(actions, point) {\n    !(getPhase().type === 'IDLE') ?  true ? invariant(false, 'Expected to move from IDLE to PENDING drag') : 0 : void 0;\n    var longPressTimerId = setTimeout(startDragging, timeForLongPress);\n    setPhase({\n      type: 'PENDING',\n      point: point,\n      actions: actions,\n      longPressTimerId: longPressTimerId\n    });\n    bindCapturingEvents();\n  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n      var phase = getPhase();\n\n      if (phase.type === 'PENDING') {\n        clearTimeout(phase.longPressTimerId);\n        setPhase(idle$2);\n      }\n    };\n  }, [getPhase, listenForCapture, setPhase]);\n  useIsomorphicLayoutEffect(function webkitHack() {\n    var unbind = bindEvents(window, [{\n      eventName: 'touchmove',\n      fn: function fn() {},\n      options: {\n        capture: false,\n        passive: false\n      }\n    }]);\n    return unbind;\n  }, []);\n}\n\nfunction useValidateSensorHooks(sensorHooks) {\n  useDev(function () {\n    var previousRef = usePrevious(sensorHooks);\n    useDevSetupWarning(function () {\n      !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, 'Cannot change the amount of sensor hooks after mounting') : 0 : void 0;\n    });\n  });\n}\n\nvar interactiveTagNames = {\n  input: true,\n  button: true,\n  textarea: true,\n  select: true,\n  option: true,\n  optgroup: true,\n  video: true,\n  audio: true\n};\n\nfunction isAnInteractiveElement(parent, current) {\n  if (current == null) {\n    return false;\n  }\n\n  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\n\n  if (hasAnInteractiveTag) {\n    return true;\n  }\n\n  var attribute = current.getAttribute('contenteditable');\n\n  if (attribute === 'true' || attribute === '') {\n    return true;\n  }\n\n  if (current === parent) {\n    return false;\n  }\n\n  return isAnInteractiveElement(parent, current.parentElement);\n}\n\nfunction isEventInInteractiveElement(draggable, event) {\n  var target = event.target;\n\n  if (!isHtmlElement(target)) {\n    return false;\n  }\n\n  return isAnInteractiveElement(draggable, target);\n}\n\nvar getBorderBoxCenterPosition = (function (el) {\n  return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(el.getBoundingClientRect()).center;\n});\n\nfunction isElement(el) {\n  return el instanceof getWindowFromEl(el).Element;\n}\n\nvar supportedMatchesName = function () {\n  var base = 'matches';\n\n  if (typeof document === 'undefined') {\n    return base;\n  }\n\n  var candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];\n  var value = find(candidates, function (name) {\n    return name in Element.prototype;\n  });\n  return value || base;\n}();\n\nfunction closestPonyfill(el, selector) {\n  if (el == null) {\n    return null;\n  }\n\n  if (el[supportedMatchesName](selector)) {\n    return el;\n  }\n\n  return closestPonyfill(el.parentElement, selector);\n}\n\nfunction closest$1(el, selector) {\n  if (el.closest) {\n    return el.closest(selector);\n  }\n\n  return closestPonyfill(el, selector);\n}\n\nfunction getSelector(contextId) {\n  return \"[\" + dragHandle.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n}\n\nfunction findClosestDragHandleFromEvent(contextId, event) {\n  var target = event.target;\n\n  if (!isElement(target)) {\n     true ? warning('event.target must be a Element') : 0;\n    return null;\n  }\n\n  var selector = getSelector(contextId);\n  var handle = closest$1(target, selector);\n\n  if (!handle) {\n    return null;\n  }\n\n  if (!isHtmlElement(handle)) {\n     true ? warning('drag handle must be a HTMLElement') : 0;\n    return null;\n  }\n\n  return handle;\n}\n\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n  var handle = findClosestDragHandleFromEvent(contextId, event);\n\n  if (!handle) {\n    return null;\n  }\n\n  return handle.getAttribute(dragHandle.draggableId);\n}\n\nfunction findDraggable(contextId, draggableId) {\n  var selector = \"[\" + draggable.contextId + \"=\\\"\" + contextId + \"\\\"]\";\n  var possible = toArray(document.querySelectorAll(selector));\n  var draggable$1 = find(possible, function (el) {\n    return el.getAttribute(draggable.id) === draggableId;\n  });\n\n  if (!draggable$1) {\n    return null;\n  }\n\n  if (!isHtmlElement(draggable$1)) {\n     true ? warning('Draggable element is not a HTMLElement') : 0;\n    return null;\n  }\n\n  return draggable$1;\n}\n\nfunction preventDefault(event) {\n  event.preventDefault();\n}\n\nfunction _isActive(_ref) {\n  var expected = _ref.expected,\n      phase = _ref.phase,\n      isLockActive = _ref.isLockActive,\n      shouldWarn = _ref.shouldWarn;\n\n  if (!isLockActive()) {\n    if (shouldWarn) {\n       true ? warning(\"\\n        Cannot perform action.\\n        The sensor no longer has an action lock.\\n\\n        Tips:\\n\\n        - Throw away your action handlers when forceStop() is called\\n        - Check actions.isActive() if you really need to\\n      \") : 0;\n    }\n\n    return false;\n  }\n\n  if (expected !== phase) {\n    if (shouldWarn) {\n       true ? warning(\"\\n        Cannot perform action.\\n        The actions you used belong to an outdated phase\\n\\n        Current phase: \" + expected + \"\\n        You called an action from outdated phase: \" + phase + \"\\n\\n        Tips:\\n\\n        - Do not use preDragActions actions after calling preDragActions.lift()\\n      \") : 0;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction canStart(_ref2) {\n  var lockAPI = _ref2.lockAPI,\n      store = _ref2.store,\n      registry = _ref2.registry,\n      draggableId = _ref2.draggableId;\n\n  if (lockAPI.isClaimed()) {\n    return false;\n  }\n\n  var entry = registry.draggable.findById(draggableId);\n\n  if (!entry) {\n     true ? warning(\"Unable to find draggable with id: \" + draggableId) : 0;\n    return false;\n  }\n\n  if (!entry.options.isEnabled) {\n    return false;\n  }\n\n  if (!canStartDrag(store.getState(), draggableId)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction tryStart(_ref3) {\n  var lockAPI = _ref3.lockAPI,\n      contextId = _ref3.contextId,\n      store = _ref3.store,\n      registry = _ref3.registry,\n      draggableId = _ref3.draggableId,\n      forceSensorStop = _ref3.forceSensorStop,\n      sourceEvent = _ref3.sourceEvent;\n  var shouldStart = canStart({\n    lockAPI: lockAPI,\n    store: store,\n    registry: registry,\n    draggableId: draggableId\n  });\n\n  if (!shouldStart) {\n    return null;\n  }\n\n  var entry = registry.draggable.getById(draggableId);\n  var el = findDraggable(contextId, entry.descriptor.id);\n\n  if (!el) {\n     true ? warning(\"Unable to find draggable element with id: \" + draggableId) : 0;\n    return null;\n  }\n\n  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n    return null;\n  }\n\n  var lock = lockAPI.claim(forceSensorStop || noop);\n  var phase = 'PRE_DRAG';\n\n  function getShouldRespectForcePress() {\n    return entry.options.shouldRespectForcePress;\n  }\n\n  function isLockActive() {\n    return lockAPI.isActive(lock);\n  }\n\n  function tryDispatch(expected, getAction) {\n    if (_isActive({\n      expected: expected,\n      phase: phase,\n      isLockActive: isLockActive,\n      shouldWarn: true\n    })) {\n      store.dispatch(getAction());\n    }\n  }\n\n  var tryDispatchWhenDragging = tryDispatch.bind(null, 'DRAGGING');\n\n  function lift$1(args) {\n    function completed() {\n      lockAPI.release();\n      phase = 'COMPLETED';\n    }\n\n    if (phase !== 'PRE_DRAG') {\n      completed();\n      !(phase === 'PRE_DRAG') ?  true ? invariant(false, \"Cannot lift in phase \" + phase) : 0 : void 0;\n    }\n\n    store.dispatch(lift(args.liftActionArgs));\n    phase = 'DRAGGING';\n\n    function finish(reason, options) {\n      if (options === void 0) {\n        options = {\n          shouldBlockNextClick: false\n        };\n      }\n\n      args.cleanup();\n\n      if (options.shouldBlockNextClick) {\n        var unbind = bindEvents(window, [{\n          eventName: 'click',\n          fn: preventDefault,\n          options: {\n            once: true,\n            passive: false,\n            capture: true\n          }\n        }]);\n        setTimeout(unbind);\n      }\n\n      completed();\n      store.dispatch(drop({\n        reason: reason\n      }));\n    }\n\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n      isActive: function isActive() {\n        return _isActive({\n          expected: 'DRAGGING',\n          phase: phase,\n          isLockActive: isLockActive,\n          shouldWarn: false\n        });\n      },\n      shouldRespectForcePress: getShouldRespectForcePress,\n      drop: function drop(options) {\n        return finish('DROP', options);\n      },\n      cancel: function cancel(options) {\n        return finish('CANCEL', options);\n      }\n    }, args.actions);\n  }\n\n  function fluidLift(clientSelection) {\n    var move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__.default)(function (client) {\n      tryDispatchWhenDragging(function () {\n        return move({\n          client: client\n        });\n      });\n    });\n    var api = lift$1({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection: clientSelection,\n        movementMode: 'FLUID'\n      },\n      cleanup: function cleanup() {\n        return move$1.cancel();\n      },\n      actions: {\n        move: move$1\n      }\n    });\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, api, {\n      move: move$1\n    });\n  }\n\n  function snapLift() {\n    var actions = {\n      moveUp: function moveUp$1() {\n        return tryDispatchWhenDragging(moveUp);\n      },\n      moveRight: function moveRight$1() {\n        return tryDispatchWhenDragging(moveRight);\n      },\n      moveDown: function moveDown$1() {\n        return tryDispatchWhenDragging(moveDown);\n      },\n      moveLeft: function moveLeft$1() {\n        return tryDispatchWhenDragging(moveLeft);\n      }\n    };\n    return lift$1({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection: getBorderBoxCenterPosition(el),\n        movementMode: 'SNAP'\n      },\n      cleanup: noop,\n      actions: actions\n    });\n  }\n\n  function abortPreDrag() {\n    var shouldRelease = _isActive({\n      expected: 'PRE_DRAG',\n      phase: phase,\n      isLockActive: isLockActive,\n      shouldWarn: true\n    });\n\n    if (shouldRelease) {\n      lockAPI.release();\n    }\n  }\n\n  var preDrag = {\n    isActive: function isActive() {\n      return _isActive({\n        expected: 'PRE_DRAG',\n        phase: phase,\n        isLockActive: isLockActive,\n        shouldWarn: false\n      });\n    },\n    shouldRespectForcePress: getShouldRespectForcePress,\n    fluidLift: fluidLift,\n    snapLift: snapLift,\n    abort: abortPreDrag\n  };\n  return preDrag;\n}\n\nvar defaultSensors = [useMouseSensor, useKeyboardSensor, useMouseSensor$1];\nfunction useSensorMarshal(_ref4) {\n  var contextId = _ref4.contextId,\n      store = _ref4.store,\n      registry = _ref4.registry,\n      customSensors = _ref4.customSensors,\n      enableDefaultSensors = _ref4.enableDefaultSensors;\n  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);\n  var lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n    return create();\n  })[0];\n  var tryAbandonLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryAbandonLock(previous, current) {\n    if (previous.isDragging && !current.isDragging) {\n      lockAPI.tryAbandon();\n    }\n  }, [lockAPI]);\n  useIsomorphicLayoutEffect(function listenToStore() {\n    var previous = store.getState();\n    var unsubscribe = store.subscribe(function () {\n      var current = store.getState();\n      tryAbandonLock(previous, current);\n      previous = current;\n    });\n    return unsubscribe;\n  }, [lockAPI, store, tryAbandonLock]);\n  useIsomorphicLayoutEffect(function () {\n    return lockAPI.tryAbandon;\n  }, [lockAPI.tryAbandon]);\n  var canGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (draggableId) {\n    return canStart({\n      lockAPI: lockAPI,\n      registry: registry,\n      store: store,\n      draggableId: draggableId\n    });\n  }, [lockAPI, registry, store]);\n  var tryGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (draggableId, forceStop, options) {\n    return tryStart({\n      lockAPI: lockAPI,\n      registry: registry,\n      contextId: contextId,\n      store: store,\n      draggableId: draggableId,\n      forceSensorStop: forceStop,\n      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n    });\n  }, [contextId, lockAPI, registry, store]);\n  var findClosestDraggableId = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (event) {\n    return tryGetClosestDraggableIdFromEvent(contextId, event);\n  }, [contextId]);\n  var findOptionsForDraggable = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (id) {\n    var entry = registry.draggable.findById(id);\n    return entry ? entry.options : null;\n  }, [registry.draggable]);\n  var tryReleaseLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryReleaseLock() {\n    if (!lockAPI.isClaimed()) {\n      return;\n    }\n\n    lockAPI.tryAbandon();\n\n    if (store.getState().phase !== 'IDLE') {\n      store.dispatch(flush());\n    }\n  }, [lockAPI, store]);\n  var isLockClaimed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(lockAPI.isClaimed, [lockAPI]);\n  var api = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      canGetLock: canGetLock,\n      tryGetLock: tryGetLock,\n      findClosestDraggableId: findClosestDraggableId,\n      findOptionsForDraggable: findOptionsForDraggable,\n      tryReleaseLock: tryReleaseLock,\n      isLockClaimed: isLockClaimed\n    };\n  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);\n  useValidateSensorHooks(useSensors);\n\n  for (var i = 0; i < useSensors.length; i++) {\n    useSensors[i](api);\n  }\n}\n\nvar createResponders = function createResponders(props) {\n  return {\n    onBeforeCapture: props.onBeforeCapture,\n    onBeforeDragStart: props.onBeforeDragStart,\n    onDragStart: props.onDragStart,\n    onDragEnd: props.onDragEnd,\n    onDragUpdate: props.onDragUpdate\n  };\n};\n\nfunction getStore(lazyRef) {\n  !lazyRef.current ?  true ? invariant(false, 'Could not find store from lazy ref') : 0 : void 0;\n  return lazyRef.current;\n}\n\nfunction App(props) {\n  var contextId = props.contextId,\n      setCallbacks = props.setCallbacks,\n      sensors = props.sensors,\n      nonce = props.nonce,\n      dragHandleUsageInstructions = props.dragHandleUsageInstructions;\n  var lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  useStartupValidation();\n  var lastPropsRef = usePrevious(props);\n  var getResponders = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    return createResponders(lastPropsRef.current);\n  }, [lastPropsRef]);\n  var announce = useAnnouncer(contextId);\n  var dragHandleUsageInstructionsId = useHiddenTextElement({\n    contextId: contextId,\n    text: dragHandleUsageInstructions\n  });\n  var styleMarshal = useStyleMarshal(contextId, nonce);\n  var lazyDispatch = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (action) {\n    getStore(lazyStoreRef).dispatch(action);\n  }, []);\n  var marshalCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return (0,redux__WEBPACK_IMPORTED_MODULE_8__.bindActionCreators)({\n      publishWhileDragging: publishWhileDragging,\n      updateDroppableScroll: updateDroppableScroll,\n      updateDroppableIsEnabled: updateDroppableIsEnabled,\n      updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n      collectionStarting: collectionStarting\n    }, lazyDispatch);\n  }, [lazyDispatch]);\n  var registry = useRegistry();\n  var dimensionMarshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return createDimensionMarshal(registry, marshalCallbacks);\n  }, [registry, marshalCallbacks]);\n  var autoScroller = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return createAutoScroller((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({\n      scrollWindow: scrollWindow,\n      scrollDroppable: dimensionMarshal.scrollDroppable\n    }, (0,redux__WEBPACK_IMPORTED_MODULE_8__.bindActionCreators)({\n      move: move\n    }, lazyDispatch)));\n  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);\n  var focusMarshal = useFocusMarshal(contextId);\n  var store = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return createStore({\n      announce: announce,\n      autoScroller: autoScroller,\n      dimensionMarshal: dimensionMarshal,\n      focusMarshal: focusMarshal,\n      getResponders: getResponders,\n      styleMarshal: styleMarshal\n    });\n  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);\n\n  if (true) {\n    if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n       true ? warning('unexpected store change') : 0;\n    }\n  }\n\n  lazyStoreRef.current = store;\n  var tryResetStore = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var current = getStore(lazyStoreRef);\n    var state = current.getState();\n\n    if (state.phase !== 'IDLE') {\n      current.dispatch(flush());\n    }\n  }, []);\n  var isDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var state = getStore(lazyStoreRef).getState();\n    return state.isDragging || state.phase === 'DROP_ANIMATING';\n  }, []);\n  var appCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      isDragging: isDragging,\n      tryAbort: tryResetStore\n    };\n  }, [isDragging, tryResetStore]);\n  setCallbacks(appCallbacks);\n  var getCanLift = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (id) {\n    return canStartDrag(getStore(lazyStoreRef).getState(), id);\n  }, []);\n  var getIsMovementAllowed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    return isMovementAllowed(getStore(lazyStoreRef).getState());\n  }, []);\n  var appContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      marshal: dimensionMarshal,\n      focus: focusMarshal,\n      contextId: contextId,\n      canLift: getCanLift,\n      isMovementAllowed: getIsMovementAllowed,\n      dragHandleUsageInstructionsId: dragHandleUsageInstructionsId,\n      registry: registry\n    };\n  }, [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);\n  useSensorMarshal({\n    contextId: contextId,\n    store: store,\n    registry: registry,\n    customSensors: sensors,\n    enableDefaultSensors: props.enableDefaultSensors !== false\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    return tryResetStore;\n  }, [tryResetStore]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(AppContext.Provider, {\n    value: appContext\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_redux__WEBPACK_IMPORTED_MODULE_1__.Provider, {\n    context: StoreContext,\n    store: store\n  }, props.children));\n}\n\nvar count$1 = 0;\nfunction reset$1() {\n  count$1 = 0;\n}\nfunction useInstanceCount() {\n  return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return \"\" + count$1++;\n  }, []);\n}\n\nfunction resetServerContext() {\n  reset$1();\n  reset();\n}\nfunction DragDropContext(props) {\n  var contextId = useInstanceCount();\n  var dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ErrorBoundary, null, function (setCallbacks) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(App, {\n      nonce: props.nonce,\n      contextId: contextId,\n      setCallbacks: setCallbacks,\n      dragHandleUsageInstructions: dragHandleUsageInstructions,\n      enableDefaultSensors: props.enableDefaultSensors,\n      sensors: props.sensors,\n      onBeforeCapture: props.onBeforeCapture,\n      onBeforeDragStart: props.onBeforeDragStart,\n      onDragStart: props.onDragStart,\n      onDragUpdate: props.onDragUpdate,\n      onDragEnd: props.onDragEnd\n    }, props.children);\n  });\n}\n\nvar isEqual$1 = function isEqual(base) {\n  return function (value) {\n    return base === value;\n  };\n};\n\nvar isScroll = isEqual$1('scroll');\nvar isAuto = isEqual$1('auto');\nvar isVisible$1 = isEqual$1('visible');\n\nvar isEither = function isEither(overflow, fn) {\n  return fn(overflow.overflowX) || fn(overflow.overflowY);\n};\n\nvar isBoth = function isBoth(overflow, fn) {\n  return fn(overflow.overflowX) && fn(overflow.overflowY);\n};\n\nvar isElementScrollable = function isElementScrollable(el) {\n  var style = window.getComputedStyle(el);\n  var overflow = {\n    overflowX: style.overflowX,\n    overflowY: style.overflowY\n  };\n  return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\n\nvar isBodyScrollable = function isBodyScrollable() {\n  if (false) {}\n\n  var body = getBodyElement();\n  var html = document.documentElement;\n  !html ?  true ? invariant(false) : 0 : void 0;\n\n  if (!isElementScrollable(body)) {\n    return false;\n  }\n\n  var htmlStyle = window.getComputedStyle(html);\n  var htmlOverflow = {\n    overflowX: htmlStyle.overflowX,\n    overflowY: htmlStyle.overflowY\n  };\n\n  if (isBoth(htmlOverflow, isVisible$1)) {\n    return false;\n  }\n\n   true ? warning(\"\\n    We have detected that your <body> element might be a scroll container.\\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\\n\\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\\n    we will be treating the <body> as *not* a scroll container\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\n  \") : 0;\n  return false;\n};\n\nvar getClosestScrollable = function getClosestScrollable(el) {\n  if (el == null) {\n    return null;\n  }\n\n  if (el === document.body) {\n    return isBodyScrollable() ? el : null;\n  }\n\n  if (el === document.documentElement) {\n    return null;\n  }\n\n  if (!isElementScrollable(el)) {\n    return getClosestScrollable(el.parentElement);\n  }\n\n  return el;\n};\n\nvar checkForNestedScrollContainers = (function (scrollable) {\n  if (!scrollable) {\n    return;\n  }\n\n  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n\n  if (!anotherScrollParent) {\n    return;\n  }\n\n   true ? warning(\"\\n    Droppable: unsupported nested scroll container detected.\\n    A Droppable can only have one scroll parent (which can be itself)\\n    Nested scroll containers are currently not supported.\\n\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\n  \") : 0;\n});\n\nvar getScroll$1 = (function (el) {\n  return {\n    x: el.scrollLeft,\n    y: el.scrollTop\n  };\n});\n\nvar getIsFixed = function getIsFixed(el) {\n  if (!el) {\n    return false;\n  }\n\n  var style = window.getComputedStyle(el);\n\n  if (style.position === 'fixed') {\n    return true;\n  }\n\n  return getIsFixed(el.parentElement);\n};\n\nvar getEnv = (function (start) {\n  var closestScrollable = getClosestScrollable(start);\n  var isFixedOnPage = getIsFixed(start);\n  return {\n    closestScrollable: closestScrollable,\n    isFixedOnPage: isFixedOnPage\n  };\n});\n\nvar getDroppableDimension = (function (_ref) {\n  var descriptor = _ref.descriptor,\n      isEnabled = _ref.isEnabled,\n      isCombineEnabled = _ref.isCombineEnabled,\n      isFixedOnPage = _ref.isFixedOnPage,\n      direction = _ref.direction,\n      client = _ref.client,\n      page = _ref.page,\n      closest = _ref.closest;\n\n  var frame = function () {\n    if (!closest) {\n      return null;\n    }\n\n    var scrollSize = closest.scrollSize,\n        frameClient = closest.client;\n    var maxScroll = getMaxScroll({\n      scrollHeight: scrollSize.scrollHeight,\n      scrollWidth: scrollSize.scrollWidth,\n      height: frameClient.paddingBox.height,\n      width: frameClient.paddingBox.width\n    });\n    return {\n      pageMarginBox: closest.page.marginBox,\n      frameClient: frameClient,\n      scrollSize: scrollSize,\n      shouldClipSubject: closest.shouldClipSubject,\n      scroll: {\n        initial: closest.scroll,\n        current: closest.scroll,\n        max: maxScroll,\n        diff: {\n          value: origin,\n          displacement: origin\n        }\n      }\n    };\n  }();\n\n  var axis = direction === 'vertical' ? vertical : horizontal;\n  var subject = getSubject({\n    page: page,\n    withPlaceholder: null,\n    axis: axis,\n    frame: frame\n  });\n  var dimension = {\n    descriptor: descriptor,\n    isCombineEnabled: isCombineEnabled,\n    isFixedOnPage: isFixedOnPage,\n    axis: axis,\n    isEnabled: isEnabled,\n    client: client,\n    page: page,\n    frame: frame,\n    subject: subject\n  };\n  return dimension;\n});\n\nvar getClient = function getClient(targetRef, closestScrollable) {\n  var base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getBox)(targetRef);\n\n  if (!closestScrollable) {\n    return base;\n  }\n\n  if (targetRef !== closestScrollable) {\n    return base;\n  }\n\n  var top = base.paddingBox.top - closestScrollable.scrollTop;\n  var left = base.paddingBox.left - closestScrollable.scrollLeft;\n  var bottom = top + closestScrollable.scrollHeight;\n  var right = left + closestScrollable.scrollWidth;\n  var paddingBox = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n  var borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.expand)(paddingBox, base.border);\n  var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.createBox)({\n    borderBox: borderBox,\n    margin: base.margin,\n    border: base.border,\n    padding: base.padding\n  });\n  return client;\n};\n\nvar getDimension = (function (_ref) {\n  var ref = _ref.ref,\n      descriptor = _ref.descriptor,\n      env = _ref.env,\n      windowScroll = _ref.windowScroll,\n      direction = _ref.direction,\n      isDropDisabled = _ref.isDropDisabled,\n      isCombineEnabled = _ref.isCombineEnabled,\n      shouldClipSubject = _ref.shouldClipSubject;\n  var closestScrollable = env.closestScrollable;\n  var client = getClient(ref, closestScrollable);\n  var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, windowScroll);\n\n  var closest = function () {\n    if (!closestScrollable) {\n      return null;\n    }\n\n    var frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getBox)(closestScrollable);\n    var scrollSize = {\n      scrollHeight: closestScrollable.scrollHeight,\n      scrollWidth: closestScrollable.scrollWidth\n    };\n    return {\n      client: frameClient,\n      page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(frameClient, windowScroll),\n      scroll: getScroll$1(closestScrollable),\n      scrollSize: scrollSize,\n      shouldClipSubject: shouldClipSubject\n    };\n  }();\n\n  var dimension = getDroppableDimension({\n    descriptor: descriptor,\n    isEnabled: !isDropDisabled,\n    isCombineEnabled: isCombineEnabled,\n    isFixedOnPage: env.isFixedOnPage,\n    direction: direction,\n    client: client,\n    page: page,\n    closest: closest\n  });\n  return dimension;\n});\n\nvar immediate = {\n  passive: false\n};\nvar delayed = {\n  passive: true\n};\nvar getListenerOptions = (function (options) {\n  return options.shouldPublishImmediately ? immediate : delayed;\n});\n\nfunction useRequiredContext(Context) {\n  var result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n  !result ?  true ? invariant(false, 'Could not find required context') : 0 : void 0;\n  return result;\n}\n\nvar getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {\n  return dragging && dragging.env.closestScrollable || null;\n};\n\nfunction useDroppablePublisher(args) {\n  var whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var appContext = useRequiredContext(AppContext);\n  var uniqueId = useUniqueId('droppable');\n  var registry = appContext.registry,\n      marshal = appContext.marshal;\n  var previousRef = usePrevious(args);\n  var descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      id: args.droppableId,\n      type: args.type,\n      mode: args.mode\n    };\n  }, [args.droppableId, args.mode, args.type]);\n  var publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n  var memoizedUpdateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (x, y) {\n      !whileDraggingRef.current ?  true ? invariant(false, 'Can only update scroll when dragging') : 0 : void 0;\n      var scroll = {\n        x: x,\n        y: y\n      };\n      marshal.updateDroppableScroll(descriptor.id, scroll);\n    });\n  }, [descriptor.id, marshal]);\n  var getClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var dragging = whileDraggingRef.current;\n\n    if (!dragging || !dragging.env.closestScrollable) {\n      return origin;\n    }\n\n    return getScroll$1(dragging.env.closestScrollable);\n  }, []);\n  var updateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var scroll = getClosestScroll();\n    memoizedUpdateScroll(scroll.x, scroll.y);\n  }, [getClosestScroll, memoizedUpdateScroll]);\n  var scheduleScrollUpdate = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__.default)(updateScroll);\n  }, [updateScroll]);\n  var onClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var dragging = whileDraggingRef.current;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ?  true ? invariant(false, 'Could not find scroll options while scrolling') : 0 : void 0;\n    var options = dragging.scrollOptions;\n\n    if (options.shouldPublishImmediately) {\n      updateScroll();\n      return;\n    }\n\n    scheduleScrollUpdate();\n  }, [scheduleScrollUpdate, updateScroll]);\n  var getDimensionAndWatchScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (windowScroll, options) {\n    !!whileDraggingRef.current ?  true ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : 0 : void 0;\n    var previous = previousRef.current;\n    var ref = previous.getDroppableRef();\n    !ref ?  true ? invariant(false, 'Cannot collect without a droppable ref') : 0 : void 0;\n    var env = getEnv(ref);\n    var dragging = {\n      ref: ref,\n      descriptor: descriptor,\n      env: env,\n      scrollOptions: options\n    };\n    whileDraggingRef.current = dragging;\n    var dimension = getDimension({\n      ref: ref,\n      descriptor: descriptor,\n      env: env,\n      windowScroll: windowScroll,\n      direction: previous.direction,\n      isDropDisabled: previous.isDropDisabled,\n      isCombineEnabled: previous.isCombineEnabled,\n      shouldClipSubject: !previous.ignoreContainerClipping\n    });\n    var scrollable = env.closestScrollable;\n\n    if (scrollable) {\n      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n\n      if (true) {\n        checkForNestedScrollContainers(scrollable);\n      }\n    }\n\n    return dimension;\n  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);\n  var getScrollWhileDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var dragging = whileDraggingRef.current;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ?  true ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : 0 : void 0;\n    return getScroll$1(closest);\n  }, []);\n  var dragStopped = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    var dragging = whileDraggingRef.current;\n    !dragging ?  true ? invariant(false, 'Cannot stop drag when no active drag') : 0 : void 0;\n    var closest = getClosestScrollableFromDrag(dragging);\n    whileDraggingRef.current = null;\n\n    if (!closest) {\n      return;\n    }\n\n    scheduleScrollUpdate.cancel();\n    closest.removeAttribute(scrollContainer.contextId);\n    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n  }, [onClosestScroll, scheduleScrollUpdate]);\n  var scroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (change) {\n    var dragging = whileDraggingRef.current;\n    !dragging ?  true ? invariant(false, 'Cannot scroll when there is no drag') : 0 : void 0;\n    var closest = getClosestScrollableFromDrag(dragging);\n    !closest ?  true ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : 0 : void 0;\n    closest.scrollTop += change.y;\n    closest.scrollLeft += change.x;\n  }, []);\n  var callbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      getDimensionAndWatchScroll: getDimensionAndWatchScroll,\n      getScrollWhileDragging: getScrollWhileDragging,\n      dragStopped: dragStopped,\n      scroll: scroll\n    };\n  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);\n  var entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      uniqueId: uniqueId,\n      descriptor: descriptor,\n      callbacks: callbacks\n    };\n  }, [callbacks, descriptor, uniqueId]);\n  useIsomorphicLayoutEffect(function () {\n    publishedDescriptorRef.current = entry.descriptor;\n    registry.droppable.register(entry);\n    return function () {\n      if (whileDraggingRef.current) {\n         true ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : 0;\n        dragStopped();\n      }\n\n      registry.droppable.unregister(entry);\n    };\n  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);\n  useIsomorphicLayoutEffect(function () {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n\n    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n  }, [args.isDropDisabled, marshal]);\n  useIsomorphicLayoutEffect(function () {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n\n    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n  }, [args.isCombineEnabled, marshal]);\n}\n\nfunction noop$2() {}\n\nvar empty = {\n  width: 0,\n  height: 0,\n  margin: noSpacing\n};\n\nvar getSize = function getSize(_ref) {\n  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount,\n      placeholder = _ref.placeholder,\n      animate = _ref.animate;\n\n  if (isAnimatingOpenOnMount) {\n    return empty;\n  }\n\n  if (animate === 'close') {\n    return empty;\n  }\n\n  return {\n    height: placeholder.client.borderBox.height,\n    width: placeholder.client.borderBox.width,\n    margin: placeholder.client.margin\n  };\n};\n\nvar getStyle = function getStyle(_ref2) {\n  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount,\n      placeholder = _ref2.placeholder,\n      animate = _ref2.animate;\n  var size = getSize({\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n    placeholder: placeholder,\n    animate: animate\n  });\n  return {\n    display: placeholder.display,\n    boxSizing: 'border-box',\n    width: size.width,\n    height: size.height,\n    marginTop: size.margin.top,\n    marginRight: size.margin.right,\n    marginBottom: size.margin.bottom,\n    marginLeft: size.margin.left,\n    flexShrink: '0',\n    flexGrow: '0',\n    pointerEvents: 'none',\n    transition: animate !== 'none' ? transitions.placeholder : null\n  };\n};\n\nfunction Placeholder(props) {\n  var animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var tryClearAnimateOpenTimer = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    if (!animateOpenTimerRef.current) {\n      return;\n    }\n\n    clearTimeout(animateOpenTimerRef.current);\n    animateOpenTimerRef.current = null;\n  }, []);\n  var animate = props.animate,\n      onTransitionEnd = props.onTransitionEnd,\n      onClose = props.onClose,\n      contextId = props.contextId;\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === 'open'),\n      isAnimatingOpenOnMount = _useState[0],\n      setIsAnimatingOpenOnMount = _useState[1];\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (!isAnimatingOpenOnMount) {\n      return noop$2;\n    }\n\n    if (animate !== 'open') {\n      tryClearAnimateOpenTimer();\n      setIsAnimatingOpenOnMount(false);\n      return noop$2;\n    }\n\n    if (animateOpenTimerRef.current) {\n      return noop$2;\n    }\n\n    animateOpenTimerRef.current = setTimeout(function () {\n      animateOpenTimerRef.current = null;\n      setIsAnimatingOpenOnMount(false);\n    });\n    return tryClearAnimateOpenTimer;\n  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);\n  var onSizeChangeEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (event) {\n    if (event.propertyName !== 'height') {\n      return;\n    }\n\n    onTransitionEnd();\n\n    if (animate === 'close') {\n      onClose();\n    }\n  }, [animate, onClose, onTransitionEnd]);\n  var style = getStyle({\n    isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n    animate: props.animate,\n    placeholder: props.placeholder\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(props.placeholder.tagName, {\n    style: style,\n    'data-rbd-placeholder-context-id': contextId,\n    onTransitionEnd: onSizeChangeEnd,\n    ref: props.innerRef\n  });\n}\n\nvar Placeholder$1 = react__WEBPACK_IMPORTED_MODULE_0__.memo(Placeholder);\n\nvar DroppableContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\nfunction checkIsValidInnerRef(el) {\n  !(el && isHtmlElement(el)) ?  true ? invariant(false, \"\\n    provided.innerRef has not been provided with a HTMLElement.\\n\\n    You can find a guide on using the innerRef callback functions at:\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\n  \") : 0 : void 0;\n}\n\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nfunction runChecks(args, checks) {\n  checks.forEach(function (check) {\n    return check(args);\n  });\n}\n\nvar shared = [function required(_ref) {\n  var props = _ref.props;\n  !props.droppableId ?  true ? invariant(false, 'A Droppable requires a droppableId prop') : 0 : void 0;\n  !(typeof props.droppableId === 'string') ?  true ? invariant(false, \"A Droppable requires a [string] droppableId. Provided: [\" + typeof props.droppableId + \"]\") : 0 : void 0;\n}, function _boolean(_ref2) {\n  var props = _ref2.props;\n  !isBoolean(props.isDropDisabled) ?  true ? invariant(false, 'isDropDisabled must be a boolean') : 0 : void 0;\n  !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, 'isCombineEnabled must be a boolean') : 0 : void 0;\n  !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, 'ignoreContainerClipping must be a boolean') : 0 : void 0;\n}, function ref(_ref3) {\n  var getDroppableRef = _ref3.getDroppableRef;\n  checkIsValidInnerRef(getDroppableRef());\n}];\nvar standard = [function placeholder(_ref4) {\n  var props = _ref4.props,\n      getPlaceholderRef = _ref4.getPlaceholderRef;\n\n  if (!props.placeholder) {\n    return;\n  }\n\n  var ref = getPlaceholderRef();\n\n  if (ref) {\n    return;\n  }\n\n   true ? warning(\"\\n      Droppable setup issue [droppableId: \\\"\" + props.droppableId + \"\\\"]:\\n      DroppableProvided > placeholder could not be found.\\n\\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\n    \") : 0;\n}];\nvar virtual = [function hasClone(_ref5) {\n  var props = _ref5.props;\n  !props.renderClone ?  true ? invariant(false, 'Must provide a clone render function (renderClone) for virtual lists') : 0 : void 0;\n}, function hasNoPlaceholder(_ref6) {\n  var getPlaceholderRef = _ref6.getPlaceholderRef;\n  !!getPlaceholderRef() ?  true ? invariant(false, 'Expected virtual list to not have a placeholder') : 0 : void 0;\n}];\nfunction useValidation(args) {\n  useDevSetupWarning(function () {\n    runChecks(args, shared);\n\n    if (args.props.mode === 'standard') {\n      runChecks(args, standard);\n    }\n\n    if (args.props.mode === 'virtual') {\n      runChecks(args, virtual);\n    }\n  });\n}\n\nvar AnimateInOut = function (_React$PureComponent) {\n  (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__.default)(AnimateInOut, _React$PureComponent);\n\n  function AnimateInOut() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n    _this.state = {\n      isVisible: Boolean(_this.props.on),\n      data: _this.props.on,\n      animate: _this.props.shouldAnimate && _this.props.on ? 'open' : 'none'\n    };\n\n    _this.onClose = function () {\n      if (_this.state.animate !== 'close') {\n        return;\n      }\n\n      _this.setState({\n        isVisible: false\n      });\n    };\n\n    return _this;\n  }\n\n  AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    if (!props.shouldAnimate) {\n      return {\n        isVisible: Boolean(props.on),\n        data: props.on,\n        animate: 'none'\n      };\n    }\n\n    if (props.on) {\n      return {\n        isVisible: true,\n        data: props.on,\n        animate: 'open'\n      };\n    }\n\n    if (state.isVisible) {\n      return {\n        isVisible: true,\n        data: state.data,\n        animate: 'close'\n      };\n    }\n\n    return {\n      isVisible: false,\n      animate: 'close',\n      data: null\n    };\n  };\n\n  var _proto = AnimateInOut.prototype;\n\n  _proto.render = function render() {\n    if (!this.state.isVisible) {\n      return null;\n    }\n\n    var provided = {\n      onClose: this.onClose,\n      data: this.state.data,\n      animate: this.state.animate\n    };\n    return this.props.children(provided);\n  };\n\n  return AnimateInOut;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\n\nvar zIndexOptions = {\n  dragging: 5000,\n  dropAnimating: 4500\n};\n\nvar getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {\n  if (dropping) {\n    return transitions.drop(dropping.duration);\n  }\n\n  if (shouldAnimateDragMovement) {\n    return transitions.snap;\n  }\n\n  return transitions.fluid;\n};\n\nvar getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {\n  if (!isCombining) {\n    return null;\n  }\n\n  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\n\nvar getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {\n  if (dragging.forceShouldAnimate != null) {\n    return dragging.forceShouldAnimate;\n  }\n\n  return dragging.mode === 'SNAP';\n};\n\nfunction getDraggingStyle(dragging) {\n  var dimension = dragging.dimension;\n  var box = dimension.client;\n  var offset = dragging.offset,\n      combineWith = dragging.combineWith,\n      dropping = dragging.dropping;\n  var isCombining = Boolean(combineWith);\n  var shouldAnimate = getShouldDraggingAnimate(dragging);\n  var isDropAnimating = Boolean(dropping);\n  var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n  var style = {\n    position: 'fixed',\n    top: box.marginBox.top,\n    left: box.marginBox.left,\n    boxSizing: 'border-box',\n    width: box.borderBox.width,\n    height: box.borderBox.height,\n    transition: getDraggingTransition(shouldAnimate, dropping),\n    transform: transform,\n    opacity: getDraggingOpacity(isCombining, isDropAnimating),\n    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n    pointerEvents: 'none'\n  };\n  return style;\n}\n\nfunction getSecondaryStyle(secondary) {\n  return {\n    transform: transforms.moveTo(secondary.offset),\n    transition: secondary.shouldAnimateDisplacement ? null : 'none'\n  };\n}\n\nfunction getStyle$1(mapped) {\n  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\n\nfunction getDimension$1(descriptor, el, windowScroll) {\n  if (windowScroll === void 0) {\n    windowScroll = origin;\n  }\n\n  var computedStyles = window.getComputedStyle(el);\n  var borderBox = el.getBoundingClientRect();\n  var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.calculateBox)(borderBox, computedStyles);\n  var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, windowScroll);\n  var placeholder = {\n    client: client,\n    tagName: el.tagName.toLowerCase(),\n    display: computedStyles.display\n  };\n  var displaceBy = {\n    x: client.marginBox.width,\n    y: client.marginBox.height\n  };\n  var dimension = {\n    descriptor: descriptor,\n    placeholder: placeholder,\n    displaceBy: displaceBy,\n    client: client,\n    page: page\n  };\n  return dimension;\n}\n\nfunction useDraggablePublisher(args) {\n  var uniqueId = useUniqueId('draggable');\n  var descriptor = args.descriptor,\n      registry = args.registry,\n      getDraggableRef = args.getDraggableRef,\n      canDragInteractiveElements = args.canDragInteractiveElements,\n      shouldRespectForcePress = args.shouldRespectForcePress,\n      isEnabled = args.isEnabled;\n  var options = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      canDragInteractiveElements: canDragInteractiveElements,\n      shouldRespectForcePress: shouldRespectForcePress,\n      isEnabled: isEnabled\n    };\n  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);\n  var getDimension = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (windowScroll) {\n    var el = getDraggableRef();\n    !el ?  true ? invariant(false, 'Cannot get dimension when no ref is set') : 0 : void 0;\n    return getDimension$1(descriptor, el, windowScroll);\n  }, [descriptor, getDraggableRef]);\n  var entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      uniqueId: uniqueId,\n      descriptor: descriptor,\n      options: options,\n      getDimension: getDimension\n    };\n  }, [descriptor, getDimension, options, uniqueId]);\n  var publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n  var isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  useIsomorphicLayoutEffect(function () {\n    registry.draggable.register(publishedRef.current);\n    return function () {\n      return registry.draggable.unregister(publishedRef.current);\n    };\n  }, [registry.draggable]);\n  useIsomorphicLayoutEffect(function () {\n    if (isFirstPublishRef.current) {\n      isFirstPublishRef.current = false;\n      return;\n    }\n\n    var last = publishedRef.current;\n    publishedRef.current = entry;\n    registry.draggable.update(entry, last);\n  }, [entry, registry.draggable]);\n}\n\nfunction useValidation$1(props, contextId, getRef) {\n  useDevSetupWarning(function () {\n    function prefix(id) {\n      return \"Draggable[id: \" + id + \"]: \";\n    }\n\n    var id = props.draggableId;\n    !id ?  true ? invariant(false, 'Draggable requires a draggableId') : 0 : void 0;\n    !(typeof id === 'string') ?  true ? invariant(false, \"Draggable requires a [string] draggableId.\\n      Provided: [type: \" + typeof id + \"] (value: \" + id + \")\") : 0 : void 0;\n    !isInteger(props.index) ?  true ? invariant(false, prefix(id) + \" requires an integer index prop\") : 0 : void 0;\n\n    if (props.mapped.type === 'DRAGGING') {\n      return;\n    }\n\n    checkIsValidInnerRef(getRef());\n\n    if (props.isEnabled) {\n      !findDragHandle(contextId, id) ?  true ? invariant(false, prefix(id) + \" Unable to find drag handle\") : 0 : void 0;\n    }\n  });\n}\nfunction useClonePropValidation(isClone) {\n  useDev(function () {\n    var initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n    useDevSetupWarning(function () {\n      !(isClone === initialRef.current) ?  true ? invariant(false, 'Draggable isClone prop value changed during component life') : 0 : void 0;\n    }, [isClone]);\n  });\n}\n\nfunction preventHtml5Dnd(event) {\n  event.preventDefault();\n}\n\nfunction Draggable(props) {\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var setRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (el) {\n    ref.current = el;\n  }, []);\n  var getRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    return ref.current;\n  }, []);\n\n  var _useRequiredContext = useRequiredContext(AppContext),\n      contextId = _useRequiredContext.contextId,\n      dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId,\n      registry = _useRequiredContext.registry;\n\n  var _useRequiredContext2 = useRequiredContext(DroppableContext),\n      type = _useRequiredContext2.type,\n      droppableId = _useRequiredContext2.droppableId;\n\n  var descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      id: props.draggableId,\n      index: props.index,\n      type: type,\n      droppableId: droppableId\n    };\n  }, [props.draggableId, props.index, type, droppableId]);\n  var children = props.children,\n      draggableId = props.draggableId,\n      isEnabled = props.isEnabled,\n      shouldRespectForcePress = props.shouldRespectForcePress,\n      canDragInteractiveElements = props.canDragInteractiveElements,\n      isClone = props.isClone,\n      mapped = props.mapped,\n      dropAnimationFinishedAction = props.dropAnimationFinished;\n  useValidation$1(props, contextId, getRef);\n  useClonePropValidation(isClone);\n\n  if (!isClone) {\n    var forPublisher = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n      return {\n        descriptor: descriptor,\n        registry: registry,\n        getDraggableRef: getRef,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress,\n        isEnabled: isEnabled\n      };\n    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);\n    useDraggablePublisher(forPublisher);\n  }\n\n  var dragHandleProps = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return isEnabled ? {\n      tabIndex: 0,\n      role: 'button',\n      'aria-describedby': dragHandleUsageInstructionsId,\n      'data-rbd-drag-handle-draggable-id': draggableId,\n      'data-rbd-drag-handle-context-id': contextId,\n      draggable: false,\n      onDragStart: preventHtml5Dnd\n    } : null;\n  }, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);\n  var onMoveEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (event) {\n    if (mapped.type !== 'DRAGGING') {\n      return;\n    }\n\n    if (!mapped.dropping) {\n      return;\n    }\n\n    if (event.propertyName !== 'transform') {\n      return;\n    }\n\n    dropAnimationFinishedAction();\n  }, [dropAnimationFinishedAction, mapped]);\n  var provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    var style = getStyle$1(mapped);\n    var onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;\n    var result = {\n      innerRef: setRef,\n      draggableProps: {\n        'data-rbd-draggable-context-id': contextId,\n        'data-rbd-draggable-id': draggableId,\n        style: style,\n        onTransitionEnd: onTransitionEnd\n      },\n      dragHandleProps: dragHandleProps\n    };\n    return result;\n  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);\n  var rubric = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      draggableId: descriptor.id,\n      type: descriptor.type,\n      source: {\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n      }\n    };\n  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);\n  return children(provided, mapped.snapshot, rubric);\n}\n\nvar isStrictEqual = (function (a, b) {\n  return a === b;\n});\n\nvar whatIsDraggedOverFromResult = (function (result) {\n  var combine = result.combine,\n      destination = result.destination;\n\n  if (destination) {\n    return destination.droppableId;\n  }\n\n  if (combine) {\n    return combine.droppableId;\n  }\n\n  return null;\n});\n\nvar getCombineWithFromResult = function getCombineWithFromResult(result) {\n  return result.combine ? result.combine.draggableId : null;\n};\n\nvar getCombineWithFromImpact = function getCombineWithFromImpact(impact) {\n  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;\n};\n\nfunction getDraggableSelector() {\n  var memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (mode, isClone, draggingOver, combineWith, dropping) {\n    return {\n      isDragging: true,\n      isClone: isClone,\n      isDropAnimating: Boolean(dropping),\n      dropAnimation: dropping,\n      mode: mode,\n      draggingOver: draggingOver,\n      combineWith: combineWith,\n      combineTargetFor: null\n    };\n  });\n  var getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {\n    return {\n      mapped: {\n        type: 'DRAGGING',\n        dropping: null,\n        draggingOver: draggingOver,\n        combineWith: combineWith,\n        mode: mode,\n        offset: offset,\n        dimension: dimension,\n        forceShouldAnimate: forceShouldAnimate,\n        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n      }\n    };\n  });\n\n  var selector = function selector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id !== ownProps.draggableId) {\n        return null;\n      }\n\n      var offset = state.current.client.offset;\n      var dimension = state.dimensions.draggables[ownProps.draggableId];\n      var draggingOver = whatIsDraggedOver(state.impact);\n      var combineWith = getCombineWithFromImpact(state.impact);\n      var forceShouldAnimate = state.forceShouldAnimate;\n      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (completed.result.draggableId !== ownProps.draggableId) {\n        return null;\n      }\n\n      var isClone = ownProps.isClone;\n      var _dimension = state.dimensions.draggables[ownProps.draggableId];\n      var result = completed.result;\n      var mode = result.mode;\n\n      var _draggingOver = whatIsDraggedOverFromResult(result);\n\n      var _combineWith = getCombineWithFromResult(result);\n\n      var duration = state.dropDuration;\n      var dropping = {\n        duration: duration,\n        curve: curves.drop,\n        moveTo: state.newHomeClientOffset,\n        opacity: _combineWith ? combine.opacity.drop : null,\n        scale: _combineWith ? combine.scale.drop : null\n      };\n      return {\n        mapped: {\n          type: 'DRAGGING',\n          offset: state.newHomeClientOffset,\n          dimension: _dimension,\n          dropping: dropping,\n          draggingOver: _draggingOver,\n          combineWith: _combineWith,\n          mode: mode,\n          forceShouldAnimate: null,\n          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)\n        }\n      };\n    }\n\n    return null;\n  };\n\n  return selector;\n}\n\nfunction getSecondarySnapshot(combineTargetFor) {\n  return {\n    isDragging: false,\n    isDropAnimating: false,\n    isClone: false,\n    dropAnimation: null,\n    mode: null,\n    draggingOver: null,\n    combineTargetFor: combineTargetFor,\n    combineWith: null\n  };\n}\n\nvar atRest = {\n  mapped: {\n    type: 'SECONDARY',\n    offset: origin,\n    combineTargetFor: null,\n    shouldAnimateDisplacement: true,\n    snapshot: getSecondarySnapshot(null)\n  }\n};\n\nfunction getSecondarySelector() {\n  var memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(getSecondarySnapshot);\n  var getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (offset, combineTargetFor, shouldAnimateDisplacement) {\n    if (combineTargetFor === void 0) {\n      combineTargetFor = null;\n    }\n\n    return {\n      mapped: {\n        type: 'SECONDARY',\n        offset: offset,\n        combineTargetFor: combineTargetFor,\n        shouldAnimateDisplacement: shouldAnimateDisplacement,\n        snapshot: getMemoizedSnapshot(combineTargetFor)\n      }\n    };\n  });\n\n  var getFallback = function getFallback(combineTargetFor) {\n    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n  };\n\n  var getProps = function getProps(ownId, draggingId, impact, afterCritical) {\n    var visualDisplacement = impact.displaced.visible[ownId];\n    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n    var combine = tryGetCombine(impact);\n    var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n\n    if (!visualDisplacement) {\n      if (!isAfterCriticalInVirtualList) {\n        return getFallback(combineTargetFor);\n      }\n\n      if (impact.displaced.invisible[ownId]) {\n        return null;\n      }\n\n      var change = negate(afterCritical.displacedBy.point);\n\n      var _offset = memoizedOffset(change.x, change.y);\n\n      return getMemoizedProps(_offset, combineTargetFor, true);\n    }\n\n    if (isAfterCriticalInVirtualList) {\n      return getFallback(combineTargetFor);\n    }\n\n    var displaceBy = impact.displacedBy.point;\n    var offset = memoizedOffset(displaceBy.x, displaceBy.y);\n    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n  };\n\n  var selector = function selector(state, ownProps) {\n    if (state.isDragging) {\n      if (state.critical.draggable.id === ownProps.draggableId) {\n        return null;\n      }\n\n      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (completed.result.draggableId === ownProps.draggableId) {\n        return null;\n      }\n\n      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n    }\n\n    return null;\n  };\n\n  return selector;\n}\n\nvar makeMapStateToProps = function makeMapStateToProps() {\n  var draggingSelector = getDraggableSelector();\n  var secondarySelector = getSecondarySelector();\n\n  var selector = function selector(state, ownProps) {\n    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n  };\n\n  return selector;\n};\nvar mapDispatchToProps = {\n  dropAnimationFinished: dropAnimationFinished\n};\nvar ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_1__.connect)(makeMapStateToProps, mapDispatchToProps, null, {\n  context: StoreContext,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Draggable);\n\nfunction PrivateDraggable(props) {\n  var droppableContext = useRequiredContext(DroppableContext);\n  var isUsingCloneFor = droppableContext.isUsingCloneFor;\n\n  if (isUsingCloneFor === props.draggableId && !props.isClone) {\n    return null;\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n  var isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;\n  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, props, {\n    isClone: false,\n    isEnabled: isEnabled,\n    canDragInteractiveElements: canDragInteractiveElements,\n    shouldRespectForcePress: shouldRespectForcePress\n  }));\n}\n\nfunction Droppable(props) {\n  var appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n  !appContext ?  true ? invariant(false, 'Could not find app context') : 0 : void 0;\n  var contextId = appContext.contextId,\n      isMovementAllowed = appContext.isMovementAllowed;\n  var droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var children = props.children,\n      droppableId = props.droppableId,\n      type = props.type,\n      mode = props.mode,\n      direction = props.direction,\n      ignoreContainerClipping = props.ignoreContainerClipping,\n      isDropDisabled = props.isDropDisabled,\n      isCombineEnabled = props.isCombineEnabled,\n      snapshot = props.snapshot,\n      useClone = props.useClone,\n      updateViewportMaxScroll = props.updateViewportMaxScroll,\n      getContainerForClone = props.getContainerForClone;\n  var getDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    return droppableRef.current;\n  }, []);\n  var setDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (value) {\n    droppableRef.current = value;\n  }, []);\n  var getPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    return placeholderRef.current;\n  }, []);\n  var setPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function (value) {\n    placeholderRef.current = value;\n  }, []);\n  useValidation({\n    props: props,\n    getDroppableRef: getDroppableRef,\n    getPlaceholderRef: getPlaceholderRef\n  });\n  var onPlaceholderTransitionEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function () {\n    if (isMovementAllowed()) {\n      updateViewportMaxScroll({\n        maxScroll: getMaxWindowScroll()\n      });\n    }\n  }, [isMovementAllowed, updateViewportMaxScroll]);\n  useDroppablePublisher({\n    droppableId: droppableId,\n    type: type,\n    mode: mode,\n    direction: direction,\n    isDropDisabled: isDropDisabled,\n    isCombineEnabled: isCombineEnabled,\n    ignoreContainerClipping: ignoreContainerClipping,\n    getDroppableRef: getDroppableRef\n  });\n  var placeholder = react__WEBPACK_IMPORTED_MODULE_0__.createElement(AnimateInOut, {\n    on: props.placeholder,\n    shouldAnimate: props.shouldAnimatePlaceholder\n  }, function (_ref) {\n    var onClose = _ref.onClose,\n        data = _ref.data,\n        animate = _ref.animate;\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Placeholder$1, {\n      placeholder: data,\n      onClose: onClose,\n      innerRef: setPlaceholderRef,\n      animate: animate,\n      contextId: contextId,\n      onTransitionEnd: onPlaceholderTransitionEnd\n    });\n  });\n  var provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      innerRef: setDroppableRef,\n      placeholder: placeholder,\n      droppableProps: {\n        'data-rbd-droppable-id': droppableId,\n        'data-rbd-droppable-context-id': contextId\n      }\n    };\n  }, [contextId, droppableId, placeholder, setDroppableRef]);\n  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n  var droppableContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function () {\n    return {\n      droppableId: droppableId,\n      type: type,\n      isUsingCloneFor: isUsingCloneFor\n    };\n  }, [droppableId, isUsingCloneFor, type]);\n\n  function getClone() {\n    if (!useClone) {\n      return null;\n    }\n\n    var dragging = useClone.dragging,\n        render = useClone.render;\n    var node = react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrivateDraggable, {\n      draggableId: dragging.draggableId,\n      index: dragging.source.index,\n      isClone: true,\n      isEnabled: true,\n      shouldRespectForcePress: false,\n      canDragInteractiveElements: true\n    }, function (draggableProvided, draggableSnapshot) {\n      return render(draggableProvided, draggableSnapshot, dragging);\n    });\n    return react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(node, getContainerForClone());\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(DroppableContext.Provider, {\n    value: droppableContext\n  }, children(provided, snapshot), getClone());\n}\n\nvar isMatchingType = function isMatchingType(type, critical) {\n  return type === critical.droppable.type;\n};\n\nvar getDraggable = function getDraggable(critical, dimensions) {\n  return dimensions.draggables[critical.draggable.id];\n};\n\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\n  var idleWithAnimation = {\n    placeholder: null,\n    shouldAnimatePlaceholder: true,\n    snapshot: {\n      isDraggingOver: false,\n      draggingOverWith: null,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: false\n    },\n    useClone: null\n  };\n\n  var idleWithoutAnimation = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__.default)({}, idleWithAnimation, {\n    shouldAnimatePlaceholder: false\n  });\n\n  var getDraggableRubric = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (descriptor) {\n    return {\n      draggableId: descriptor.id,\n      type: descriptor.type,\n      source: {\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n      }\n    };\n  });\n  var getMapProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__.default)(function (id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {\n    var draggableId = dragging.descriptor.id;\n    var isHome = dragging.descriptor.droppableId === id;\n\n    if (isHome) {\n      var useClone = renderClone ? {\n        render: renderClone,\n        dragging: getDraggableRubric(dragging.descriptor)\n      } : null;\n      var _snapshot = {\n        isDraggingOver: isDraggingOverForConsumer,\n        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n        draggingFromThisWith: draggableId,\n        isUsingPlaceholder: true\n      };\n      return {\n        placeholder: dragging.placeholder,\n        shouldAnimatePlaceholder: false,\n        snapshot: _snapshot,\n        useClone: useClone\n      };\n    }\n\n    if (!isEnabled) {\n      return idleWithoutAnimation;\n    }\n\n    if (!isDraggingOverForImpact) {\n      return idleWithAnimation;\n    }\n\n    var snapshot = {\n      isDraggingOver: isDraggingOverForConsumer,\n      draggingOverWith: draggableId,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: true\n    };\n    return {\n      placeholder: dragging.placeholder,\n      shouldAnimatePlaceholder: true,\n      snapshot: snapshot,\n      useClone: null\n    };\n  });\n\n  var selector = function selector(state, ownProps) {\n    var id = ownProps.droppableId;\n    var type = ownProps.type;\n    var isEnabled = !ownProps.isDropDisabled;\n    var renderClone = ownProps.renderClone;\n\n    if (state.isDragging) {\n      var critical = state.critical;\n\n      if (!isMatchingType(type, critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var dragging = getDraggable(critical, state.dimensions);\n      var isDraggingOver = whatIsDraggedOver(state.impact) === id;\n      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n    }\n\n    if (state.phase === 'DROP_ANIMATING') {\n      var completed = state.completed;\n\n      if (!isMatchingType(type, completed.critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var _dragging = getDraggable(completed.critical, state.dimensions);\n\n      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);\n    }\n\n    if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {\n      var _completed = state.completed;\n\n      if (!isMatchingType(type, _completed.critical)) {\n        return idleWithoutAnimation;\n      }\n\n      var wasOver = whatIsDraggedOver(_completed.impact) === id;\n      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === 'COMBINE');\n      var isHome = _completed.critical.droppable.id === id;\n\n      if (wasOver) {\n        return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n      }\n\n      if (isHome) {\n        return idleWithAnimation;\n      }\n\n      return idleWithoutAnimation;\n    }\n\n    return idleWithoutAnimation;\n  };\n\n  return selector;\n};\nvar mapDispatchToProps$1 = {\n  updateViewportMaxScroll: updateViewportMaxScroll\n};\n\nfunction getBody() {\n  !document.body ?  true ? invariant(false, 'document.body is not ready') : 0 : void 0;\n  return document.body;\n}\n\nvar defaultProps = {\n  mode: 'standard',\n  type: 'DEFAULT',\n  direction: 'vertical',\n  isDropDisabled: false,\n  isCombineEnabled: false,\n  ignoreContainerClipping: false,\n  renderClone: null,\n  getContainerForClone: getBody\n};\nvar ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_1__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n  context: StoreContext,\n  pure: true,\n  areStatePropsEqual: isStrictEqual\n})(Droppable);\nConnectedDroppable.defaultProps = defaultProps;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlci1jb21pYy1zbGljZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtYmVhdXRpZnVsLWRuZC9kaXN0L3JlYWN0LWJlYXV0aWZ1bC1kbmQuZXNtLmpzPzllMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDbEI7QUFDWjtBQUN5QztBQUNuRDtBQUNJO0FBQ2lEO0FBQ2hFO0FBQ047QUFDRTs7QUFFakMsbUJBQW1CLGFBQW9CO0FBQ3ZDLDJCQUEyQixHQUFHO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Qsa0JBQWtCLG1CQUFtQix1Q0FBdUM7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVMsMkVBQVEsR0FBRyxZQUFZO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHFCQUFxQixhQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLGlGQUFjOztBQUVoQjtBQUNBOztBQUVBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsS0FBcUMsa0tBQWtLLENBQU07QUFDck47O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLENBQUMsNENBQWU7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsc0RBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQXFDLG1GQUFtRixDQUFnQjs7QUFFbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQyxzQkFBc0IsQ0FBZ0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLDJCQUEyQixxREFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHFEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUgsa0JBQWtCLDJFQUFRLEdBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVLEtBQXFDLGdFQUFnRSxDQUFnQjtBQUMvSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQscUJBQXFCLG9EQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDJFQUFRLEdBQUc7QUFDcEIsWUFBWSwyRUFBUSxHQUFHO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLEtBQXFDLHVFQUF1RSxDQUFnQjtBQUNqSyx3Q0FBd0MsS0FBcUMsMEZBQTBGLENBQWdCO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsV0FBVywyRUFBUSxHQUFHO0FBQ3RCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMkVBQVEsR0FBRztBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBcUMsb0ZBQW9GLENBQWdCO0FBQ3BKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsV0FBVywyRUFBUSxHQUFHO0FBQ3RCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esa0JBQWtCLEtBQXFDLDhHQUE4RyxDQUFnQjtBQUNyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUywyRUFBUSxHQUFHO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxTQUFTLHNEQUFPO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsU0FBUywyRUFBUSxHQUFHLDZCQUE2QjtBQUNqRCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDJFQUFRO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxlQUFlLDJFQUFRLEdBQUc7QUFDMUI7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Szs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQXFDLDZGQUE2RixDQUFnQjs7QUFFeEwsbUJBQW1CLDJFQUFRO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQXFDLHVFQUF1RSxDQUFnQjtBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFxQyx3TEFBd0wsQ0FBTTtBQUN2TztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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b0JBQW9CLG9EQUFVO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixLQUFxQyxvREFBb0QsQ0FBZ0I7QUFDNUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRThHIiwiZmlsZSI6Im5nUUkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgeyBjcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZSQxLCBhcHBseU1pZGRsZXdhcmUsIGNvbXBvc2UsIGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IFByb3ZpZGVyLCBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICd1c2UtbWVtby1vbmUnO1xuaW1wb3J0IHsgZ2V0UmVjdCwgZXhwYW5kLCBvZmZzZXQsIHdpdGhTY3JvbGwsIGdldEJveCwgY3JlYXRlQm94LCBjYWxjdWxhdGVCb3ggfSBmcm9tICdjc3MtYm94LW1vZGVsJztcbmltcG9ydCBtZW1vaXplT25lIGZyb20gJ21lbW9pemUtb25lJztcbmltcG9ydCByYWZTY2hkIGZyb20gJ3JhZi1zY2hkJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbnZhciBzcGFjZXNBbmRUYWJzID0gL1sgXFx0XXsyLH0vZztcbnZhciBsaW5lU3RhcnRXaXRoU3BhY2VzID0gL15bIFxcdF0qL2dtO1xuXG52YXIgY2xlYW4gPSBmdW5jdGlvbiBjbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShzcGFjZXNBbmRUYWJzLCAnICcpLnJlcGxhY2UobGluZVN0YXJ0V2l0aFNwYWNlcywgJycpLnRyaW0oKTtcbn07XG5cbnZhciBnZXREZXZNZXNzYWdlID0gZnVuY3Rpb24gZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiBjbGVhbihcIlxcbiAgJWNyZWFjdC1iZWF1dGlmdWwtZG5kXFxuXFxuICAlY1wiICsgY2xlYW4obWVzc2FnZSkgKyBcIlxcblxcbiAgJWNcXHVEODNEXFx1REM3N1xcdTIwMEQgVGhpcyBpcyBhIGRldmVsb3BtZW50IG9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxcblwiKTtcbn07XG5cbnZhciBnZXRGb3JtYXR0ZWRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiBbZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSwgJ2NvbG9yOiAjMDBDNTg0OyBmb250LXNpemU6IDEuMmVtOyBmb250LXdlaWdodDogYm9sZDsnLCAnbGluZS1oZWlnaHQ6IDEuNScsICdjb2xvcjogIzcyMzg3NDsnXTtcbn07XG52YXIgaXNEaXNhYmxlZEZsYWcgPSAnX19yZWFjdC1iZWF1dGlmdWwtZG5kLWRpc2FibGUtZGV2LXdhcm5pbmdzJztcbmZ1bmN0aW9uIGxvZyh0eXBlLCBtZXNzYWdlKSB7XG4gIHZhciBfY29uc29sZTtcblxuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1tpc0Rpc2FibGVkRmxhZ10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAoX2NvbnNvbGUgPSBjb25zb2xlKVt0eXBlXS5hcHBseShfY29uc29sZSwgZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG59XG52YXIgd2FybmluZyA9IGxvZy5iaW5kKG51bGwsICd3YXJuJyk7XG52YXIgZXJyb3IgPSBsb2cuYmluZChudWxsLCAnZXJyb3InKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMoc2hhcmVkLCBmcm9tQmluZGluZykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHNoYXJlZCwge30sIGZyb21CaW5kaW5nKTtcbn1cblxuZnVuY3Rpb24gYmluZEV2ZW50cyhlbCwgYmluZGluZ3MsIHNoYXJlZE9wdGlvbnMpIHtcbiAgdmFyIHVuYmluZGluZ3MgPSBiaW5kaW5ncy5tYXAoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGdldE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgYmluZGluZy5vcHRpb25zKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGJpbmRpbmcuZXZlbnROYW1lLCBiaW5kaW5nLmZuLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmV2ZW50TmFtZSwgYmluZGluZy5mbiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiB1bmJpbmRBbGwoKSB7XG4gICAgdW5iaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uICh1bmJpbmQpIHtcbiAgICAgIHVuYmluZCgpO1xuICAgIH0pO1xuICB9O1xufVxuXG52YXIgaXNQcm9kdWN0aW9uJDEgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xudmFyIHByZWZpeCA9ICdJbnZhcmlhbnQgZmFpbGVkJztcbmZ1bmN0aW9uIFJiZEludmFyaWFudChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cblJiZEludmFyaWFudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbn07XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc1Byb2R1Y3Rpb24kMSkge1xuICAgIHRocm93IG5ldyBSYmRJbnZhcmlhbnQocHJlZml4KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmJkSW52YXJpYW50KHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8ICcnKSk7XG4gIH1cbn1cblxudmFyIEVycm9yQm91bmRhcnkgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFcnJvckJvdW5kYXJ5LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgX3RoaXMudW5iaW5kID0gbm9vcDtcblxuICAgIF90aGlzLm9uV2luZG93RXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSBfdGhpcy5nZXRDYWxsYmFja3MoKTtcblxuICAgICAgaWYgKGNhbGxiYWNrcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgY2FsbGJhY2tzLnRyeUFib3J0KCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICAgIEFuIGVycm9yIHdhcyBjYXVnaHQgYnkgb3VyIHdpbmRvdyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHdoaWxlIGEgZHJhZyB3YXMgb2NjdXJyaW5nLlxcbiAgICAgICAgVGhlIGFjdGl2ZSBkcmFnIGhhcyBiZWVuIGFib3J0ZWQuXFxuICAgICAgXCIpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyID0gZXZlbnQuZXJyb3I7XG5cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBSYmRJbnZhcmlhbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLmNhbGxiYWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIEFwcENhbGxiYWNrcyBpbiA8RXJyb3JCb3VuZGFyeS8+Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5jYWxsYmFja3M7XG4gICAgfTtcblxuICAgIF90aGlzLnNldENhbGxiYWNrcyA9IGZ1bmN0aW9uIChjYWxsYmFja3MpIHtcbiAgICAgIF90aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVycm9yQm91bmRhcnkucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICBldmVudE5hbWU6ICdlcnJvcicsXG4gICAgICBmbjogdGhpcy5vbldpbmRvd0Vycm9yXG4gICAgfV0pO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5iaW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHt9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnNldENhbGxiYWNrcyk7XG4gIH07XG5cbiAgcmV0dXJuIEVycm9yQm91bmRhcnk7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbnZhciBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgPSBcIlxcbiAgUHJlc3Mgc3BhY2UgYmFyIHRvIHN0YXJ0IGEgZHJhZy5cXG4gIFdoZW4gZHJhZ2dpbmcgeW91IGNhbiB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgaXRlbSBhcm91bmQgYW5kIGVzY2FwZSB0byBjYW5jZWwuXFxuICBTb21lIHNjcmVlbiByZWFkZXJzIG1heSByZXF1aXJlIHlvdSB0byBiZSBpbiBmb2N1cyBtb2RlIG9yIHRvIHVzZSB5b3VyIHBhc3MgdGhyb3VnaCBrZXlcXG5cIjtcblxudmFyIHBvc2l0aW9uID0gZnVuY3Rpb24gcG9zaXRpb24oaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ICsgMTtcbn07XG5cbnZhciBvbkRyYWdTdGFydCA9IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KHN0YXJ0KSB7XG4gIHJldHVybiBcIlxcbiAgWW91IGhhdmUgbGlmdGVkIGFuIGl0ZW0gaW4gcG9zaXRpb24gXCIgKyBwb3NpdGlvbihzdGFydC5zb3VyY2UuaW5kZXgpICsgXCJcXG5cIjtcbn07XG5cbnZhciB3aXRoTG9jYXRpb24gPSBmdW5jdGlvbiB3aXRoTG9jYXRpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICB2YXIgaXNJbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgdmFyIHN0YXJ0UG9zaXRpb24gPSBwb3NpdGlvbihzb3VyY2UuaW5kZXgpO1xuICB2YXIgZW5kUG9zaXRpb24gPSBwb3NpdGlvbihkZXN0aW5hdGlvbi5pbmRleCk7XG5cbiAgaWYgKGlzSW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBcIlxcbiAgICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gXCIgKyBzdGFydFBvc2l0aW9uICsgXCJcXG4gICAgICB0byBwb3NpdGlvbiBcIiArIGVuZFBvc2l0aW9uICsgXCJcXG4gICAgXCI7XG4gIH1cblxuICByZXR1cm4gXCJcXG4gICAgWW91IGhhdmUgbW92ZWQgdGhlIGl0ZW0gZnJvbSBwb3NpdGlvbiBcIiArIHN0YXJ0UG9zaXRpb24gKyBcIlxcbiAgICBpbiBsaXN0IFwiICsgc291cmNlLmRyb3BwYWJsZUlkICsgXCJcXG4gICAgdG8gbGlzdCBcIiArIGRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkICsgXCJcXG4gICAgaW4gcG9zaXRpb24gXCIgKyBlbmRQb3NpdGlvbiArIFwiXFxuICBcIjtcbn07XG5cbnZhciB3aXRoQ29tYmluZSA9IGZ1bmN0aW9uIHdpdGhDb21iaW5lKGlkLCBzb3VyY2UsIGNvbWJpbmUpIHtcbiAgdmFyIGluSG9tZUxpc3QgPSBzb3VyY2UuZHJvcHBhYmxlSWQgPT09IGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG5cbiAgaWYgKGluSG9tZUxpc3QpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgICBUaGUgaXRlbSBcIiArIGlkICsgXCJcXG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoIFwiICsgY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgfVxuXG4gIHJldHVybiBcIlxcbiAgICAgIFRoZSBpdGVtIFwiICsgaWQgKyBcIlxcbiAgICAgIGluIGxpc3QgXCIgKyBzb3VyY2UuZHJvcHBhYmxlSWQgKyBcIlxcbiAgICAgIGhhcyBiZWVuIGNvbWJpbmVkIHdpdGggXCIgKyBjb21iaW5lLmRyYWdnYWJsZUlkICsgXCJcXG4gICAgICBpbiBsaXN0IFwiICsgY29tYmluZS5kcm9wcGFibGVJZCArIFwiXFxuICAgIFwiO1xufTtcblxudmFyIG9uRHJhZ1VwZGF0ZSA9IGZ1bmN0aW9uIG9uRHJhZ1VwZGF0ZSh1cGRhdGUpIHtcbiAgdmFyIGxvY2F0aW9uID0gdXBkYXRlLmRlc3RpbmF0aW9uO1xuXG4gIGlmIChsb2NhdGlvbikge1xuICAgIHJldHVybiB3aXRoTG9jYXRpb24odXBkYXRlLnNvdXJjZSwgbG9jYXRpb24pO1xuICB9XG5cbiAgdmFyIGNvbWJpbmUgPSB1cGRhdGUuY29tYmluZTtcblxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiB3aXRoQ29tYmluZSh1cGRhdGUuZHJhZ2dhYmxlSWQsIHVwZGF0ZS5zb3VyY2UsIGNvbWJpbmUpO1xuICB9XG5cbiAgcmV0dXJuICdZb3UgYXJlIG92ZXIgYW4gYXJlYSB0aGF0IGNhbm5vdCBiZSBkcm9wcGVkIG9uJztcbn07XG5cbnZhciByZXR1cm5lZFRvU3RhcnQgPSBmdW5jdGlvbiByZXR1cm5lZFRvU3RhcnQoc291cmNlKSB7XG4gIHJldHVybiBcIlxcbiAgVGhlIGl0ZW0gaGFzIHJldHVybmVkIHRvIGl0cyBzdGFydGluZyBwb3NpdGlvblxcbiAgb2YgXCIgKyBwb3NpdGlvbihzb3VyY2UuaW5kZXgpICsgXCJcXG5cIjtcbn07XG5cbnZhciBvbkRyYWdFbmQgPSBmdW5jdGlvbiBvbkRyYWdFbmQocmVzdWx0KSB7XG4gIGlmIChyZXN1bHQucmVhc29uID09PSAnQ0FOQ0VMJykge1xuICAgIHJldHVybiBcIlxcbiAgICAgIE1vdmVtZW50IGNhbmNlbGxlZC5cXG4gICAgICBcIiArIHJldHVybmVkVG9TdGFydChyZXN1bHQuc291cmNlKSArIFwiXFxuICAgIFwiO1xuICB9XG5cbiAgdmFyIGxvY2F0aW9uID0gcmVzdWx0LmRlc3RpbmF0aW9uO1xuICB2YXIgY29tYmluZSA9IHJlc3VsdC5jb21iaW5lO1xuXG4gIGlmIChsb2NhdGlvbikge1xuICAgIHJldHVybiBcIlxcbiAgICAgIFlvdSBoYXZlIGRyb3BwZWQgdGhlIGl0ZW0uXFxuICAgICAgXCIgKyB3aXRoTG9jYXRpb24ocmVzdWx0LnNvdXJjZSwgbG9jYXRpb24pICsgXCJcXG4gICAgXCI7XG4gIH1cblxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBcIlxcbiAgICAgIFlvdSBoYXZlIGRyb3BwZWQgdGhlIGl0ZW0uXFxuICAgICAgXCIgKyB3aXRoQ29tYmluZShyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5zb3VyY2UsIGNvbWJpbmUpICsgXCJcXG4gICAgXCI7XG4gIH1cblxuICByZXR1cm4gXCJcXG4gICAgVGhlIGl0ZW0gaGFzIGJlZW4gZHJvcHBlZCB3aGlsZSBub3Qgb3ZlciBhIGRyb3AgYXJlYS5cXG4gICAgXCIgKyByZXR1cm5lZFRvU3RhcnQocmVzdWx0LnNvdXJjZSkgKyBcIlxcbiAgXCI7XG59O1xuXG52YXIgcHJlc2V0ID0ge1xuICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyxcbiAgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdVcGRhdGU6IG9uRHJhZ1VwZGF0ZSxcbiAgb25EcmFnRW5kOiBvbkRyYWdFbmRcbn07XG5cbnZhciBvcmlnaW4gPSB7XG4gIHg6IDAsXG4gIHk6IDBcbn07XG52YXIgYWRkID0gZnVuY3Rpb24gYWRkKHBvaW50MSwgcG9pbnQyKSB7XG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQxLnggKyBwb2ludDIueCxcbiAgICB5OiBwb2ludDEueSArIHBvaW50Mi55XG4gIH07XG59O1xudmFyIHN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QocG9pbnQxLCBwb2ludDIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludDEueCAtIHBvaW50Mi54LFxuICAgIHk6IHBvaW50MS55IC0gcG9pbnQyLnlcbiAgfTtcbn07XG52YXIgaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwocG9pbnQxLCBwb2ludDIpIHtcbiAgcmV0dXJuIHBvaW50MS54ID09PSBwb2ludDIueCAmJiBwb2ludDEueSA9PT0gcG9pbnQyLnk7XG59O1xudmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZShwb2ludCkge1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50LnggIT09IDAgPyAtcG9pbnQueCA6IDAsXG4gICAgeTogcG9pbnQueSAhPT0gMCA/IC1wb2ludC55IDogMFxuICB9O1xufTtcbnZhciBwYXRjaCA9IGZ1bmN0aW9uIHBhdGNoKGxpbmUsIHZhbHVlLCBvdGhlclZhbHVlKSB7XG4gIHZhciBfcmVmO1xuXG4gIGlmIChvdGhlclZhbHVlID09PSB2b2lkIDApIHtcbiAgICBvdGhlclZhbHVlID0gMDtcbiAgfVxuXG4gIHJldHVybiBfcmVmID0ge30sIF9yZWZbbGluZV0gPSB2YWx1ZSwgX3JlZltsaW5lID09PSAneCcgPyAneScgOiAneCddID0gb3RoZXJWYWx1ZSwgX3JlZjtcbn07XG52YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZShwb2ludDEsIHBvaW50Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50Mi54IC0gcG9pbnQxLngsIDIpICsgTWF0aC5wb3cocG9pbnQyLnkgLSBwb2ludDEueSwgMikpO1xufTtcbnZhciBjbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdCh0YXJnZXQsIHBvaW50cykge1xuICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gZGlzdGFuY2UodGFyZ2V0LCBwb2ludCk7XG4gIH0pKTtcbn07XG52YXIgYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGZuKHBvaW50LngpLFxuICAgICAgeTogZm4ocG9pbnQueSlcbiAgICB9O1xuICB9O1xufTtcblxudmFyIGV4ZWN1dGVDbGlwID0gKGZ1bmN0aW9uIChmcmFtZSwgc3ViamVjdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0UmVjdCh7XG4gICAgdG9wOiBNYXRoLm1heChzdWJqZWN0LnRvcCwgZnJhbWUudG9wKSxcbiAgICByaWdodDogTWF0aC5taW4oc3ViamVjdC5yaWdodCwgZnJhbWUucmlnaHQpLFxuICAgIGJvdHRvbTogTWF0aC5taW4oc3ViamVjdC5ib3R0b20sIGZyYW1lLmJvdHRvbSksXG4gICAgbGVmdDogTWF0aC5tYXgoc3ViamVjdC5sZWZ0LCBmcmFtZS5sZWZ0KVxuICB9KTtcblxuICBpZiAocmVzdWx0LndpZHRoIDw9IDAgfHwgcmVzdWx0LmhlaWdodCA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbnZhciBvZmZzZXRCeVBvc2l0aW9uID0gZnVuY3Rpb24gb2Zmc2V0QnlQb3NpdGlvbihzcGFjaW5nLCBwb2ludCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogc3BhY2luZy50b3AgKyBwb2ludC55LFxuICAgIGxlZnQ6IHNwYWNpbmcubGVmdCArIHBvaW50LngsXG4gICAgYm90dG9tOiBzcGFjaW5nLmJvdHRvbSArIHBvaW50LnksXG4gICAgcmlnaHQ6IHNwYWNpbmcucmlnaHQgKyBwb2ludC54XG4gIH07XG59O1xudmFyIGdldENvcm5lcnMgPSBmdW5jdGlvbiBnZXRDb3JuZXJzKHNwYWNpbmcpIHtcbiAgcmV0dXJuIFt7XG4gICAgeDogc3BhY2luZy5sZWZ0LFxuICAgIHk6IHNwYWNpbmcudG9wXG4gIH0sIHtcbiAgICB4OiBzcGFjaW5nLnJpZ2h0LFxuICAgIHk6IHNwYWNpbmcudG9wXG4gIH0sIHtcbiAgICB4OiBzcGFjaW5nLmxlZnQsXG4gICAgeTogc3BhY2luZy5ib3R0b21cbiAgfSwge1xuICAgIHg6IHNwYWNpbmcucmlnaHQsXG4gICAgeTogc3BhY2luZy5ib3R0b21cbiAgfV07XG59O1xudmFyIG5vU3BhY2luZyA9IHtcbiAgdG9wOiAwLFxuICByaWdodDogMCxcbiAgYm90dG9tOiAwLFxuICBsZWZ0OiAwXG59O1xuXG52YXIgc2Nyb2xsID0gZnVuY3Rpb24gc2Nyb2xsKHRhcmdldCwgZnJhbWUpIHtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59O1xuXG52YXIgaW5jcmVhc2UgPSBmdW5jdGlvbiBpbmNyZWFzZSh0YXJnZXQsIGF4aXMsIHdpdGhQbGFjZWhvbGRlcikge1xuICBpZiAod2l0aFBsYWNlaG9sZGVyICYmIHdpdGhQbGFjZWhvbGRlci5pbmNyZWFzZWRCeSkge1xuICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHRhcmdldCwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbYXhpcy5lbmRdID0gdGFyZ2V0W2F4aXMuZW5kXSArIHdpdGhQbGFjZWhvbGRlci5pbmNyZWFzZWRCeVtheGlzLmxpbmVdLCBfZXh0ZW5kczIpKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgY2xpcCA9IGZ1bmN0aW9uIGNsaXAodGFyZ2V0LCBmcmFtZSkge1xuICBpZiAoZnJhbWUgJiYgZnJhbWUuc2hvdWxkQ2xpcFN1YmplY3QpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUNsaXAoZnJhbWUucGFnZU1hcmdpbkJveCwgdGFyZ2V0KTtcbiAgfVxuXG4gIHJldHVybiBnZXRSZWN0KHRhcmdldCk7XG59O1xuXG52YXIgZ2V0U3ViamVjdCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcGFnZSA9IF9yZWYucGFnZSxcbiAgICAgIHdpdGhQbGFjZWhvbGRlciA9IF9yZWYud2l0aFBsYWNlaG9sZGVyLFxuICAgICAgYXhpcyA9IF9yZWYuYXhpcyxcbiAgICAgIGZyYW1lID0gX3JlZi5mcmFtZTtcbiAgdmFyIHNjcm9sbGVkID0gc2Nyb2xsKHBhZ2UubWFyZ2luQm94LCBmcmFtZSk7XG4gIHZhciBpbmNyZWFzZWQgPSBpbmNyZWFzZShzY3JvbGxlZCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKTtcbiAgdmFyIGNsaXBwZWQgPSBjbGlwKGluY3JlYXNlZCwgZnJhbWUpO1xuICByZXR1cm4ge1xuICAgIHBhZ2U6IHBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiB3aXRoUGxhY2Vob2xkZXIsXG4gICAgYWN0aXZlOiBjbGlwcGVkXG4gIH07XG59KTtcblxudmFyIHNjcm9sbERyb3BwYWJsZSA9IChmdW5jdGlvbiAoZHJvcHBhYmxlLCBuZXdTY3JvbGwpIHtcbiAgIWRyb3BwYWJsZS5mcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgc2Nyb2xsYWJsZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgdmFyIHNjcm9sbERpZmYgPSBzdWJ0cmFjdChuZXdTY3JvbGwsIHNjcm9sbGFibGUuc2Nyb2xsLmluaXRpYWwpO1xuICB2YXIgc2Nyb2xsRGlzcGxhY2VtZW50ID0gbmVnYXRlKHNjcm9sbERpZmYpO1xuXG4gIHZhciBmcmFtZSA9IF9leHRlbmRzKHt9LCBzY3JvbGxhYmxlLCB7XG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsLFxuICAgICAgY3VycmVudDogbmV3U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogc2Nyb2xsRGlmZixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBzY3JvbGxEaXNwbGFjZW1lbnRcbiAgICAgIH0sXG4gICAgICBtYXg6IHNjcm9sbGFibGUuc2Nyb2xsLm1heFxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBmcmFtZVxuICB9KTtcblxuICB2YXIgcmVzdWx0ID0gX2V4dGVuZHMoe30sIGRyb3BwYWJsZSwge1xuICAgIGZyYW1lOiBmcmFtZSxcbiAgICBzdWJqZWN0OiBzdWJqZWN0XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHZhbHVlcyhtYXApIHtcbiAgaWYgKE9iamVjdC52YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhtYXApO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWFwW2tleV07XG4gIH0pO1xufVxuZnVuY3Rpb24gZmluZEluZGV4KGxpc3QsIHByZWRpY2F0ZSkge1xuICBpZiAobGlzdC5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdC5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVkaWNhdGUobGlzdFtpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZpbmQobGlzdCwgcHJlZGljYXRlKSB7XG4gIGlmIChsaXN0LmZpbmQpIHtcbiAgICByZXR1cm4gbGlzdC5maW5kKHByZWRpY2F0ZSk7XG4gIH1cblxuICB2YXIgaW5kZXggPSBmaW5kSW5kZXgobGlzdCwgcHJlZGljYXRlKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIGxpc3RbaW5kZXhdO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCk7XG59XG5cbnZhciB0b0Ryb3BwYWJsZU1hcCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKGRyb3BwYWJsZXMpIHtcbiAgcmV0dXJuIGRyb3BwYWJsZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgIHByZXZpb3VzW2N1cnJlbnQuZGVzY3JpcHRvci5pZF0gPSBjdXJyZW50O1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfSwge30pO1xufSk7XG52YXIgdG9EcmFnZ2FibGVNYXAgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChkcmFnZ2FibGVzKSB7XG4gIHJldHVybiBkcmFnZ2FibGVzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBwcmV2aW91c1tjdXJyZW50LmRlc2NyaXB0b3IuaWRdID0gY3VycmVudDtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH0sIHt9KTtcbn0pO1xudmFyIHRvRHJvcHBhYmxlTGlzdCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKGRyb3BwYWJsZXMpIHtcbiAgcmV0dXJuIHZhbHVlcyhkcm9wcGFibGVzKTtcbn0pO1xudmFyIHRvRHJhZ2dhYmxlTGlzdCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIHZhbHVlcyhkcmFnZ2FibGVzKTtcbn0pO1xuXG52YXIgZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZSA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKGRyb3BwYWJsZUlkLCBkcmFnZ2FibGVzKSB7XG4gIHZhciByZXN1bHQgPSB0b0RyYWdnYWJsZUxpc3QoZHJhZ2dhYmxlcykuZmlsdGVyKGZ1bmN0aW9uIChkcmFnZ2FibGUpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlSWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KSB7XG4gIGlmIChpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiBpbXBhY3QuYXQuZGVzdGluYXRpb247XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRyeUdldENvbWJpbmUoaW1wYWN0KSB7XG4gIGlmIChpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJykge1xuICAgIHJldHVybiBpbXBhY3QuYXQuY29tYmluZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChyZW1vdmUsIGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uZGVzY3JpcHRvci5pZCAhPT0gcmVtb3ZlLmRlc2NyaXB0b3IuaWQ7XG4gIH0pO1xufSk7XG5cbnZhciBtb3ZlVG9OZXh0Q29tYmluZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaXNNb3ZpbmdGb3J3YXJkID0gX3JlZi5pc01vdmluZ0ZvcndhcmQsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIHByZXZpb3VzSW1wYWN0ID0gX3JlZi5wcmV2aW91c0ltcGFjdDtcblxuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsb2NhdGlvbiA9IHRyeUdldERlc3RpbmF0aW9uKHByZXZpb3VzSW1wYWN0KTtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbXBhY3QodGFyZ2V0KSB7XG4gICAgdmFyIGF0ID0ge1xuICAgICAgdHlwZTogJ0NPTUJJTkUnLFxuICAgICAgY29tYmluZToge1xuICAgICAgICBkcmFnZ2FibGVJZDogdGFyZ2V0LFxuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwcmV2aW91c0ltcGFjdCwge1xuICAgICAgYXQ6IGF0XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYWxsID0gcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLmFsbDtcbiAgdmFyIGNsb3Nlc3RJZCA9IGFsbC5sZW5ndGggPyBhbGxbMF0gOiBudWxsO1xuXG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY2xvc2VzdElkID8gZ2V0SW1wYWN0KGNsb3Nlc3RJZCkgOiBudWxsO1xuICB9XG5cbiAgdmFyIHdpdGhvdXREcmFnZ2FibGUgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcblxuICBpZiAoIWNsb3Nlc3RJZCkge1xuICAgIGlmICghd2l0aG91dERyYWdnYWJsZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gd2l0aG91dERyYWdnYWJsZVt3aXRob3V0RHJhZ2dhYmxlLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBnZXRJbXBhY3QobGFzdC5kZXNjcmlwdG9yLmlkKTtcbiAgfVxuXG4gIHZhciBpbmRleE9mQ2xvc2VzdCA9IGZpbmRJbmRleCh3aXRob3V0RHJhZ2dhYmxlLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLmRlc2NyaXB0b3IuaWQgPT09IGNsb3Nlc3RJZDtcbiAgfSk7XG4gICEoaW5kZXhPZkNsb3Nlc3QgIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIGRpc3BsYWNlZCBpdGVtIGluIHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIHByb3Bvc2VkSW5kZXggPSBpbmRleE9mQ2xvc2VzdCAtIDE7XG5cbiAgaWYgKHByb3Bvc2VkSW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYmVmb3JlID0gd2l0aG91dERyYWdnYWJsZVtwcm9wb3NlZEluZGV4XTtcbiAgcmV0dXJuIGdldEltcGFjdChiZWZvcmUuZGVzY3JpcHRvci5pZCk7XG59KTtcblxudmFyIGlzSG9tZU9mID0gKGZ1bmN0aW9uIChkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKSB7XG4gIHJldHVybiBkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZCA9PT0gZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZDtcbn0pO1xuXG52YXIgbm9EaXNwbGFjZWRCeSA9IHtcbiAgcG9pbnQ6IG9yaWdpbixcbiAgdmFsdWU6IDBcbn07XG52YXIgZW1wdHlHcm91cHMgPSB7XG4gIGludmlzaWJsZToge30sXG4gIHZpc2libGU6IHt9LFxuICBhbGw6IFtdXG59O1xudmFyIG5vSW1wYWN0ID0ge1xuICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgYXQ6IG51bGxcbn07XG5cbnZhciBpc1dpdGhpbiA9IChmdW5jdGlvbiAobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGxvd2VyQm91bmQgPD0gdmFsdWUgJiYgdmFsdWUgPD0gdXBwZXJCb3VuZDtcbiAgfTtcbn0pO1xuXG52YXIgaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gKGZ1bmN0aW9uIChmcmFtZSkge1xuICB2YXIgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgdmFyIGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgdmFyIGlzQ29udGFpbmVkID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuXG4gICAgaWYgKGlzQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApIHx8IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIHZhciBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkgPSBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSB8fCBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgdmFyIGlzUGFydGlhbGx5Q29udGFpbmVkID0gaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHk7XG5cbiAgICBpZiAoaXNQYXJ0aWFsbHlDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc0JpZ2dlclZlcnRpY2FsbHkgPSBzdWJqZWN0LnRvcCA8IGZyYW1lLnRvcCAmJiBzdWJqZWN0LmJvdHRvbSA+IGZyYW1lLmJvdHRvbTtcbiAgICB2YXIgaXNCaWdnZXJIb3Jpem9udGFsbHkgPSBzdWJqZWN0LmxlZnQgPCBmcmFtZS5sZWZ0ICYmIHN1YmplY3QucmlnaHQgPiBmcmFtZS5yaWdodDtcbiAgICB2YXIgaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNCaWdnZXJIb3Jpem9udGFsbHk7XG5cbiAgICBpZiAoaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1RhcmdldEJpZ2dlck9uT25lQXhpcyA9IGlzQmlnZ2VyVmVydGljYWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkgfHwgaXNCaWdnZXJIb3Jpem9udGFsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseTtcbiAgICByZXR1cm4gaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXM7XG4gIH07XG59KTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWUgPSAoZnVuY3Rpb24gKGZyYW1lKSB7XG4gIHZhciBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICB2YXIgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICB2YXIgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgcmV0dXJuIGlzQ29udGFpbmVkO1xuICB9O1xufSk7XG5cbnZhciB2ZXJ0aWNhbCA9IHtcbiAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICBsaW5lOiAneScsXG4gIGNyb3NzQXhpc0xpbmU6ICd4JyxcbiAgc3RhcnQ6ICd0b3AnLFxuICBlbmQ6ICdib3R0b20nLFxuICBzaXplOiAnaGVpZ2h0JyxcbiAgY3Jvc3NBeGlzU3RhcnQ6ICdsZWZ0JyxcbiAgY3Jvc3NBeGlzRW5kOiAncmlnaHQnLFxuICBjcm9zc0F4aXNTaXplOiAnd2lkdGgnXG59O1xudmFyIGhvcml6b250YWwgPSB7XG4gIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICBsaW5lOiAneCcsXG4gIGNyb3NzQXhpc0xpbmU6ICd5JyxcbiAgc3RhcnQ6ICdsZWZ0JyxcbiAgZW5kOiAncmlnaHQnLFxuICBzaXplOiAnd2lkdGgnLFxuICBjcm9zc0F4aXNTdGFydDogJ3RvcCcsXG4gIGNyb3NzQXhpc0VuZDogJ2JvdHRvbScsXG4gIGNyb3NzQXhpc1NpemU6ICdoZWlnaHQnXG59O1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyA9IChmdW5jdGlvbiAoYXhpcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgdmFyIGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gICAgdmFyIGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICAgIGlmIChheGlzID09PSB2ZXJ0aWNhbCkge1xuICAgICAgICByZXR1cm4gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgZ2V0RHJvcHBhYmxlRGlzcGxhY2VkID0gZnVuY3Rpb24gZ2V0RHJvcHBhYmxlRGlzcGxhY2VkKHRhcmdldCwgZGVzdGluYXRpb24pIHtcbiAgdmFyIGRpc3BsYWNlbWVudCA9IGRlc3RpbmF0aW9uLmZyYW1lID8gZGVzdGluYXRpb24uZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50IDogb3JpZ2luO1xuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGRpc3BsYWNlbWVudCk7XG59O1xuXG52YXIgaXNWaXNpYmxlSW5Ecm9wcGFibGUgPSBmdW5jdGlvbiBpc1Zpc2libGVJbkRyb3BwYWJsZSh0YXJnZXQsIGRlc3RpbmF0aW9uLCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikge1xuICBpZiAoIWRlc3RpbmF0aW9uLnN1YmplY3QuYWN0aXZlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKGRlc3RpbmF0aW9uLnN1YmplY3QuYWN0aXZlKSh0YXJnZXQpO1xufTtcblxudmFyIGlzVmlzaWJsZUluVmlld3BvcnQgPSBmdW5jdGlvbiBpc1Zpc2libGVJblZpZXdwb3J0KHRhcmdldCwgdmlld3BvcnQsIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSB7XG4gIHJldHVybiBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbih2aWV3cG9ydCkodGFyZ2V0KTtcbn07XG5cbnZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoX3JlZikge1xuICB2YXIgdG9CZURpc3BsYWNlZCA9IF9yZWYudGFyZ2V0LFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCA9IF9yZWYud2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgICAgIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuID0gX3JlZi5pc1Zpc2libGVUaHJvdWdoRnJhbWVGbjtcbiAgdmFyIGRpc3BsYWNlZFRhcmdldCA9IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPyBnZXREcm9wcGFibGVEaXNwbGFjZWQodG9CZURpc3BsYWNlZCwgZGVzdGluYXRpb24pIDogdG9CZURpc3BsYWNlZDtcbiAgcmV0dXJuIGlzVmlzaWJsZUluRHJvcHBhYmxlKGRpc3BsYWNlZFRhcmdldCwgZGVzdGluYXRpb24sIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSAmJiBpc1Zpc2libGVJblZpZXdwb3J0KGRpc3BsYWNlZFRhcmdldCwgdmlld3BvcnQsIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKTtcbn07XG5cbnZhciBpc1BhcnRpYWxseVZpc2libGUgPSBmdW5jdGlvbiBpc1BhcnRpYWxseVZpc2libGUoYXJncykge1xuICByZXR1cm4gaXNWaXNpYmxlKF9leHRlbmRzKHt9LCBhcmdzLCB7XG4gICAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZVxuICB9KSk7XG59O1xudmFyIGlzVG90YWxseVZpc2libGUgPSBmdW5jdGlvbiBpc1RvdGFsbHlWaXNpYmxlKGFyZ3MpIHtcbiAgcmV0dXJuIGlzVmlzaWJsZShfZXh0ZW5kcyh7fSwgYXJncywge1xuICAgIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lXG4gIH0pKTtcbn07XG52YXIgaXNUb3RhbGx5VmlzaWJsZU9uQXhpcyA9IGZ1bmN0aW9uIGlzVG90YWxseVZpc2libGVPbkF4aXMoYXJncykge1xuICByZXR1cm4gaXNWaXNpYmxlKF9leHRlbmRzKHt9LCBhcmdzLCB7XG4gICAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMoYXJncy5kZXN0aW5hdGlvbi5heGlzKVxuICB9KSk7XG59O1xuXG52YXIgZ2V0U2hvdWxkQW5pbWF0ZSA9IGZ1bmN0aW9uIGdldFNob3VsZEFuaW1hdGUoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSkge1xuICBpZiAodHlwZW9mIGZvcmNlU2hvdWxkQW5pbWF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgfVxuXG4gIGlmICghbGFzdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGludmlzaWJsZSA9IGxhc3QuaW52aXNpYmxlLFxuICAgICAgdmlzaWJsZSA9IGxhc3QudmlzaWJsZTtcblxuICBpZiAoaW52aXNpYmxlW2lkXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcmV2aW91cyA9IHZpc2libGVbaWRdO1xuICByZXR1cm4gcHJldmlvdXMgPyBwcmV2aW91cy5zaG91bGRBbmltYXRlIDogdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGdldFRhcmdldChkcmFnZ2FibGUsIGRpc3BsYWNlZEJ5KSB7XG4gIHZhciBtYXJnaW5Cb3ggPSBkcmFnZ2FibGUucGFnZS5tYXJnaW5Cb3g7XG4gIHZhciBleHBhbmRCeSA9IHtcbiAgICB0b3A6IGRpc3BsYWNlZEJ5LnBvaW50LnksXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IGRpc3BsYWNlZEJ5LnBvaW50LnhcbiAgfTtcbiAgcmV0dXJuIGdldFJlY3QoZXhwYW5kKG1hcmdpbkJveCwgZXhwYW5kQnkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKF9yZWYpIHtcbiAgdmFyIGFmdGVyRHJhZ2dpbmcgPSBfcmVmLmFmdGVyRHJhZ2dpbmcsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBkaXNwbGFjZWRCeSA9IF9yZWYuZGlzcGxhY2VkQnksXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGUgPSBfcmVmLmZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICAgIGxhc3QgPSBfcmVmLmxhc3Q7XG4gIHJldHVybiBhZnRlckRyYWdnaW5nLnJlZHVjZShmdW5jdGlvbiBwcm9jZXNzKGdyb3VwcywgZHJhZ2dhYmxlKSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChkcmFnZ2FibGUsIGRpc3BsYWNlZEJ5KTtcbiAgICB2YXIgaWQgPSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZDtcbiAgICBncm91cHMuYWxsLnB1c2goaWQpO1xuICAgIHZhciBpc1Zpc2libGUgPSBpc1BhcnRpYWxseVZpc2libGUoe1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgZ3JvdXBzLmludmlzaWJsZVtkcmFnZ2FibGUuZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkQW5pbWF0ZSA9IGdldFNob3VsZEFuaW1hdGUoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgdmFyIGRpc3BsYWNlbWVudCA9IHtcbiAgICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICAgIHNob3VsZEFuaW1hdGU6IHNob3VsZEFuaW1hdGVcbiAgICB9O1xuICAgIGdyb3Vwcy52aXNpYmxlW2lkXSA9IGRpc3BsYWNlbWVudDtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9LCB7XG4gICAgYWxsOiBbXSxcbiAgICB2aXNpYmxlOiB7fSxcbiAgICBpbnZpc2libGU6IHt9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleE9mTGFzdEl0ZW0oZHJhZ2dhYmxlcywgb3B0aW9ucykge1xuICBpZiAoIWRyYWdnYWJsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgaW5kZXhPZkxhc3RJdGVtID0gZHJhZ2dhYmxlc1tkcmFnZ2FibGVzLmxlbmd0aCAtIDFdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIHJldHVybiBvcHRpb25zLmluSG9tZUxpc3QgPyBpbmRleE9mTGFzdEl0ZW0gOiBpbmRleE9mTGFzdEl0ZW0gKyAxO1xufVxuXG5mdW5jdGlvbiBnb0F0RW5kKF9yZWYpIHtcbiAgdmFyIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3QgPSBfcmVmLmluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeSA9IF9yZWYuZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb247XG4gIHZhciBuZXdJbmRleCA9IGdldEluZGV4T2ZMYXN0SXRlbShpbnNpZGVEZXN0aW5hdGlvbiwge1xuICAgIGluSG9tZUxpc3Q6IGluSG9tZUxpc3RcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBpbmRleDogbmV3SW5kZXhcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3QoX3JlZjIpIHtcbiAgdmFyIGRyYWdnYWJsZSA9IF9yZWYyLmRyYWdnYWJsZSxcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZjIuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYyLmRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQgPSBfcmVmMi52aWV3cG9ydCxcbiAgICAgIGRpc3BsYWNlZEJ5ID0gX3JlZjIuZGlzcGxhY2VkQnksXG4gICAgICBsYXN0ID0gX3JlZjIubGFzdCxcbiAgICAgIGluZGV4ID0gX3JlZjIuaW5kZXgsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGUgPSBfcmVmMi5mb3JjZVNob3VsZEFuaW1hdGU7XG4gIHZhciBpbkhvbWVMaXN0ID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbik7XG5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZ29BdEVuZCh7XG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0OiBpbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uXG4gICAgfSk7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBmaW5kKGluc2lkZURlc3RpbmF0aW9uLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLmRlc2NyaXB0b3IuaW5kZXggPT09IGluZGV4O1xuICB9KTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGdvQXRFbmQoe1xuICAgICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgaW5Ib21lTGlzdDogaW5Ib21lTGlzdCxcbiAgICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvblxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICB2YXIgc2xpY2VGcm9tID0gaW5zaWRlRGVzdGluYXRpb24uaW5kZXhPZihtYXRjaCk7XG4gIHZhciBpbXBhY3RlZCA9IHdpdGhvdXREcmFnZ2luZy5zbGljZShzbGljZUZyb20pO1xuICB2YXIgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBpbXBhY3RlZCxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGxhc3Q6IGxhc3QsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZm9yY2VTaG91bGRBbmltYXRlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYWNlZDogZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZUlkLCBhZnRlckNyaXRpY2FsKSB7XG4gIHJldHVybiBCb29sZWFuKGFmdGVyQ3JpdGljYWwuZWZmZWN0ZWRbZHJhZ2dhYmxlSWRdKTtcbn1cblxudmFyIGZyb21Db21iaW5lID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSBfcmVmLmlzTW92aW5nRm9yd2FyZCxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBjb21iaW5lID0gX3JlZi5jb21iaW5lLFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcblxuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjb21iaW5lSWQgPSBjb21iaW5lLmRyYWdnYWJsZUlkO1xuICB2YXIgY29tYmluZVdpdGggPSBkcmFnZ2FibGVzW2NvbWJpbmVJZF07XG4gIHZhciBjb21iaW5lV2l0aEluZGV4ID0gY29tYmluZVdpdGguZGVzY3JpcHRvci5pbmRleDtcbiAgdmFyIGRpZENvbWJpbmVXaXRoU3RhcnRBZnRlckNyaXRpY2FsID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNvbWJpbmVJZCwgYWZ0ZXJDcml0aWNhbCk7XG5cbiAgaWYgKGRpZENvbWJpbmVXaXRoU3RhcnRBZnRlckNyaXRpY2FsKSB7XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggLSAxO1xuICB9XG5cbiAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgIHJldHVybiBjb21iaW5lV2l0aEluZGV4ICsgMTtcbiAgfVxuXG4gIHJldHVybiBjb21iaW5lV2l0aEluZGV4O1xufSk7XG5cbnZhciBmcm9tUmVvcmRlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaXNNb3ZpbmdGb3J3YXJkID0gX3JlZi5pc01vdmluZ0ZvcndhcmQsXG4gICAgICBpc0luSG9tZUxpc3QgPSBfcmVmLmlzSW5Ib21lTGlzdCxcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbjtcblxuICBpZiAoIWluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRJbmRleCA9IGxvY2F0aW9uLmluZGV4O1xuICB2YXIgcHJvcG9zZWRJbmRleCA9IGlzTW92aW5nRm9yd2FyZCA/IGN1cnJlbnRJbmRleCArIDEgOiBjdXJyZW50SW5kZXggLSAxO1xuICB2YXIgZmlyc3RJbmRleCA9IGluc2lkZURlc3RpbmF0aW9uWzBdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIHZhciBsYXN0SW5kZXggPSBpbnNpZGVEZXN0aW5hdGlvbltpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggLSAxXS5kZXNjcmlwdG9yLmluZGV4O1xuICB2YXIgdXBwZXJCb3VuZCA9IGlzSW5Ib21lTGlzdCA/IGxhc3RJbmRleCA6IGxhc3RJbmRleCArIDE7XG5cbiAgaWYgKHByb3Bvc2VkSW5kZXggPCBmaXJzdEluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocHJvcG9zZWRJbmRleCA+IHVwcGVyQm91bmQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwcm9wb3NlZEluZGV4O1xufSk7XG5cbnZhciBtb3ZlVG9OZXh0SW5kZXggPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGlzTW92aW5nRm9yd2FyZCA9IF9yZWYuaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgaXNJbkhvbWVMaXN0ID0gX3JlZi5pc0luSG9tZUxpc3QsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBwcmV2aW91c0ltcGFjdCA9IF9yZWYucHJldmlvdXNJbXBhY3QsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuICB2YXIgd2FzQXQgPSBwcmV2aW91c0ltcGFjdC5hdDtcbiAgIXdhc0F0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IG1vdmUgaW4gZGlyZWN0aW9uIHdpdGhvdXQgcHJldmlvdXMgaW1wYWN0IGxvY2F0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIGlmICh3YXNBdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICB2YXIgX25ld0luZGV4ID0gZnJvbVJlb3JkZXIoe1xuICAgICAgaXNNb3ZpbmdGb3J3YXJkOiBpc01vdmluZ0ZvcndhcmQsXG4gICAgICBpc0luSG9tZUxpc3Q6IGlzSW5Ib21lTGlzdCxcbiAgICAgIGxvY2F0aW9uOiB3YXNBdC5kZXN0aW5hdGlvbixcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKF9uZXdJbmRleCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICAgIGluZGV4OiBfbmV3SW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBuZXdJbmRleCA9IGZyb21Db21iaW5lKHtcbiAgICBpc01vdmluZ0ZvcndhcmQ6IGlzTW92aW5nRm9yd2FyZCxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBjb21iaW5lOiB3YXNBdC5jb21iaW5lLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG5cbiAgaWYgKG5ld0luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBsYXN0OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnk6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIGluZGV4OiBuZXdJbmRleFxuICB9KTtcbn0pO1xuXG52YXIgZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkaXNwbGFjZWQgPSBfcmVmLmRpc3BsYWNlZCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWwsXG4gICAgICBjb21iaW5lV2l0aCA9IF9yZWYuY29tYmluZVdpdGgsXG4gICAgICBkaXNwbGFjZWRCeSA9IF9yZWYuZGlzcGxhY2VkQnk7XG4gIHZhciBpc0Rpc3BsYWNlZCA9IEJvb2xlYW4oZGlzcGxhY2VkLnZpc2libGVbY29tYmluZVdpdGhdIHx8IGRpc3BsYWNlZC5pbnZpc2libGVbY29tYmluZVdpdGhdKTtcblxuICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNvbWJpbmVXaXRoLCBhZnRlckNyaXRpY2FsKSkge1xuICAgIHJldHVybiBpc0Rpc3BsYWNlZCA/IG9yaWdpbiA6IG5lZ2F0ZShkaXNwbGFjZWRCeS5wb2ludCk7XG4gIH1cblxuICByZXR1cm4gaXNEaXNwbGFjZWQgPyBkaXNwbGFjZWRCeS5wb2ludCA6IG9yaWdpbjtcbn0pO1xuXG52YXIgd2hlbkNvbWJpbmluZyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbCxcbiAgICAgIGltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcztcbiAgdmFyIGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICFjb21iaW5lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBjb21iaW5lV2l0aCA9IGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIHZhciBjZW50ZXIgPSBkcmFnZ2FibGVzW2NvbWJpbmVXaXRoXS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIHZhciBkaXNwbGFjZUJ5ID0gZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50KHtcbiAgICBkaXNwbGFjZWQ6IGltcGFjdC5kaXNwbGFjZWQsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbCxcbiAgICBjb21iaW5lV2l0aDogY29tYmluZVdpdGgsXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeVxuICB9KTtcbiAgcmV0dXJuIGFkZChjZW50ZXIsIGRpc3BsYWNlQnkpO1xufSk7XG5cbnZhciBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyID0gZnVuY3Rpb24gZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlcihheGlzLCBib3gpIHtcbiAgcmV0dXJuIGJveC5tYXJnaW5bYXhpcy5zdGFydF0gKyBib3guYm9yZGVyQm94W2F4aXMuc2l6ZV0gLyAyO1xufTtcblxudmFyIGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyID0gZnVuY3Rpb24gZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgYm94KSB7XG4gIHJldHVybiBib3gubWFyZ2luW2F4aXMuZW5kXSArIGJveC5ib3JkZXJCb3hbYXhpcy5zaXplXSAvIDI7XG59O1xuXG52YXIgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIHRhcmdldCwgaXNNb3ZpbmcpIHtcbiAgcmV0dXJuIHRhcmdldFtheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLm1hcmdpbltheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLmJvcmRlckJveFtheGlzLmNyb3NzQXhpc1NpemVdIC8gMjtcbn07XG5cbnZhciBnb0FmdGVyID0gZnVuY3Rpb24gZ29BZnRlcihfcmVmKSB7XG4gIHZhciBheGlzID0gX3JlZi5heGlzLFxuICAgICAgbW92ZVJlbGF0aXZlVG8gPSBfcmVmLm1vdmVSZWxhdGl2ZVRvLFxuICAgICAgaXNNb3ZpbmcgPSBfcmVmLmlzTW92aW5nO1xuICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3hbYXhpcy5lbmRdICsgZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlcihheGlzLCBpc01vdmluZyksIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlcihheGlzLCBtb3ZlUmVsYXRpdmVUby5tYXJnaW5Cb3gsIGlzTW92aW5nKSk7XG59O1xudmFyIGdvQmVmb3JlID0gZnVuY3Rpb24gZ29CZWZvcmUoX3JlZjIpIHtcbiAgdmFyIGF4aXMgPSBfcmVmMi5heGlzLFxuICAgICAgbW92ZVJlbGF0aXZlVG8gPSBfcmVmMi5tb3ZlUmVsYXRpdmVUbyxcbiAgICAgIGlzTW92aW5nID0gX3JlZjIuaXNNb3Zpbmc7XG4gIHJldHVybiBwYXRjaChheGlzLmxpbmUsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveFtheGlzLnN0YXJ0XSAtIGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveCwgaXNNb3ZpbmcpKTtcbn07XG52YXIgZ29JbnRvU3RhcnQgPSBmdW5jdGlvbiBnb0ludG9TdGFydChfcmVmMykge1xuICB2YXIgYXhpcyA9IF9yZWYzLmF4aXMsXG4gICAgICBtb3ZlSW50byA9IF9yZWYzLm1vdmVJbnRvLFxuICAgICAgaXNNb3ZpbmcgPSBfcmVmMy5pc01vdmluZztcbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbW92ZUludG8uY29udGVudEJveFtheGlzLnN0YXJ0XSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZUludG8uY29udGVudEJveCwgaXNNb3ZpbmcpKTtcbn07XG5cbnZhciB3aGVuUmVvcmRlcmluZyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGUgPSBfcmVmLmRyb3BwYWJsZSxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG4gIHZhciBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICB2YXIgZHJhZ2dhYmxlUGFnZSA9IGRyYWdnYWJsZS5wYWdlO1xuICB2YXIgYXhpcyA9IGRyb3BwYWJsZS5heGlzO1xuXG4gIGlmICghaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdvSW50b1N0YXJ0KHtcbiAgICAgIGF4aXM6IGF4aXMsXG4gICAgICBtb3ZlSW50bzogZHJvcHBhYmxlLnBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGRpc3BsYWNlZCA9IGltcGFjdC5kaXNwbGFjZWQsXG4gICAgICBkaXNwbGFjZWRCeSA9IGltcGFjdC5kaXNwbGFjZWRCeTtcbiAgdmFyIGNsb3Nlc3RBZnRlciA9IGRpc3BsYWNlZC5hbGxbMF07XG5cbiAgaWYgKGNsb3Nlc3RBZnRlcikge1xuICAgIHZhciBjbG9zZXN0ID0gZHJhZ2dhYmxlc1tjbG9zZXN0QWZ0ZXJdO1xuXG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjbG9zZXN0QWZ0ZXIsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgICBheGlzOiBheGlzLFxuICAgICAgICBtb3ZlUmVsYXRpdmVUbzogY2xvc2VzdC5wYWdlLFxuICAgICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHdpdGhEaXNwbGFjZW1lbnQgPSBvZmZzZXQoY2xvc2VzdC5wYWdlLCBkaXNwbGFjZWRCeS5wb2ludCk7XG4gICAgcmV0dXJuIGdvQmVmb3JlKHtcbiAgICAgIGF4aXM6IGF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbzogd2l0aERpc3BsYWNlbWVudCxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgbGFzdCA9IGluc2lkZURlc3RpbmF0aW9uW2luc2lkZURlc3RpbmF0aW9uLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChsYXN0LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgcmV0dXJuIGRyYWdnYWJsZVBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgfVxuXG4gIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwobGFzdC5kZXNjcmlwdG9yLmlkLCBhZnRlckNyaXRpY2FsKSkge1xuICAgIHZhciBwYWdlID0gb2Zmc2V0KGxhc3QucGFnZSwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKTtcbiAgICByZXR1cm4gZ29BZnRlcih7XG4gICAgICBheGlzOiBheGlzLFxuICAgICAgbW92ZVJlbGF0aXZlVG86IHBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGdvQWZ0ZXIoe1xuICAgIGF4aXM6IGF4aXMsXG4gICAgbW92ZVJlbGF0aXZlVG86IGxhc3QucGFnZSxcbiAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICB9KTtcbn0pO1xuXG52YXIgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCA9IChmdW5jdGlvbiAoZHJvcHBhYmxlLCBwb2ludCkge1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIHJldHVybiBhZGQocG9pbnQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59KTtcblxudmFyIGdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQgPSBmdW5jdGlvbiBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50KF9yZWYpIHtcbiAgdmFyIGltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkcm9wcGFibGUgPSBfcmVmLmRyb3BwYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuICB2YXIgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICB2YXIgYXQgPSBpbXBhY3QuYXQ7XG5cbiAgaWYgKCFkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cblxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG5cbiAgaWYgKGF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiB3aGVuUmVvcmRlcmluZyh7XG4gICAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZTogZHJvcHBhYmxlLFxuICAgICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHdoZW5Db21iaW5pbmcoe1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn07XG5cbnZhciBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCA9IChmdW5jdGlvbiAoYXJncykge1xuICB2YXIgd2l0aG91dERpc3BsYWNlbWVudCA9IGdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQoYXJncyk7XG4gIHZhciBkcm9wcGFibGUgPSBhcmdzLmRyb3BwYWJsZTtcbiAgdmFyIHdpdGhEaXNwbGFjZW1lbnQgPSBkcm9wcGFibGUgPyB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRyb3BwYWJsZSwgd2l0aG91dERpc3BsYWNlbWVudCkgOiB3aXRob3V0RGlzcGxhY2VtZW50O1xuICByZXR1cm4gd2l0aERpc3BsYWNlbWVudDtcbn0pO1xuXG52YXIgc2Nyb2xsVmlld3BvcnQgPSAoZnVuY3Rpb24gKHZpZXdwb3J0LCBuZXdTY3JvbGwpIHtcbiAgdmFyIGRpZmYgPSBzdWJ0cmFjdChuZXdTY3JvbGwsIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKTtcbiAgdmFyIGRpc3BsYWNlbWVudCA9IG5lZ2F0ZShkaWZmKTtcbiAgdmFyIGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wOiBuZXdTY3JvbGwueSxcbiAgICBib3R0b206IG5ld1Njcm9sbC55ICsgdmlld3BvcnQuZnJhbWUuaGVpZ2h0LFxuICAgIGxlZnQ6IG5ld1Njcm9sbC54LFxuICAgIHJpZ2h0OiBuZXdTY3JvbGwueCArIHZpZXdwb3J0LmZyYW1lLndpZHRoXG4gIH0pO1xuICB2YXIgdXBkYXRlZCA9IHtcbiAgICBmcmFtZTogZnJhbWUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIG1heDogdmlld3BvcnQuc2Nyb2xsLm1heCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IGRpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudDogZGlzcGxhY2VtZW50XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlZDtcbn0pO1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVzKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZHJhZ2dhYmxlc1tpZF07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlzcGxhY2VtZW50ID0gZ3JvdXBzW2ldLnZpc2libGVbaWRdO1xuXG4gICAgaWYgKGRpc3BsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIHNwZWN1bGF0aXZlbHlJbmNyZWFzZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgbWF4U2Nyb2xsQ2hhbmdlID0gX3JlZi5tYXhTY3JvbGxDaGFuZ2U7XG4gIHZhciBzY3JvbGxlZFZpZXdwb3J0ID0gc2Nyb2xsVmlld3BvcnQodmlld3BvcnQsIGFkZCh2aWV3cG9ydC5zY3JvbGwuY3VycmVudCwgbWF4U2Nyb2xsQ2hhbmdlKSk7XG4gIHZhciBzY3JvbGxlZERyb3BwYWJsZSA9IGRlc3RpbmF0aW9uLmZyYW1lID8gc2Nyb2xsRHJvcHBhYmxlKGRlc3RpbmF0aW9uLCBhZGQoZGVzdGluYXRpb24uZnJhbWUuc2Nyb2xsLmN1cnJlbnQsIG1heFNjcm9sbENoYW5nZSkpIDogZGVzdGluYXRpb247XG4gIHZhciBsYXN0ID0gaW1wYWN0LmRpc3BsYWNlZDtcbiAgdmFyIHdpdGhWaWV3cG9ydFNjcm9sbCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogZ2V0RHJhZ2dhYmxlcyhsYXN0LmFsbCwgZHJhZ2dhYmxlcyksXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHNjcm9sbGVkVmlld3BvcnQuZnJhbWUsXG4gICAgbGFzdDogbGFzdCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICB2YXIgd2l0aERyb3BwYWJsZVNjcm9sbCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogZ2V0RHJhZ2dhYmxlcyhsYXN0LmFsbCwgZHJhZ2dhYmxlcyksXG4gICAgZGVzdGluYXRpb246IHNjcm9sbGVkRHJvcHBhYmxlLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGxhc3Q6IGxhc3QsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgdmFyIGludmlzaWJsZSA9IHt9O1xuICB2YXIgdmlzaWJsZSA9IHt9O1xuICB2YXIgZ3JvdXBzID0gW2xhc3QsIHdpdGhWaWV3cG9ydFNjcm9sbCwgd2l0aERyb3BwYWJsZVNjcm9sbF07XG4gIGxhc3QuYWxsLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGRpc3BsYWNlbWVudCA9IHRyeUdldFZpc2libGUoaWQsIGdyb3Vwcyk7XG5cbiAgICBpZiAoZGlzcGxhY2VtZW50KSB7XG4gICAgICB2aXNpYmxlW2lkXSA9IGRpc3BsYWNlbWVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZpc2libGVbaWRdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgdmFyIG5ld0ltcGFjdCA9IF9leHRlbmRzKHt9LCBpbXBhY3QsIHtcbiAgICBkaXNwbGFjZWQ6IHtcbiAgICAgIGFsbDogbGFzdC5hbGwsXG4gICAgICBpbnZpc2libGU6IGludmlzaWJsZSxcbiAgICAgIHZpc2libGU6IHZpc2libGVcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZXdJbXBhY3Q7XG59KTtcblxudmFyIHdpdGhWaWV3cG9ydERpc3BsYWNlbWVudCA9IChmdW5jdGlvbiAodmlld3BvcnQsIHBvaW50KSB7XG4gIHJldHVybiBhZGQodmlld3BvcnQuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50LCBwb2ludCk7XG59KTtcblxudmFyIGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwYWdlQm9yZGVyQm94Q2VudGVyID0gX3JlZi5wYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQ7XG4gIHZhciB3aXRob3V0UGFnZVNjcm9sbENoYW5nZSA9IHdpdGhWaWV3cG9ydERpc3BsYWNlbWVudCh2aWV3cG9ydCwgcGFnZUJvcmRlckJveENlbnRlcik7XG4gIHZhciBvZmZzZXQgPSBzdWJ0cmFjdCh3aXRob3V0UGFnZVNjcm9sbENoYW5nZSwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIHJldHVybiBhZGQoZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyLCBvZmZzZXQpO1xufSk7XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbiA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyID0gX3JlZi5uZXdQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCA9IF9yZWYud2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgICAgIF9yZWYkb25seU9uTWFpbkF4aXMgPSBfcmVmLm9ubHlPbk1haW5BeGlzLFxuICAgICAgb25seU9uTWFpbkF4aXMgPSBfcmVmJG9ubHlPbk1haW5BeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkb25seU9uTWFpbkF4aXM7XG4gIHZhciBjaGFuZ2VOZWVkZWQgPSBzdWJ0cmFjdChuZXdQYWdlQm9yZGVyQm94Q2VudGVyLCBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyKTtcbiAgdmFyIHNoaWZ0ZWQgPSBvZmZzZXRCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgY2hhbmdlTmVlZGVkKTtcbiAgdmFyIGFyZ3MgPSB7XG4gICAgdGFyZ2V0OiBzaGlmdGVkLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICB9O1xuICByZXR1cm4gb25seU9uTWFpbkF4aXMgPyBpc1RvdGFsbHlWaXNpYmxlT25BeGlzKGFyZ3MpIDogaXNUb3RhbGx5VmlzaWJsZShhcmdzKTtcbn0pO1xuXG52YXIgbW92ZVRvTmV4dFBsYWNlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSBfcmVmLmlzTW92aW5nRm9yd2FyZCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIHByZXZpb3VzSW1wYWN0ID0gX3JlZi5wcmV2aW91c0ltcGFjdCxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciA9IF9yZWYucHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgcHJldmlvdXNDbGllbnRTZWxlY3Rpb24gPSBfcmVmLnByZXZpb3VzQ2xpZW50U2VsZWN0aW9uLFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcblxuICBpZiAoIWRlc3RpbmF0aW9uLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgdmFyIGlzSW5Ib21lTGlzdCA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pO1xuICB2YXIgaW1wYWN0ID0gbW92ZVRvTmV4dENvbWJpbmUoe1xuICAgIGlzTW92aW5nRm9yd2FyZDogaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgcHJldmlvdXNJbXBhY3Q6IHByZXZpb3VzSW1wYWN0XG4gIH0pIHx8IG1vdmVUb05leHRJbmRleCh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkOiBpc01vdmluZ0ZvcndhcmQsXG4gICAgaXNJbkhvbWVMaXN0OiBpc0luSG9tZUxpc3QsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0OiBwcmV2aW91c0ltcGFjdCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcblxuICBpZiAoIWltcGFjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHZhciBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID0gaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24oe1xuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyOiBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiBmYWxzZSxcbiAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICB9KTtcblxuICBpZiAoaXNWaXNpYmxlSW5OZXdMb2NhdGlvbikge1xuICAgIHZhciBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50U2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkaXN0YW5jZSA9IHN1YnRyYWN0KHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcik7XG4gIHZhciBjYXV0aW91cyA9IHNwZWN1bGF0aXZlbHlJbmNyZWFzZSh7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIG1heFNjcm9sbENoYW5nZTogZGlzdGFuY2VcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xpZW50U2VsZWN0aW9uOiBwcmV2aW91c0NsaWVudFNlbGVjdGlvbixcbiAgICBpbXBhY3Q6IGNhdXRpb3VzLFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBkaXN0YW5jZVxuICB9O1xufSk7XG5cbnZhciBnZXRLbm93bkFjdGl2ZSA9IGZ1bmN0aW9uIGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSkge1xuICB2YXIgcmVjdCA9IGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZTtcbiAgIXJlY3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZ2V0IGNsaXBwZWQgYXJlYSBmcm9tIGRyb3BwYWJsZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlY3Q7XG59O1xuXG52YXIgZ2V0QmVzdENyb3NzQXhpc0Ryb3BwYWJsZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaXNNb3ZpbmdGb3J3YXJkID0gX3JlZi5pc01vdmluZ0ZvcndhcmQsXG4gICAgICBwYWdlQm9yZGVyQm94Q2VudGVyID0gX3JlZi5wYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICBkcm9wcGFibGVzID0gX3JlZi5kcm9wcGFibGVzLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0O1xuICB2YXIgYWN0aXZlID0gc291cmNlLnN1YmplY3QuYWN0aXZlO1xuXG4gIGlmICghYWN0aXZlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXhpcyA9IHNvdXJjZS5heGlzO1xuICB2YXIgaXNCZXR3ZWVuU291cmNlQ2xpcHBlZCA9IGlzV2l0aGluKGFjdGl2ZVtheGlzLnN0YXJ0XSwgYWN0aXZlW2F4aXMuZW5kXSk7XG4gIHZhciBjYW5kaWRhdGVzID0gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZSAhPT0gc291cmNlO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICAgIHJldHVybiBkcm9wcGFibGUuaXNFbmFibGVkO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICAgIHJldHVybiBCb29sZWFuKGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZSk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuIGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSh2aWV3cG9ydC5mcmFtZSkoZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKSk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgdmFyIGFjdGl2ZU9mVGFyZ2V0ID0gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKTtcblxuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdIDwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIH1cblxuICAgIHJldHVybiBhY3RpdmVPZlRhcmdldFtheGlzLmNyb3NzQXhpc1N0YXJ0XSA8IGFjdGl2ZVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICB2YXIgYWN0aXZlT2ZUYXJnZXQgPSBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpO1xuICAgIHZhciBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5lbmRdKTtcbiAgICByZXR1cm4gaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSkgfHwgaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLmVuZF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5zdGFydF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5lbmRdKTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBmaXJzdCA9IGdldEtub3duQWN0aXZlKGEpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIHZhciBzZWNvbmQgPSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcblxuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAtIHNlY29uZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2Vjb25kIC0gZmlyc3Q7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlLCBpbmRleCwgYXJyYXkpIHtcbiAgICByZXR1cm4gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLmNyb3NzQXhpc1N0YXJ0XSA9PT0gZ2V0S25vd25BY3RpdmUoYXJyYXlbMF0pW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICB9KTtcblxuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlc1swXTtcbiAgfVxuXG4gIHZhciBjb250YWlucyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICB2YXIgaXNXaXRoaW5Ecm9wcGFibGUgPSBpc1dpdGhpbihnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuc3RhcnRdLCBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuZW5kXSk7XG4gICAgcmV0dXJuIGlzV2l0aGluRHJvcHBhYmxlKHBhZ2VCb3JkZXJCb3hDZW50ZXJbYXhpcy5saW5lXSk7XG4gIH0pO1xuXG4gIGlmIChjb250YWlucy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY29udGFpbnNbMF07XG4gIH1cblxuICBpZiAoY29udGFpbnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBjb250YWlucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5zdGFydF0gLSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLnN0YXJ0XTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgZmlyc3QgPSBjbG9zZXN0KHBhZ2VCb3JkZXJCb3hDZW50ZXIsIGdldENvcm5lcnMoZ2V0S25vd25BY3RpdmUoYSkpKTtcbiAgICB2YXIgc2Vjb25kID0gY2xvc2VzdChwYWdlQm9yZGVyQm94Q2VudGVyLCBnZXRDb3JuZXJzKGdldEtub3duQWN0aXZlKGIpKSk7XG5cbiAgICBpZiAoZmlyc3QgIT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRLbm93bkFjdGl2ZShhKVtheGlzLnN0YXJ0XSAtIGdldEtub3duQWN0aXZlKGIpW2F4aXMuc3RhcnRdO1xuICB9KVswXTtcbn0pO1xuXG52YXIgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBmdW5jdGlvbiBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlcihkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpIHtcbiAgdmFyIG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBzdWJ0cmFjdChvcmlnaW5hbCwgYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkgOiBvcmlnaW5hbDtcbn07XG52YXIgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3ggPSBmdW5jdGlvbiBnZXRDdXJyZW50UGFnZUJvcmRlckJveChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpIHtcbiAgdmFyIG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94O1xuICByZXR1cm4gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLCBhZnRlckNyaXRpY2FsKSA/IG9mZnNldEJ5UG9zaXRpb24ob3JpZ2luYWwsIG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSkgOiBvcmlnaW5hbDtcbn07XG5cbnZhciBnZXRDbG9zZXN0RHJhZ2dhYmxlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwYWdlQm9yZGVyQm94Q2VudGVyID0gX3JlZi5wYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIHNvcnRlZCA9IGluc2lkZURlc3RpbmF0aW9uLmZpbHRlcihmdW5jdGlvbiAoZHJhZ2dhYmxlKSB7XG4gICAgcmV0dXJuIGlzVG90YWxseVZpc2libGUoe1xuICAgICAgdGFyZ2V0OiBnZXRDdXJyZW50UGFnZUJvcmRlckJveChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpLFxuICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogdHJ1ZVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGRpc3RhbmNlVG9BID0gZGlzdGFuY2UocGFnZUJvcmRlckJveENlbnRlciwgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkZXN0aW5hdGlvbiwgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoYSwgYWZ0ZXJDcml0aWNhbCkpKTtcbiAgICB2YXIgZGlzdGFuY2VUb0IgPSBkaXN0YW5jZShwYWdlQm9yZGVyQm94Q2VudGVyLCB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRlc3RpbmF0aW9uLCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlcihiLCBhZnRlckNyaXRpY2FsKSkpO1xuXG4gICAgaWYgKGRpc3RhbmNlVG9BIDwgZGlzdGFuY2VUb0IpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2VUb0IgPCBkaXN0YW5jZVRvQSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleDtcbiAgfSk7XG4gIHJldHVybiBzb3J0ZWRbMF0gfHwgbnVsbDtcbn0pO1xuXG52YXIgZ2V0RGlzcGxhY2VkQnkgPSBtZW1vaXplT25lKGZ1bmN0aW9uIGdldERpc3BsYWNlZEJ5KGF4aXMsIGRpc3BsYWNlQnkpIHtcbiAgdmFyIGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlQnlbYXhpcy5saW5lXTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogZGlzcGxhY2VtZW50LFxuICAgIHBvaW50OiBwYXRjaChheGlzLmxpbmUsIGRpc3BsYWNlbWVudClcbiAgfTtcbn0pO1xuXG52YXIgZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBwbGFjZWhvbGRlclNpemUsIGRyYWdnYWJsZXMpIHtcbiAgdmFyIGF4aXMgPSBkcm9wcGFibGUuYXhpcztcblxuICBpZiAoZHJvcHBhYmxlLmRlc2NyaXB0b3IubW9kZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgcGxhY2Vob2xkZXJTaXplW2F4aXMubGluZV0pO1xuICB9XG5cbiAgdmFyIGF2YWlsYWJsZVNwYWNlID0gZHJvcHBhYmxlLnN1YmplY3QucGFnZS5jb250ZW50Qm94W2F4aXMuc2l6ZV07XG4gIHZhciBpbnNpZGVEcm9wcGFibGUgPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgdmFyIHNwYWNlVXNlZCA9IGluc2lkZURyb3BwYWJsZS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZGltZW5zaW9uKSB7XG4gICAgcmV0dXJuIHN1bSArIGRpbWVuc2lvbi5jbGllbnQubWFyZ2luQm94W2F4aXMuc2l6ZV07XG4gIH0sIDApO1xuICB2YXIgcmVxdWlyZWRTcGFjZSA9IHNwYWNlVXNlZCArIHBsYWNlaG9sZGVyU2l6ZVtheGlzLmxpbmVdO1xuICB2YXIgbmVlZHNUb0dyb3dCeSA9IHJlcXVpcmVkU3BhY2UgLSBhdmFpbGFibGVTcGFjZTtcblxuICBpZiAobmVlZHNUb0dyb3dCeSA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBuZWVkc1RvR3Jvd0J5KTtcbn07XG5cbnZhciB3aXRoTWF4U2Nyb2xsID0gZnVuY3Rpb24gd2l0aE1heFNjcm9sbChmcmFtZSwgbWF4KSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZnJhbWUsIHtcbiAgICBzY3JvbGw6IF9leHRlbmRzKHt9LCBmcmFtZS5zY3JvbGwsIHtcbiAgICAgIG1heDogbWF4XG4gICAgfSlcbiAgfSk7XG59O1xuXG52YXIgYWRkUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiBhZGRQbGFjZWhvbGRlcihkcm9wcGFibGUsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcykge1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gICEhaXNIb21lT2YoZHJhZ2dhYmxlLCBkcm9wcGFibGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIG5vdCBhZGQgcGxhY2Vob2xkZXIgc3BhY2UgdG8gaG9tZSBsaXN0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhIWRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBhZGQgcGxhY2Vob2xkZXIgc2l6ZSB0byBhIHN1YmplY3Qgd2hlbiBpdCBhbHJlYWR5IGhhcyBvbmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBwbGFjZWhvbGRlclNpemUgPSBnZXREaXNwbGFjZWRCeShkcm9wcGFibGUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpLnBvaW50O1xuICB2YXIgcmVxdWlyZWRHcm93dGggPSBnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyKGRyb3BwYWJsZSwgcGxhY2Vob2xkZXJTaXplLCBkcmFnZ2FibGVzKTtcbiAgdmFyIGFkZGVkID0ge1xuICAgIHBsYWNlaG9sZGVyU2l6ZTogcGxhY2Vob2xkZXJTaXplLFxuICAgIGluY3JlYXNlZEJ5OiByZXF1aXJlZEdyb3d0aCxcbiAgICBvbGRGcmFtZU1heFNjcm9sbDogZHJvcHBhYmxlLmZyYW1lID8gZHJvcHBhYmxlLmZyYW1lLnNjcm9sbC5tYXggOiBudWxsXG4gIH07XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHZhciBfc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogYWRkZWQsXG4gICAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICAgIGZyYW1lOiBkcm9wcGFibGUuZnJhbWVcbiAgICB9KTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZHJvcHBhYmxlLCB7XG4gICAgICBzdWJqZWN0OiBfc3ViamVjdFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1heFNjcm9sbCA9IHJlcXVpcmVkR3Jvd3RoID8gYWRkKGZyYW1lLnNjcm9sbC5tYXgsIHJlcXVpcmVkR3Jvd3RoKSA6IGZyYW1lLnNjcm9sbC5tYXg7XG4gIHZhciBuZXdGcmFtZSA9IHdpdGhNYXhTY3JvbGwoZnJhbWUsIG1heFNjcm9sbCk7XG4gIHZhciBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9KTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkcm9wcGFibGUsIHtcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9KTtcbn07XG52YXIgcmVtb3ZlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiByZW1vdmVQbGFjZWhvbGRlcihkcm9wcGFibGUpIHtcbiAgdmFyIGFkZGVkID0gZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyO1xuICAhYWRkZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVtb3ZlIHBsYWNlaG9sZGVyIGZvcm0gc3ViamVjdCB3aGVuIHRoZXJlIHdhcyBub25lJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHZhciBfc3ViamVjdDIgPSBnZXRTdWJqZWN0KHtcbiAgICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICAgIGZyYW1lOiBudWxsLFxuICAgICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRyb3BwYWJsZSwge1xuICAgICAgc3ViamVjdDogX3N1YmplY3QyXG4gICAgfSk7XG4gIH1cblxuICB2YXIgb2xkTWF4U2Nyb2xsID0gYWRkZWQub2xkRnJhbWVNYXhTY3JvbGw7XG4gICFvbGRNYXhTY3JvbGwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBkcm9wcGFibGUgd2l0aCBmcmFtZSB0byBoYXZlIG9sZCBtYXggZnJhbWUgc2Nyb2xsIHdoZW4gcmVtb3ZpbmcgcGxhY2Vob2xkZXInKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBuZXdGcmFtZSA9IHdpdGhNYXhTY3JvbGwoZnJhbWUsIG9sZE1heFNjcm9sbCk7XG4gIHZhciBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWUsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsXG4gIH0pO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGRyb3BwYWJsZSwge1xuICAgIHN1YmplY3Q6IHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH0pO1xufTtcblxudmFyIG1vdmVUb05ld0Ryb3BwYWJsZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyID0gX3JlZi5wcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBtb3ZlUmVsYXRpdmVUbyA9IF9yZWYubW92ZVJlbGF0aXZlVG8sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuXG4gIGlmICghbW92ZVJlbGF0aXZlVG8pIHtcbiAgICBpZiAoaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcHJvcG9zZWQgPSB7XG4gICAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICAgICAgZGlzcGxhY2VkQnk6IG5vRGlzcGxhY2VkQnksXG4gICAgICBhdDoge1xuICAgICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICAgIGltcGFjdDogcHJvcG9zZWQsXG4gICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICAgIH0pO1xuICAgIHZhciB3aXRoUGxhY2Vob2xkZXIgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKSA/IGRlc3RpbmF0aW9uIDogYWRkUGxhY2Vob2xkZXIoZGVzdGluYXRpb24sIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcyk7XG4gICAgdmFyIGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgIGRlc3RpbmF0aW9uOiB3aXRoUGxhY2Vob2xkZXIsXG4gICAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyOiBwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiBmYWxzZSxcbiAgICAgIG9ubHlPbk1haW5BeGlzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPyBwcm9wb3NlZCA6IG51bGw7XG4gIH1cblxuICB2YXIgaXNHb2luZ0JlZm9yZVRhcmdldCA9IEJvb2xlYW4ocHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyW2Rlc3RpbmF0aW9uLmF4aXMubGluZV0gPD0gbW92ZVJlbGF0aXZlVG8ucGFnZS5ib3JkZXJCb3guY2VudGVyW2Rlc3RpbmF0aW9uLmF4aXMubGluZV0pO1xuXG4gIHZhciBwcm9wb3NlZEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWxhdGl2ZVRvID0gbW92ZVJlbGF0aXZlVG8uZGVzY3JpcHRvci5pbmRleDtcblxuICAgIGlmIChtb3ZlUmVsYXRpdmVUby5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCkge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgfVxuXG4gICAgaWYgKGlzR29pbmdCZWZvcmVUYXJnZXQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgIH1cblxuICAgIHJldHVybiByZWxhdGl2ZVRvICsgMTtcbiAgfSgpO1xuXG4gIHZhciBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGRlc3RpbmF0aW9uLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBsYXN0OiBlbXB0eUdyb3VwcyxcbiAgICBpbmRleDogcHJvcG9zZWRJbmRleFxuICB9KTtcbn0pO1xuXG52YXIgbW92ZUNyb3NzQXhpcyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaXNNb3ZpbmdGb3J3YXJkID0gX3JlZi5pc01vdmluZ0ZvcndhcmQsXG4gICAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIgPSBfcmVmLnByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgaXNPdmVyID0gX3JlZi5pc092ZXIsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlcyA9IF9yZWYuZHJvcHBhYmxlcyxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG4gIHZhciBkZXN0aW5hdGlvbiA9IGdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUoe1xuICAgIGlzTW92aW5nRm9yd2FyZDogaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBzb3VyY2U6IGlzT3ZlcixcbiAgICBkcm9wcGFibGVzOiBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICB9KTtcblxuICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICB2YXIgbW92ZVJlbGF0aXZlVG8gPSBnZXRDbG9zZXN0RHJhZ2dhYmxlKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgdmFyIGltcGFjdCA9IG1vdmVUb05ld0Ryb3BwYWJsZSh7XG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgbW92ZVJlbGF0aXZlVG86IG1vdmVSZWxhdGl2ZVRvLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcblxuICBpZiAoIWltcGFjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHZhciBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xpZW50U2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgfTtcbn0pO1xuXG52YXIgd2hhdElzRHJhZ2dlZE92ZXIgPSAoZnVuY3Rpb24gKGltcGFjdCkge1xuICB2YXIgYXQgPSBpbXBhY3QuYXQ7XG5cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiBhdC5kZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgfVxuXG4gIHJldHVybiBhdC5jb21iaW5lLmRyb3BwYWJsZUlkO1xufSk7XG5cbnZhciBnZXREcm9wcGFibGVPdmVyID0gZnVuY3Rpb24gZ2V0RHJvcHBhYmxlT3ZlcihpbXBhY3QsIGRyb3BwYWJsZXMpIHtcbiAgdmFyIGlkID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgcmV0dXJuIGlkID8gZHJvcHBhYmxlc1tpZF0gOiBudWxsO1xufTtcblxudmFyIG1vdmVJbkRpcmVjdGlvbiA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgdHlwZSA9IF9yZWYudHlwZTtcbiAgdmFyIGlzQWN0dWFsbHlPdmVyID0gZ2V0RHJvcHBhYmxlT3ZlcihzdGF0ZS5pbXBhY3QsIHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlcyk7XG4gIHZhciBpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkID0gQm9vbGVhbihpc0FjdHVhbGx5T3Zlcik7XG4gIHZhciBob21lID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIHZhciBpc092ZXIgPSBpc0FjdHVhbGx5T3ZlciB8fCBob21lO1xuICB2YXIgZGlyZWN0aW9uID0gaXNPdmVyLmF4aXMuZGlyZWN0aW9uO1xuICB2YXIgaXNNb3ZpbmdPbk1haW5BeGlzID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnICYmICh0eXBlID09PSAnTU9WRV9VUCcgfHwgdHlwZSA9PT0gJ01PVkVfRE9XTicpIHx8IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmICh0eXBlID09PSAnTU9WRV9MRUZUJyB8fCB0eXBlID09PSAnTU9WRV9SSUdIVCcpO1xuXG4gIGlmIChpc01vdmluZ09uTWFpbkF4aXMgJiYgIWlzTWFpbkF4aXNNb3ZlbWVudEFsbG93ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSB0eXBlID09PSAnTU9WRV9ET1dOJyB8fCB0eXBlID09PSAnTU9WRV9SSUdIVCc7XG4gIHZhciBkcmFnZ2FibGUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgdmFyIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciA9IHN0YXRlLmN1cnJlbnQucGFnZS5ib3JkZXJCb3hDZW50ZXI7XG4gIHZhciBfc3RhdGUkZGltZW5zaW9ucyA9IHN0YXRlLmRpbWVuc2lvbnMsXG4gICAgICBkcmFnZ2FibGVzID0gX3N0YXRlJGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZXMgPSBfc3RhdGUkZGltZW5zaW9ucy5kcm9wcGFibGVzO1xuICByZXR1cm4gaXNNb3ZpbmdPbk1haW5BeGlzID8gbW92ZVRvTmV4dFBsYWNlKHtcbiAgICBpc01vdmluZ0ZvcndhcmQ6IGlzTW92aW5nRm9yd2FyZCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbjogaXNPdmVyLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uOiBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24sXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pIDogbW92ZUNyb3NzQXhpcyh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkOiBpc01vdmluZ0ZvcndhcmQsXG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgaXNPdmVyOiBpc092ZXIsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnO1xufVxuXG5mdW5jdGlvbiBpc1Bvc2l0aW9uSW5GcmFtZShmcmFtZSkge1xuICB2YXIgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgdmFyIGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJ1bihwb2ludCkge1xuICAgIHJldHVybiBpc1dpdGhpblZlcnRpY2FsKHBvaW50LnkpICYmIGlzV2l0aGluSG9yaXpvbnRhbChwb2ludC54KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzT3ZlcmxhcChmaXJzdCwgc2Vjb25kKSB7XG4gIHJldHVybiBmaXJzdC5sZWZ0IDwgc2Vjb25kLnJpZ2h0ICYmIGZpcnN0LnJpZ2h0ID4gc2Vjb25kLmxlZnQgJiYgZmlyc3QudG9wIDwgc2Vjb25kLmJvdHRvbSAmJiBmaXJzdC5ib3R0b20gPiBzZWNvbmQudG9wO1xufVxuXG5mdW5jdGlvbiBnZXRGdXJ0aGVzdEF3YXkoX3JlZikge1xuICB2YXIgcGFnZUJvcmRlckJveCA9IF9yZWYucGFnZUJvcmRlckJveCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgY2FuZGlkYXRlcyA9IF9yZWYuY2FuZGlkYXRlcztcbiAgdmFyIHN0YXJ0Q2VudGVyID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgdmFyIHNvcnRlZCA9IGNhbmRpZGF0ZXMubWFwKGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICB2YXIgYXhpcyA9IGNhbmRpZGF0ZS5heGlzO1xuICAgIHZhciB0YXJnZXQgPSBwYXRjaChjYW5kaWRhdGUuYXhpcy5saW5lLCBwYWdlQm9yZGVyQm94LmNlbnRlcltheGlzLmxpbmVdLCBjYW5kaWRhdGUucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV0pO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogY2FuZGlkYXRlLmRlc2NyaXB0b3IuaWQsXG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2Uoc3RhcnRDZW50ZXIsIHRhcmdldClcbiAgICB9O1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuZGlzdGFuY2UgLSBhLmRpc3RhbmNlO1xuICB9KTtcbiAgcmV0dXJuIHNvcnRlZFswXSA/IHNvcnRlZFswXS5pZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERyb3BwYWJsZU92ZXIkMShfcmVmMikge1xuICB2YXIgcGFnZUJvcmRlckJveCA9IF9yZWYyLnBhZ2VCb3JkZXJCb3gsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmMi5kcmFnZ2FibGUsXG4gICAgICBkcm9wcGFibGVzID0gX3JlZjIuZHJvcHBhYmxlcztcbiAgdmFyIGNhbmRpZGF0ZXMgPSB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFpdGVtLmlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhY3RpdmUgPSBpdGVtLnN1YmplY3QuYWN0aXZlO1xuXG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWdldEhhc092ZXJsYXAocGFnZUJvcmRlckJveCwgYWN0aXZlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc1Bvc2l0aW9uSW5GcmFtZShhY3RpdmUpKHBhZ2VCb3JkZXJCb3guY2VudGVyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGF4aXMgPSBpdGVtLmF4aXM7XG4gICAgdmFyIGNoaWxkQ2VudGVyID0gYWN0aXZlLmNlbnRlcltheGlzLmNyb3NzQXhpc0xpbmVdO1xuICAgIHZhciBjcm9zc0F4aXNTdGFydCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgdmFyIGNyb3NzQXhpc0VuZCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIHZhciBpc0NvbnRhaW5lZCA9IGlzV2l0aGluKGFjdGl2ZVtheGlzLmNyb3NzQXhpc1N0YXJ0XSwgYWN0aXZlW2F4aXMuY3Jvc3NBeGlzRW5kXSk7XG4gICAgdmFyIGlzU3RhcnRDb250YWluZWQgPSBpc0NvbnRhaW5lZChjcm9zc0F4aXNTdGFydCk7XG4gICAgdmFyIGlzRW5kQ29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzRW5kKTtcblxuICAgIGlmICghaXNTdGFydENvbnRhaW5lZCAmJiAhaXNFbmRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc1N0YXJ0Q29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gY3Jvc3NBeGlzU3RhcnQgPCBjaGlsZENlbnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gY3Jvc3NBeGlzRW5kID4gY2hpbGRDZW50ZXI7XG4gIH0pO1xuXG4gIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjYW5kaWRhdGVzWzBdLmRlc2NyaXB0b3IuaWQ7XG4gIH1cblxuICByZXR1cm4gZ2V0RnVydGhlc3RBd2F5KHtcbiAgICBwYWdlQm9yZGVyQm94OiBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGNhbmRpZGF0ZXM6IGNhbmRpZGF0ZXNcbiAgfSk7XG59XG5cbnZhciBvZmZzZXRSZWN0QnlQb3NpdGlvbiA9IGZ1bmN0aW9uIG9mZnNldFJlY3RCeVBvc2l0aW9uKHJlY3QsIHBvaW50KSB7XG4gIHJldHVybiBnZXRSZWN0KG9mZnNldEJ5UG9zaXRpb24ocmVjdCwgcG9pbnQpKTtcbn07XG5cbnZhciB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gKGZ1bmN0aW9uIChkcm9wcGFibGUsIGFyZWEpIHtcbiAgdmFyIGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuXG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRSZWN0QnlQb3NpdGlvbihhcmVhLCBmcmFtZS5zY3JvbGwuZGlmZi52YWx1ZSk7XG59KTtcblxuZnVuY3Rpb24gZ2V0SXNEaXNwbGFjZWQoX3JlZikge1xuICB2YXIgZGlzcGxhY2VkID0gX3JlZi5kaXNwbGFjZWQsXG4gICAgICBpZCA9IF9yZWYuaWQ7XG4gIHJldHVybiBCb29sZWFuKGRpc3BsYWNlZC52aXNpYmxlW2lkXSB8fCBkaXNwbGFjZWQuaW52aXNpYmxlW2lkXSk7XG59XG5cbmZ1bmN0aW9uIGF0SW5kZXgoX3JlZikge1xuICB2YXIgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBjbG9zZXN0ID0gX3JlZi5jbG9zZXN0LFxuICAgICAgaW5Ib21lTGlzdCA9IF9yZWYuaW5Ib21lTGlzdDtcblxuICBpZiAoIWNsb3Nlc3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG4gIH1cblxuICBpZiAoY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4ID4gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaW5kZXgpIHtcbiAgICByZXR1cm4gY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4IC0gMTtcbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG59XG5cbnZhciBnZXRSZW9yZGVySW1wYWN0ID0gKGZ1bmN0aW9uIChfcmVmMikge1xuICB2YXIgdGFyZ2V0UmVjdCA9IF9yZWYyLnBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsLFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZjIuZHJhZ2dhYmxlLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmMi5kZXN0aW5hdGlvbixcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZjIuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBsYXN0ID0gX3JlZjIubGFzdCxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZjIudmlld3BvcnQsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZjIuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIGF4aXMgPSBkZXN0aW5hdGlvbi5heGlzO1xuICB2YXIgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIHZhciBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFtheGlzLnN0YXJ0XTtcbiAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbYXhpcy5lbmRdO1xuICB2YXIgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIHZhciBjbG9zZXN0ID0gZmluZCh3aXRob3V0RHJhZ2dpbmcsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciBpZCA9IGNoaWxkLmRlc2NyaXB0b3IuaWQ7XG4gICAgdmFyIGNoaWxkQ2VudGVyID0gY2hpbGQucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMubGluZV07XG4gICAgdmFyIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGlkLCBhZnRlckNyaXRpY2FsKTtcbiAgICB2YXIgaXNEaXNwbGFjZWQgPSBnZXRJc0Rpc3BsYWNlZCh7XG4gICAgICBkaXNwbGFjZWQ6IGxhc3QsXG4gICAgICBpZDogaWRcbiAgICB9KTtcblxuICAgIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSkge1xuICAgICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRFbmQgPD0gY2hpbGRDZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRTdGFydCA8IGNoaWxkQ2VudGVyIC0gZGlzcGxhY2VtZW50O1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA8PSBjaGlsZENlbnRlciArIGRpc3BsYWNlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPCBjaGlsZENlbnRlcjtcbiAgfSk7XG4gIHZhciBuZXdJbmRleCA9IGF0SW5kZXgoe1xuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gICAgaW5Ib21lTGlzdDogaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbilcbiAgfSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBsYXN0OiBsYXN0LFxuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59KTtcblxudmFyIGNvbWJpbmVUaHJlc2hvbGREaXZpc29yID0gNDtcbnZhciBnZXRDb21iaW5lSW1wYWN0ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIHRhcmdldFJlY3QgPSBfcmVmLnBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsLFxuICAgICAgcHJldmlvdXNJbXBhY3QgPSBfcmVmLnByZXZpb3VzSW1wYWN0LFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcblxuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBheGlzID0gZGVzdGluYXRpb24uYXhpcztcbiAgdmFyIGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICB2YXIgZGlzcGxhY2VtZW50ID0gZGlzcGxhY2VkQnkudmFsdWU7XG4gIHZhciB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbYXhpcy5zdGFydF07XG4gIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgdmFyIHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICB2YXIgY29tYmluZVdpdGggPSBmaW5kKHdpdGhvdXREcmFnZ2luZywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIGlkID0gY2hpbGQuZGVzY3JpcHRvci5pZDtcbiAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQucGFnZS5ib3JkZXJCb3g7XG4gICAgdmFyIGNoaWxkU2l6ZSA9IGNoaWxkUmVjdFtheGlzLnNpemVdO1xuICAgIHZhciB0aHJlc2hvbGQgPSBjaGlsZFNpemUgLyBjb21iaW5lVGhyZXNob2xkRGl2aXNvcjtcbiAgICB2YXIgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIHZhciBpc0Rpc3BsYWNlZCA9IGdldElzRGlzcGxhY2VkKHtcbiAgICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgaWQ6IGlkXG4gICAgfSk7XG5cbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldEVuZCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSB0aHJlc2hvbGQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRTdGFydCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSAtIGRpc3BsYWNlbWVudCArIHRocmVzaG9sZCAmJiB0YXJnZXRTdGFydCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSBkaXNwbGFjZW1lbnQgLSB0aHJlc2hvbGQ7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0RW5kID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgZGlzcGxhY2VtZW50ICsgdGhyZXNob2xkICYmIHRhcmdldEVuZCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gKyBkaXNwbGFjZW1lbnQgLSB0aHJlc2hvbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0ID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldFN0YXJ0IDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIHRocmVzaG9sZDtcbiAgfSk7XG5cbiAgaWYgKCFjb21iaW5lV2l0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGltcGFjdCA9IHtcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdDT01CSU5FJyxcbiAgICAgIGNvbWJpbmU6IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IGNvbWJpbmVXaXRoLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gaW1wYWN0O1xufSk7XG5cbnZhciBnZXREcmFnSW1wYWN0ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwYWdlT2Zmc2V0ID0gX3JlZi5wYWdlT2Zmc2V0LFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlcyA9IF9yZWYuZHJvcHBhYmxlcyxcbiAgICAgIHByZXZpb3VzSW1wYWN0ID0gX3JlZi5wcmV2aW91c0ltcGFjdCxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG4gIHZhciBwYWdlQm9yZGVyQm94ID0gb2Zmc2V0UmVjdEJ5UG9zaXRpb24oZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LCBwYWdlT2Zmc2V0KTtcbiAgdmFyIGRlc3RpbmF0aW9uSWQgPSBnZXREcm9wcGFibGVPdmVyJDEoe1xuICAgIHBhZ2VCb3JkZXJCb3g6IHBhZ2VCb3JkZXJCb3gsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlczogZHJvcHBhYmxlc1xuICB9KTtcblxuICBpZiAoIWRlc3RpbmF0aW9uSWQpIHtcbiAgICByZXR1cm4gbm9JbXBhY3Q7XG4gIH1cblxuICB2YXIgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uSWRdO1xuICB2YXIgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICB2YXIgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwgPSB3aXRoRHJvcHBhYmxlU2Nyb2xsKGRlc3RpbmF0aW9uLCBwYWdlQm9yZGVyQm94KTtcbiAgcmV0dXJuIGdldENvbWJpbmVJbXBhY3Qoe1xuICAgIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsOiBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBwcmV2aW91c0ltcGFjdDogcHJldmlvdXNJbXBhY3QsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pIHx8IGdldFJlb3JkZXJJbXBhY3Qoe1xuICAgIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsOiBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn0pO1xuXG52YXIgcGF0Y2hEcm9wcGFibGVNYXAgPSAoZnVuY3Rpb24gKGRyb3BwYWJsZXMsIHVwZGF0ZWQpIHtcbiAgdmFyIF9leHRlbmRzMjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGRyb3BwYWJsZXMsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW3VwZGF0ZWQuZGVzY3JpcHRvci5pZF0gPSB1cGRhdGVkLCBfZXh0ZW5kczIpKTtcbn0pO1xuXG52YXIgY2xlYXJVbnVzZWRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIGNsZWFyVW51c2VkUGxhY2Vob2xkZXIoX3JlZikge1xuICB2YXIgcHJldmlvdXNJbXBhY3QgPSBfcmVmLnByZXZpb3VzSW1wYWN0LFxuICAgICAgaW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICBkcm9wcGFibGVzID0gX3JlZi5kcm9wcGFibGVzO1xuICB2YXIgbGFzdCA9IHdoYXRJc0RyYWdnZWRPdmVyKHByZXZpb3VzSW1wYWN0KTtcbiAgdmFyIG5vdyA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG5cbiAgaWYgKCFsYXN0KSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cblxuICBpZiAobGFzdCA9PT0gbm93KSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cblxuICB2YXIgbGFzdERyb3BwYWJsZSA9IGRyb3BwYWJsZXNbbGFzdF07XG5cbiAgaWYgKCFsYXN0RHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cblxuICB2YXIgdXBkYXRlZCA9IHJlbW92ZVBsYWNlaG9sZGVyKGxhc3REcm9wcGFibGUpO1xuICByZXR1cm4gcGF0Y2hEcm9wcGFibGVNYXAoZHJvcHBhYmxlcywgdXBkYXRlZCk7XG59O1xuXG52YXIgcmVjb21wdXRlUGxhY2Vob2xkZXJzID0gKGZ1bmN0aW9uIChfcmVmMikge1xuICB2YXIgZHJhZ2dhYmxlID0gX3JlZjIuZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYyLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzID0gX3JlZjIuZHJvcHBhYmxlcyxcbiAgICAgIHByZXZpb3VzSW1wYWN0ID0gX3JlZjIucHJldmlvdXNJbXBhY3QsXG4gICAgICBpbXBhY3QgPSBfcmVmMi5pbXBhY3Q7XG4gIHZhciBjbGVhbmVkID0gY2xlYXJVbnVzZWRQbGFjZWhvbGRlcih7XG4gICAgcHJldmlvdXNJbXBhY3Q6IHByZXZpb3VzSW1wYWN0LFxuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGRyb3BwYWJsZXM6IGRyb3BwYWJsZXNcbiAgfSk7XG4gIHZhciBpc092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuXG4gIGlmICghaXNPdmVyKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cblxuICB2YXIgZHJvcHBhYmxlID0gZHJvcHBhYmxlc1tpc092ZXJdO1xuXG4gIGlmIChpc0hvbWVPZihkcmFnZ2FibGUsIGRyb3BwYWJsZSkpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuXG4gIGlmIChkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuXG4gIHZhciBwYXRjaGVkID0gYWRkUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpO1xuICByZXR1cm4gcGF0Y2hEcm9wcGFibGVNYXAoY2xlYW5lZCwgcGF0Y2hlZCk7XG59KTtcblxudmFyIHVwZGF0ZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgZm9yY2VkQ2xpZW50U2VsZWN0aW9uID0gX3JlZi5jbGllbnRTZWxlY3Rpb24sXG4gICAgICBmb3JjZWREaW1lbnNpb25zID0gX3JlZi5kaW1lbnNpb25zLFxuICAgICAgZm9yY2VkVmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgZm9yY2VkSW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdCA9IF9yZWYuc2Nyb2xsSnVtcFJlcXVlc3Q7XG4gIHZhciB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICB2YXIgZGltZW5zaW9ucyA9IGZvcmNlZERpbWVuc2lvbnMgfHwgc3RhdGUuZGltZW5zaW9ucztcbiAgdmFyIGNsaWVudFNlbGVjdGlvbiA9IGZvcmNlZENsaWVudFNlbGVjdGlvbiB8fCBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb247XG4gIHZhciBvZmZzZXQgPSBzdWJ0cmFjdChjbGllbnRTZWxlY3Rpb24sIHN0YXRlLmluaXRpYWwuY2xpZW50LnNlbGVjdGlvbik7XG4gIHZhciBjbGllbnQgPSB7XG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoc3RhdGUuaW5pdGlhbC5jbGllbnQuYm9yZGVyQm94Q2VudGVyLCBvZmZzZXQpXG4gIH07XG4gIHZhciBwYWdlID0ge1xuICAgIHNlbGVjdGlvbjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50KSxcbiAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChjbGllbnQuYm9yZGVyQm94Q2VudGVyLCB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCksXG4gICAgb2Zmc2V0OiBhZGQoY2xpZW50Lm9mZnNldCwgdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWUpXG4gIH07XG4gIHZhciBjdXJyZW50ID0ge1xuICAgIGNsaWVudDogY2xpZW50LFxuICAgIHBhZ2U6IHBhZ2VcbiAgfTtcblxuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBwaGFzZTogJ0NPTExFQ1RJTkcnXG4gICAgfSwgc3RhdGUsIHtcbiAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBjdXJyZW50OiBjdXJyZW50XG4gICAgfSk7XG4gIH1cblxuICB2YXIgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIHZhciBuZXdJbXBhY3QgPSBmb3JjZWRJbXBhY3QgfHwgZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogcGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICBwcmV2aW91c0ltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICB2YXIgd2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnMgPSByZWNvbXB1dGVQbGFjZWhvbGRlcnMoe1xuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcblxuICB2YXIgcmVzdWx0ID0gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgY3VycmVudDogY3VycmVudCxcbiAgICBkaW1lbnNpb25zOiB7XG4gICAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzOiB3aXRoVXBkYXRlZFBsYWNlaG9sZGVyc1xuICAgIH0sXG4gICAgaW1wYWN0OiBuZXdJbXBhY3QsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBzY3JvbGxKdW1wUmVxdWVzdCB8fCBudWxsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogc2Nyb2xsSnVtcFJlcXVlc3QgPyBmYWxzZSA6IG51bGxcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVzJDEoaWRzLCBkcmFnZ2FibGVzKSB7XG4gIHJldHVybiBpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBkcmFnZ2FibGVzW2lkXTtcbiAgfSk7XG59XG5cbnZhciByZWNvbXB1dGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSA9IF9yZWYuZm9yY2VTaG91bGRBbmltYXRlO1xuICB2YXIgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIHZhciBhZnRlckRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlcyQxKGxhc3QuYWxsLCBkcmFnZ2FibGVzKTtcbiAgdmFyIGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogYWZ0ZXJEcmFnZ2luZyxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmb3JjZVNob3VsZEFuaW1hdGUsXG4gICAgbGFzdDogbGFzdFxuICB9KTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBpbXBhY3QsIHtcbiAgICBkaXNwbGFjZWQ6IGRpc3BsYWNlZFxuICB9KTtcbn0pO1xuXG52YXIgZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZHJvcHBhYmxlID0gX3JlZi5kcm9wcGFibGUsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGU6IGRyb3BwYWJsZSxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICByZXR1cm4gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gIH0pO1xufSk7XG5cbnZhciByZWZyZXNoU25hcCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgZm9yY2VkRGltZW5zaW9ucyA9IF9yZWYuZGltZW5zaW9ucyxcbiAgICAgIGZvcmNlZFZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydDtcbiAgIShzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5lZWRzVmlzaWJpbGl0eUNoZWNrID0gc3RhdGUuaW1wYWN0O1xuICB2YXIgdmlld3BvcnQgPSBmb3JjZWRWaWV3cG9ydCB8fCBzdGF0ZS52aWV3cG9ydDtcbiAgdmFyIGRpbWVuc2lvbnMgPSBmb3JjZWREaW1lbnNpb25zIHx8IHN0YXRlLmRpbWVuc2lvbnM7XG4gIHZhciBkcmFnZ2FibGVzID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlcyA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlcztcbiAgdmFyIGRyYWdnYWJsZSA9IGRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgdmFyIGlzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKG5lZWRzVmlzaWJpbGl0eUNoZWNrKTtcbiAgIWlzT3ZlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgb3ZlciBhIGRlc3RpbmF0aW9uIGluIFNOQVAgbW92ZW1lbnQgbW9kZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlc1tpc092ZXJdO1xuICB2YXIgaW1wYWN0ID0gcmVjb21wdXRlKHtcbiAgICBpbXBhY3Q6IG5lZWRzVmlzaWJpbGl0eUNoZWNrLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlc1xuICB9KTtcbiAgdmFyIGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEJvcmRlckJveENlbnRlcih7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICByZXR1cm4gdXBkYXRlKHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBjbGllbnRTZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgfSk7XG59KTtcblxudmFyIGdldEhvbWVMb2NhdGlvbiA9IChmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICByZXR1cm4ge1xuICAgIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gIH07XG59KTtcblxudmFyIGdldExpZnRFZmZlY3QgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgaG9tZSA9IF9yZWYuaG9tZSxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQ7XG4gIHZhciBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGhvbWUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICB2YXIgaW5zaWRlSG9tZSA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoaG9tZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgdmFyIHJhd0luZGV4ID0gaW5zaWRlSG9tZS5pbmRleE9mKGRyYWdnYWJsZSk7XG4gICEocmF3SW5kZXggIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGRyYWdnYWJsZSB0byBiZSBpbnNpZGUgaG9tZSBsaXN0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgYWZ0ZXJEcmFnZ2luZyA9IGluc2lkZUhvbWUuc2xpY2UocmF3SW5kZXggKyAxKTtcbiAgdmFyIGVmZmVjdGVkID0gYWZ0ZXJEcmFnZ2luZy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBpdGVtKSB7XG4gICAgcHJldmlvdXNbaXRlbS5kZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LCB7fSk7XG4gIHZhciBhZnRlckNyaXRpY2FsID0ge1xuICAgIGluVmlydHVhbExpc3Q6IGhvbWUuZGVzY3JpcHRvci5tb2RlID09PSAndmlydHVhbCcsXG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGVmZmVjdGVkOiBlZmZlY3RlZFxuICB9O1xuICB2YXIgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBhZnRlckRyYWdnaW5nLFxuICAgIGRlc3RpbmF0aW9uOiBob21lLFxuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBsYXN0OiBudWxsLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICB2YXIgaW1wYWN0ID0ge1xuICAgIGRpc3BsYWNlZDogZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IGdldEhvbWVMb2NhdGlvbihkcmFnZ2FibGUuZGVzY3JpcHRvcilcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9O1xufSk7XG5cbnZhciBwYXRjaERpbWVuc2lvbk1hcCA9IChmdW5jdGlvbiAoZGltZW5zaW9ucywgdXBkYXRlZCkge1xuICByZXR1cm4ge1xuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBwYXRjaERyb3BwYWJsZU1hcChkaW1lbnNpb25zLmRyb3BwYWJsZXMsIHVwZGF0ZWQpXG4gIH07XG59KTtcblxudmFyIHN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoa2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcbnZhciBmaW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goa2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxudmFyIG9mZnNldERyYWdnYWJsZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBvZmZzZXQkMSA9IF9yZWYub2Zmc2V0LFxuICAgICAgaW5pdGlhbFdpbmRvd1Njcm9sbCA9IF9yZWYuaW5pdGlhbFdpbmRvd1Njcm9sbDtcbiAgdmFyIGNsaWVudCA9IG9mZnNldChkcmFnZ2FibGUuY2xpZW50LCBvZmZzZXQkMSk7XG4gIHZhciBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIGluaXRpYWxXaW5kb3dTY3JvbGwpO1xuXG4gIHZhciBtb3ZlZCA9IF9leHRlbmRzKHt9LCBkcmFnZ2FibGUsIHtcbiAgICBwbGFjZWhvbGRlcjogX2V4dGVuZHMoe30sIGRyYWdnYWJsZS5wbGFjZWhvbGRlciwge1xuICAgICAgY2xpZW50OiBjbGllbnRcbiAgICB9KSxcbiAgICBjbGllbnQ6IGNsaWVudCxcbiAgICBwYWdlOiBwYWdlXG4gIH0pO1xuXG4gIHJldHVybiBtb3ZlZDtcbn0pO1xuXG52YXIgZ2V0RnJhbWUgPSAoZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gICFmcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIERyb3BwYWJsZSB0byBoYXZlIGEgZnJhbWUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmcmFtZTtcbn0pO1xuXG52YXIgYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgYWRkaXRpb25zID0gX3JlZi5hZGRpdGlvbnMsXG4gICAgICB1cGRhdGVkRHJvcHBhYmxlcyA9IF9yZWYudXBkYXRlZERyb3BwYWJsZXMsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQ7XG4gIHZhciB3aW5kb3dTY3JvbGxDaGFuZ2UgPSB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZTtcbiAgcmV0dXJuIGFkZGl0aW9ucy5tYXAoZnVuY3Rpb24gKGRyYWdnYWJsZSkge1xuICAgIHZhciBkcm9wcGFibGVJZCA9IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkO1xuICAgIHZhciBtb2RpZmllZCA9IHVwZGF0ZWREcm9wcGFibGVzW2Ryb3BwYWJsZUlkXTtcbiAgICB2YXIgZnJhbWUgPSBnZXRGcmFtZShtb2RpZmllZCk7XG4gICAgdmFyIGRyb3BwYWJsZVNjcm9sbENoYW5nZSA9IGZyYW1lLnNjcm9sbC5kaWZmLnZhbHVlO1xuICAgIHZhciB0b3RhbENoYW5nZSA9IGFkZCh3aW5kb3dTY3JvbGxDaGFuZ2UsIGRyb3BwYWJsZVNjcm9sbENoYW5nZSk7XG4gICAgdmFyIG1vdmVkID0gb2Zmc2V0RHJhZ2dhYmxlKHtcbiAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgb2Zmc2V0OiB0b3RhbENoYW5nZSxcbiAgICAgIGluaXRpYWxXaW5kb3dTY3JvbGw6IHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1vdmVkO1xuICB9KTtcbn0pO1xuXG52YXIgcHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIHB1Ymxpc2hlZCA9IF9yZWYucHVibGlzaGVkO1xuICBzdGFydCgpO1xuICB2YXIgd2l0aFNjcm9sbENoYW5nZSA9IHB1Ymxpc2hlZC5tb2RpZmllZC5tYXAoZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgIHZhciBleGlzdGluZyA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1t1cGRhdGUuZHJvcHBhYmxlSWRdO1xuICAgIHZhciBzY3JvbGxlZCA9IHNjcm9sbERyb3BwYWJsZShleGlzdGluZywgdXBkYXRlLnNjcm9sbCk7XG4gICAgcmV0dXJuIHNjcm9sbGVkO1xuICB9KTtcblxuICB2YXIgZHJvcHBhYmxlcyA9IF9leHRlbmRzKHt9LCBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXMsIHt9LCB0b0Ryb3BwYWJsZU1hcCh3aXRoU2Nyb2xsQ2hhbmdlKSk7XG5cbiAgdmFyIHVwZGF0ZWRBZGRpdGlvbnMgPSB0b0RyYWdnYWJsZU1hcChhZGp1c3RBZGRpdGlvbnNGb3JTY3JvbGxDaGFuZ2VzKHtcbiAgICBhZGRpdGlvbnM6IHB1Ymxpc2hlZC5hZGRpdGlvbnMsXG4gICAgdXBkYXRlZERyb3BwYWJsZXM6IGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0XG4gIH0pKTtcblxuICB2YXIgZHJhZ2dhYmxlcyA9IF9leHRlbmRzKHt9LCBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXMsIHt9LCB1cGRhdGVkQWRkaXRpb25zKTtcblxuICBwdWJsaXNoZWQucmVtb3ZhbHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICBkZWxldGUgZHJhZ2dhYmxlc1tpZF07XG4gIH0pO1xuICB2YXIgZGltZW5zaW9ucyA9IHtcbiAgICBkcm9wcGFibGVzOiBkcm9wcGFibGVzLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXNcbiAgfTtcbiAgdmFyIHdhc092ZXJJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gIHZhciB3YXNPdmVyID0gd2FzT3ZlcklkID8gZGltZW5zaW9ucy5kcm9wcGFibGVzW3dhc092ZXJJZF0gOiBudWxsO1xuICB2YXIgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIHZhciBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG5cbiAgdmFyIF9nZXRMaWZ0RWZmZWN0ID0gZ2V0TGlmdEVmZmVjdCh7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgaG9tZTogaG9tZSxcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KSxcbiAgICAgIG9uTGlmdEltcGFjdCA9IF9nZXRMaWZ0RWZmZWN0LmltcGFjdCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfZ2V0TGlmdEVmZmVjdC5hZnRlckNyaXRpY2FsO1xuXG4gIHZhciBwcmV2aW91c0ltcGFjdCA9IHdhc092ZXIgJiYgd2FzT3Zlci5pc0NvbWJpbmVFbmFibGVkID8gc3RhdGUuaW1wYWN0IDogb25MaWZ0SW1wYWN0O1xuICB2YXIgaW1wYWN0ID0gZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogc3RhdGUuY3VycmVudC5wYWdlLm9mZnNldCxcbiAgICBkcmFnZ2FibGU6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBmaW5pc2goKTtcblxuICB2YXIgZHJhZ2dpbmdTdGF0ZSA9IF9leHRlbmRzKHtcbiAgICBwaGFzZTogJ0RSQUdHSU5HJ1xuICB9LCBzdGF0ZSwge1xuICAgIHBoYXNlOiAnRFJBR0dJTkcnLFxuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIG9uTGlmdEltcGFjdDogb25MaWZ0SW1wYWN0LFxuICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuXG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nU3RhdGU7XG4gIH1cblxuICB2YXIgZHJvcFBlbmRpbmcgPSBfZXh0ZW5kcyh7XG4gICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnXG4gIH0sIGRyYWdnaW5nU3RhdGUsIHtcbiAgICBwaGFzZTogJ0RST1BfUEVORElORycsXG4gICAgcmVhc29uOiBzdGF0ZS5yZWFzb24sXG4gICAgaXNXYWl0aW5nOiBmYWxzZVxuICB9KTtcblxuICByZXR1cm4gZHJvcFBlbmRpbmc7XG59KTtcblxudmFyIGlzU25hcHBpbmcgPSBmdW5jdGlvbiBpc1NuYXBwaW5nKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJztcbn07XG5cbnZhciBwb3N0RHJvcHBhYmxlQ2hhbmdlID0gZnVuY3Rpb24gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgdXBkYXRlZCwgaXNFbmFibGVkQ2hhbmdpbmcpIHtcbiAgdmFyIGRpbWVuc2lvbnMgPSBwYXRjaERpbWVuc2lvbk1hcChzdGF0ZS5kaW1lbnNpb25zLCB1cGRhdGVkKTtcblxuICBpZiAoIWlzU25hcHBpbmcoc3RhdGUpIHx8IGlzRW5hYmxlZENoYW5naW5nKSB7XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVmcmVzaFNuYXAoe1xuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmlzRHJhZ2dpbmcgJiYgc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCcpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgcGhhc2U6ICdEUkFHR0lORydcbiAgICB9LCBzdGF0ZSwge1xuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxudmFyIGlkbGUgPSB7XG4gIHBoYXNlOiAnSURMRScsXG4gIGNvbXBsZXRlZDogbnVsbCxcbiAgc2hvdWxkRmx1c2g6IGZhbHNlXG59O1xudmFyIHJlZHVjZXIgPSAoZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICBzdGF0ZSA9IGlkbGU7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGlkbGUsIHtcbiAgICAgIHNob3VsZEZsdXNoOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0lOSVRJQUxfUFVCTElTSCBtdXN0IGNvbWUgYWZ0ZXIgYSBJRExFIHBoYXNlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfYWN0aW9uJHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgY3JpdGljYWwgPSBfYWN0aW9uJHBheWxvYWQuY3JpdGljYWwsXG4gICAgICAgIGNsaWVudFNlbGVjdGlvbiA9IF9hY3Rpb24kcGF5bG9hZC5jbGllbnRTZWxlY3Rpb24sXG4gICAgICAgIHZpZXdwb3J0ID0gX2FjdGlvbiRwYXlsb2FkLnZpZXdwb3J0LFxuICAgICAgICBkaW1lbnNpb25zID0gX2FjdGlvbiRwYXlsb2FkLmRpbWVuc2lvbnMsXG4gICAgICAgIG1vdmVtZW50TW9kZSA9IF9hY3Rpb24kcGF5bG9hZC5tb3ZlbWVudE1vZGU7XG4gICAgdmFyIGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tjcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICAgIHZhciBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW2NyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gICAgdmFyIGNsaWVudCA9IHtcbiAgICAgIHNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgICAgYm9yZGVyQm94Q2VudGVyOiBkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIsXG4gICAgICBvZmZzZXQ6IG9yaWdpblxuICAgIH07XG4gICAgdmFyIGluaXRpYWwgPSB7XG4gICAgICBjbGllbnQ6IGNsaWVudCxcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpLFxuICAgICAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCksXG4gICAgICAgIG9mZnNldDogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlKVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGlzV2luZG93U2Nyb2xsQWxsb3dlZCA9IHRvRHJvcHBhYmxlTGlzdChkaW1lbnNpb25zLmRyb3BwYWJsZXMpLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gIWl0ZW0uaXNGaXhlZE9uUGFnZTtcbiAgICB9KTtcblxuICAgIHZhciBfZ2V0TGlmdEVmZmVjdCA9IGdldExpZnRFZmZlY3Qoe1xuICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICBob21lOiBob21lLFxuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gICAgfSksXG4gICAgICAgIGltcGFjdCA9IF9nZXRMaWZ0RWZmZWN0LmltcGFjdCxcbiAgICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9nZXRMaWZ0RWZmZWN0LmFmdGVyQ3JpdGljYWw7XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgcGhhc2U6ICdEUkFHR0lORycsXG4gICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgY3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgbW92ZW1lbnRNb2RlOiBtb3ZlbWVudE1vZGUsXG4gICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgaW5pdGlhbDogaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWwsXG4gICAgICBpc1dpbmRvd1Njcm9sbEFsbG93ZWQ6IGlzV2luZG93U2Nyb2xsQWxsb3dlZCxcbiAgICAgIGltcGFjdDogaW1wYWN0LFxuICAgICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbCxcbiAgICAgIG9uTGlmdEltcGFjdDogaW1wYWN0LFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGwsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdDT0xMRUNUSU9OX1NUQVJUSU5HJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNvbGxlY3Rpb24gY2Fubm90IHN0YXJ0IGZyb20gcGhhc2UgXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIF9yZXN1bHQgPSBfZXh0ZW5kcyh7XG4gICAgICBwaGFzZTogJ0NPTExFQ1RJTkcnXG4gICAgfSwgc3RhdGUsIHtcbiAgICAgIHBoYXNlOiAnQ09MTEVDVElORydcbiAgICB9KTtcblxuICAgIHJldHVybiBfcmVzdWx0O1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnUFVCTElTSF9XSElMRV9EUkFHR0lORycpIHtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJVbmV4cGVjdGVkIFwiICsgYWN0aW9uLnR5cGUgKyBcIiByZWNlaXZlZCBpbiBwaGFzZSBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHB1Ymxpc2hlZDogYWN0aW9uLnBheWxvYWRcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkUnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGFjdGlvbi50eXBlICsgXCIgbm90IHBlcm1pdHRlZCBpbiBwaGFzZSBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9jbGllbnRTZWxlY3Rpb24gPSBhY3Rpb24ucGF5bG9hZC5jbGllbnQ7XG5cbiAgICBpZiAoaXNFcXVhbChfY2xpZW50U2VsZWN0aW9uLCBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBjbGllbnRTZWxlY3Rpb246IF9jbGllbnRTZWxlY3Rpb24sXG4gICAgICBpbXBhY3Q6IGlzU25hcHBpbmcoc3RhdGUpID8gc3RhdGUuaW1wYWN0IDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9TQ1JPTEwnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBhY3Rpb24udHlwZSArIFwiIG5vdCBwZXJtaXR0ZWQgaW4gcGhhc2UgXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfYWN0aW9uJHBheWxvYWQyID0gYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIGlkID0gX2FjdGlvbiRwYXlsb2FkMi5pZCxcbiAgICAgICAgbmV3U2Nyb2xsID0gX2FjdGlvbiRwYXlsb2FkMi5uZXdTY3JvbGw7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tpZF07XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxlZCA9IHNjcm9sbERyb3BwYWJsZSh0YXJnZXQsIG5ld1Njcm9sbCk7XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHNjcm9sbGVkLCBmYWxzZSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX0lTX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlIFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgX2FjdGlvbiRwYXlsb2FkMyA9IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICBfaWQgPSBfYWN0aW9uJHBheWxvYWQzLmlkLFxuICAgICAgICBpc0VuYWJsZWQgPSBfYWN0aW9uJHBheWxvYWQzLmlzRW5hYmxlZDtcbiAgICB2YXIgX3RhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tfaWRdO1xuICAgICFfdGFyZ2V0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBmaW5kIERyb3BwYWJsZVtpZDogXCIgKyBfaWQgKyBcIl0gdG8gdG9nZ2xlIGl0cyBlbmFibGVkIHN0YXRlXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKF90YXJnZXQuaXNFbmFibGVkICE9PSBpc0VuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIlRyeWluZyB0byBzZXQgZHJvcHBhYmxlIGlzRW5hYmxlZCB0byBcIiArIFN0cmluZyhpc0VuYWJsZWQpICsgXCJcXG4gICAgICBidXQgaXQgaXMgYWxyZWFkeSBcIiArIFN0cmluZyhfdGFyZ2V0LmlzRW5hYmxlZCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciB1cGRhdGVkID0gX2V4dGVuZHMoe30sIF90YXJnZXQsIHtcbiAgICAgIGlzRW5hYmxlZDogaXNFbmFibGVkXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgdXBkYXRlZCwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX0lTX0NPTUJJTkVfRU5BQkxFRCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJBdHRlbXB0aW5nIHRvIG1vdmUgaW4gYW4gdW5zdXBwb3J0ZWQgcGhhc2UgXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfYWN0aW9uJHBheWxvYWQ0ID0gYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIF9pZDIgPSBfYWN0aW9uJHBheWxvYWQ0LmlkLFxuICAgICAgICBpc0NvbWJpbmVFbmFibGVkID0gX2FjdGlvbiRwYXlsb2FkNC5pc0NvbWJpbmVFbmFibGVkO1xuICAgIHZhciBfdGFyZ2V0MiA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tfaWQyXTtcbiAgICAhX3RhcmdldDIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IGZpbmQgRHJvcHBhYmxlW2lkOiBcIiArIF9pZDIgKyBcIl0gdG8gdG9nZ2xlIGl0cyBpc0NvbWJpbmVFbmFibGVkIHN0YXRlXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKF90YXJnZXQyLmlzQ29tYmluZUVuYWJsZWQgIT09IGlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIlRyeWluZyB0byBzZXQgZHJvcHBhYmxlIGlzQ29tYmluZUVuYWJsZWQgdG8gXCIgKyBTdHJpbmcoaXNDb21iaW5lRW5hYmxlZCkgKyBcIlxcbiAgICAgIGJ1dCBpdCBpcyBhbHJlYWR5IFwiICsgU3RyaW5nKF90YXJnZXQyLmlzQ29tYmluZUVuYWJsZWQpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgX3VwZGF0ZWQgPSBfZXh0ZW5kcyh7fSwgX3RhcmdldDIsIHtcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQ6IGlzQ29tYmluZUVuYWJsZWRcbiAgICB9KTtcblxuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCBfdXBkYXRlZCwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0JZX1dJTkRPV19TQ1JPTEwnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IG1vdmUgYnkgd2luZG93IGluIHBoYXNlIFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnV2luZG93IHNjcm9sbGluZyBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBmb3IgZml4ZWQgbGlzdHMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9uZXdTY3JvbGwgPSBhY3Rpb24ucGF5bG9hZC5uZXdTY3JvbGw7XG5cbiAgICBpZiAoaXNFcXVhbChzdGF0ZS52aWV3cG9ydC5zY3JvbGwuY3VycmVudCwgX25ld1Njcm9sbCkpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIF92aWV3cG9ydCA9IHNjcm9sbFZpZXdwb3J0KHN0YXRlLnZpZXdwb3J0LCBfbmV3U2Nyb2xsKTtcblxuICAgIGlmIChpc1NuYXBwaW5nKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICB2aWV3cG9ydDogX3ZpZXdwb3J0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHZpZXdwb3J0OiBfdmlld3BvcnRcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9WSUVXUE9SVF9NQVhfU0NST0xMJykge1xuICAgIGlmICghaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIG1heFNjcm9sbCA9IGFjdGlvbi5wYXlsb2FkLm1heFNjcm9sbDtcblxuICAgIGlmIChpc0VxdWFsKG1heFNjcm9sbCwgc3RhdGUudmlld3BvcnQuc2Nyb2xsLm1heCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgd2l0aE1heFNjcm9sbCA9IF9leHRlbmRzKHt9LCBzdGF0ZS52aWV3cG9ydCwge1xuICAgICAgc2Nyb2xsOiBfZXh0ZW5kcyh7fSwgc3RhdGUudmlld3BvcnQuc2Nyb2xsLCB7XG4gICAgICAgIG1heDogbWF4U2Nyb2xsXG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHBoYXNlOiAnRFJBR0dJTkcnXG4gICAgfSwgc3RhdGUsIHtcbiAgICAgIHZpZXdwb3J0OiB3aXRoTWF4U2Nyb2xsXG4gICAgfSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFX1VQJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0xFRlQnIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9SSUdIVCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYWN0aW9uLnR5cGUgKyBcIiByZWNlaXZlZCB3aGlsZSBub3QgaW4gRFJBR0dJTkcgcGhhc2VcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIF9yZXN1bHQyID0gbW92ZUluRGlyZWN0aW9uKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHR5cGU6IGFjdGlvbi50eXBlXG4gICAgfSk7XG5cbiAgICBpZiAoIV9yZXN1bHQyKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBpbXBhY3Q6IF9yZXN1bHQyLmltcGFjdCxcbiAgICAgIGNsaWVudFNlbGVjdGlvbjogX3Jlc3VsdDIuY2xpZW50U2VsZWN0aW9uLFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IF9yZXN1bHQyLnNjcm9sbEp1bXBSZXF1ZXN0XG4gICAgfSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgdmFyIHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgbW92ZSBpbnRvIHRoZSBEUk9QX1BFTkRJTkcgcGhhc2UgZnJvbSB0aGUgQ09MTEVDVElORyBwaGFzZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBuZXdTdGF0ZSA9IF9leHRlbmRzKHtcbiAgICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJ1xuICAgIH0sIHN0YXRlLCB7XG4gICAgICBwaGFzZTogJ0RST1BfUEVORElORycsXG4gICAgICBpc1dhaXRpbmc6IHRydWUsXG4gICAgICByZWFzb246IHJlYXNvblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgIHZhciBfYWN0aW9uJHBheWxvYWQ1ID0gYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIGNvbXBsZXRlZCA9IF9hY3Rpb24kcGF5bG9hZDUuY29tcGxldGVkLFxuICAgICAgICBkcm9wRHVyYXRpb24gPSBfYWN0aW9uJHBheWxvYWQ1LmRyb3BEdXJhdGlvbixcbiAgICAgICAgbmV3SG9tZUNsaWVudE9mZnNldCA9IF9hY3Rpb24kcGF5bG9hZDUubmV3SG9tZUNsaWVudE9mZnNldDtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IGFuaW1hdGUgZHJvcCBmcm9tIHBoYXNlIFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgX3Jlc3VsdDMgPSB7XG4gICAgICBwaGFzZTogJ0RST1BfQU5JTUFUSU5HJyxcbiAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkLFxuICAgICAgZHJvcER1cmF0aW9uOiBkcm9wRHVyYXRpb24sXG4gICAgICBuZXdIb21lQ2xpZW50T2Zmc2V0OiBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgZGltZW5zaW9uczogc3RhdGUuZGltZW5zaW9uc1xuICAgIH07XG4gICAgcmV0dXJuIF9yZXN1bHQzO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICB2YXIgX2NvbXBsZXRlZCA9IGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZDtcbiAgICByZXR1cm4ge1xuICAgICAgcGhhc2U6ICdJRExFJyxcbiAgICAgIGNvbXBsZXRlZDogX2NvbXBsZXRlZCxcbiAgICAgIHNob3VsZEZsdXNoOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59KTtcblxudmFyIGJlZm9yZUluaXRpYWxDYXB0dXJlID0gZnVuY3Rpb24gYmVmb3JlSW5pdGlhbENhcHR1cmUoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCRUZPUkVfSU5JVElBTF9DQVBUVVJFJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIGxpZnQgPSBmdW5jdGlvbiBsaWZ0KGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTElGVCcsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBpbml0aWFsUHVibGlzaCA9IGZ1bmN0aW9uIGluaXRpYWxQdWJsaXNoKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnSU5JVElBTF9QVUJMSVNIJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIHB1Ymxpc2hXaGlsZURyYWdnaW5nID0gZnVuY3Rpb24gcHVibGlzaFdoaWxlRHJhZ2dpbmcoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIGNvbGxlY3Rpb25TdGFydGluZyA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25TdGFydGluZygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQ09MTEVDVElPTl9TVEFSVElORycsXG4gICAgcGF5bG9hZDogbnVsbFxuICB9O1xufTtcbnZhciB1cGRhdGVEcm9wcGFibGVTY3JvbGwgPSBmdW5jdGlvbiB1cGRhdGVEcm9wcGFibGVTY3JvbGwoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQgPSBmdW5jdGlvbiB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX0lTX0VOQUJMRUQnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCA9IGZ1bmN0aW9uIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX0lTX0NPTUJJTkVfRU5BQkxFRCcsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBtb3ZlID0gZnVuY3Rpb24gbW92ZShhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ01PVkUnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgbW92ZUJ5V2luZG93U2Nyb2xsID0gZnVuY3Rpb24gbW92ZUJ5V2luZG93U2Nyb2xsKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRV9CWV9XSU5ET1dfU0NST0xMJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsID0gZnVuY3Rpb24gdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdVUERBVEVfVklFV1BPUlRfTUFYX1NDUk9MTCcsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBtb3ZlVXAgPSBmdW5jdGlvbiBtb3ZlVXAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ01PVkVfVVAnLFxuICAgIHBheWxvYWQ6IG51bGxcbiAgfTtcbn07XG52YXIgbW92ZURvd24gPSBmdW5jdGlvbiBtb3ZlRG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRV9ET1dOJyxcbiAgICBwYXlsb2FkOiBudWxsXG4gIH07XG59O1xudmFyIG1vdmVSaWdodCA9IGZ1bmN0aW9uIG1vdmVSaWdodCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRV9SSUdIVCcsXG4gICAgcGF5bG9hZDogbnVsbFxuICB9O1xufTtcbnZhciBtb3ZlTGVmdCA9IGZ1bmN0aW9uIG1vdmVMZWZ0KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX0xFRlQnLFxuICAgIHBheWxvYWQ6IG51bGxcbiAgfTtcbn07XG52YXIgZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRkxVU0gnLFxuICAgIHBheWxvYWQ6IG51bGxcbiAgfTtcbn07XG52YXIgYW5pbWF0ZURyb3AgPSBmdW5jdGlvbiBhbmltYXRlRHJvcChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0RST1BfQU5JTUFURScsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBjb21wbGV0ZURyb3AgPSBmdW5jdGlvbiBjb21wbGV0ZURyb3AoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdEUk9QX0NPTVBMRVRFJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRFJPUCcsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBkcm9wUGVuZGluZyA9IGZ1bmN0aW9uIGRyb3BQZW5kaW5nKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRFJPUF9QRU5ESU5HJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIGRyb3BBbmltYXRpb25GaW5pc2hlZCA9IGZ1bmN0aW9uIGRyb3BBbmltYXRpb25GaW5pc2hlZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnLFxuICAgIHBheWxvYWQ6IG51bGxcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSW5kZXhlcyhpbnNpZGVEZXN0aW5hdGlvbikge1xuICBpZiAoaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5kZXhlcyA9IGluc2lkZURlc3RpbmF0aW9uLm1hcChmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLmRlc2NyaXB0b3IuaW5kZXg7XG4gIH0pO1xuICB2YXIgZXJyb3JzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBpbmRleGVzW2ldO1xuICAgIHZhciBwcmV2aW91cyA9IGluZGV4ZXNbaSAtIDFdO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IHByZXZpb3VzICsgMSkge1xuICAgICAgZXJyb3JzW2N1cnJlbnRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIU9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZvcm1hdHRlZCA9IGluZGV4ZXMubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBoYXNFcnJvciA9IEJvb2xlYW4oZXJyb3JzW2luZGV4XSk7XG4gICAgcmV0dXJuIGhhc0Vycm9yID8gXCJbXFx1RDgzRFxcdUREMjVcIiArIGluZGV4ICsgXCJdXCIgOiBcIlwiICsgaW5kZXg7XG4gIH0pLmpvaW4oJywgJyk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgRGV0ZWN0ZWQgbm9uLWNvbnNlY3V0aXZlIDxEcmFnZ2FibGUgLz4gaW5kZXhlcy5cXG5cXG4gICAgKFRoaXMgY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYnVncylcXG5cXG4gICAgXCIgKyBmb3JtYXR0ZWQgKyBcIlxcbiAgXCIpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbnMoY3JpdGljYWwsIGRpbWVuc2lvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGNyaXRpY2FsLmRyb3BwYWJsZS5pZCwgZGltZW5zaW9ucy5kcmFnZ2FibGVzKTtcbiAgICBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pO1xuICB9XG59XG5cbnZhciBsaWZ0JDEgPSAoZnVuY3Rpb24gKG1hcnNoYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSAnTElGVCcpIHtcbiAgICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9hY3Rpb24kcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICAgICAgaWQgPSBfYWN0aW9uJHBheWxvYWQuaWQsXG4gICAgICAgICAgICBjbGllbnRTZWxlY3Rpb24gPSBfYWN0aW9uJHBheWxvYWQuY2xpZW50U2VsZWN0aW9uLFxuICAgICAgICAgICAgbW92ZW1lbnRNb2RlID0gX2FjdGlvbiRwYXlsb2FkLm1vdmVtZW50TW9kZTtcbiAgICAgICAgdmFyIGluaXRpYWwgPSBnZXRTdGF0ZSgpO1xuXG4gICAgICAgIGlmIChpbml0aWFsLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICAgICAgZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICAgICAgICAgIGNvbXBsZXRlZDogaW5pdGlhbC5jb21wbGV0ZWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICAhKGdldFN0YXRlKCkucGhhc2UgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIHBoYXNlIHRvIHN0YXJ0IGEgZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgICAgIGRpc3BhdGNoKGJlZm9yZUluaXRpYWxDYXB0dXJlKHtcbiAgICAgICAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgICAgICAgbW92ZW1lbnRNb2RlOiBtb3ZlbWVudE1vZGVcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IHtcbiAgICAgICAgICBzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHk6IG1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICAgICAgICBzY3JvbGxPcHRpb25zOiBzY3JvbGxPcHRpb25zXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9tYXJzaGFsJHN0YXJ0UHVibGlzaCA9IG1hcnNoYWwuc3RhcnRQdWJsaXNoaW5nKHJlcXVlc3QpLFxuICAgICAgICAgICAgY3JpdGljYWwgPSBfbWFyc2hhbCRzdGFydFB1Ymxpc2guY3JpdGljYWwsXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gX21hcnNoYWwkc3RhcnRQdWJsaXNoLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICB2aWV3cG9ydCA9IF9tYXJzaGFsJHN0YXJ0UHVibGlzaC52aWV3cG9ydDtcblxuICAgICAgICB2YWxpZGF0ZURpbWVuc2lvbnMoY3JpdGljYWwsIGRpbWVuc2lvbnMpO1xuICAgICAgICBkaXNwYXRjaChpbml0aWFsUHVibGlzaCh7XG4gICAgICAgICAgY3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgY2xpZW50U2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgICAgICAgbW92ZW1lbnRNb2RlOiBtb3ZlbWVudE1vZGUsXG4gICAgICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgc3R5bGUgPSAoZnVuY3Rpb24gKG1hcnNoYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAgICAgICBtYXJzaGFsLmRyYWdnaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnKSB7XG4gICAgICAgICAgbWFyc2hhbC5kcm9wcGluZyhhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0LnJlYXNvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgICAgICAgIG1hcnNoYWwucmVzdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBjdXJ2ZXMgPSB7XG4gIG91dE9mVGhlV2F5OiAnY3ViaWMtYmV6aWVyKDAuMiwgMCwgMCwgMSknLFxuICBkcm9wOiAnY3ViaWMtYmV6aWVyKC4yLDEsLjEsMSknXG59O1xudmFyIGNvbWJpbmUgPSB7XG4gIG9wYWNpdHk6IHtcbiAgICBkcm9wOiAwLFxuICAgIGNvbWJpbmluZzogMC43XG4gIH0sXG4gIHNjYWxlOiB7XG4gICAgZHJvcDogMC43NVxuICB9XG59O1xudmFyIHRpbWluZ3MgPSB7XG4gIG91dE9mVGhlV2F5OiAwLjIsXG4gIG1pbkRyb3BUaW1lOiAwLjMzLFxuICBtYXhEcm9wVGltZTogMC41NVxufTtcbnZhciBvdXRPZlRoZVdheVRpbWluZyA9IHRpbWluZ3Mub3V0T2ZUaGVXYXkgKyBcInMgXCIgKyBjdXJ2ZXMub3V0T2ZUaGVXYXk7XG52YXIgdHJhbnNpdGlvbnMgPSB7XG4gIGZsdWlkOiBcIm9wYWNpdHkgXCIgKyBvdXRPZlRoZVdheVRpbWluZyxcbiAgc25hcDogXCJ0cmFuc2Zvcm0gXCIgKyBvdXRPZlRoZVdheVRpbWluZyArIFwiLCBvcGFjaXR5IFwiICsgb3V0T2ZUaGVXYXlUaW1pbmcsXG4gIGRyb3A6IGZ1bmN0aW9uIGRyb3AoZHVyYXRpb24pIHtcbiAgICB2YXIgdGltaW5nID0gZHVyYXRpb24gKyBcInMgXCIgKyBjdXJ2ZXMuZHJvcDtcbiAgICByZXR1cm4gXCJ0cmFuc2Zvcm0gXCIgKyB0aW1pbmcgKyBcIiwgb3BhY2l0eSBcIiArIHRpbWluZztcbiAgfSxcbiAgb3V0T2ZUaGVXYXk6IFwidHJhbnNmb3JtIFwiICsgb3V0T2ZUaGVXYXlUaW1pbmcsXG4gIHBsYWNlaG9sZGVyOiBcImhlaWdodCBcIiArIG91dE9mVGhlV2F5VGltaW5nICsgXCIsIHdpZHRoIFwiICsgb3V0T2ZUaGVXYXlUaW1pbmcgKyBcIiwgbWFyZ2luIFwiICsgb3V0T2ZUaGVXYXlUaW1pbmdcbn07XG5cbnZhciBtb3ZlVG8gPSBmdW5jdGlvbiBtb3ZlVG8ob2Zmc2V0KSB7XG4gIHJldHVybiBpc0VxdWFsKG9mZnNldCwgb3JpZ2luKSA/IG51bGwgOiBcInRyYW5zbGF0ZShcIiArIG9mZnNldC54ICsgXCJweCwgXCIgKyBvZmZzZXQueSArIFwicHgpXCI7XG59O1xuXG52YXIgdHJhbnNmb3JtcyA9IHtcbiAgbW92ZVRvOiBtb3ZlVG8sXG4gIGRyb3A6IGZ1bmN0aW9uIGRyb3Aob2Zmc2V0LCBpc0NvbWJpbmluZykge1xuICAgIHZhciB0cmFuc2xhdGUgPSBtb3ZlVG8ob2Zmc2V0KTtcblxuICAgIGlmICghdHJhbnNsYXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ29tYmluaW5nKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2xhdGUgKyBcIiBzY2FsZShcIiArIGNvbWJpbmUuc2NhbGUuZHJvcCArIFwiKVwiO1xuICB9XG59O1xuXG52YXIgbWluRHJvcFRpbWUgPSB0aW1pbmdzLm1pbkRyb3BUaW1lLFxuICAgIG1heERyb3BUaW1lID0gdGltaW5ncy5tYXhEcm9wVGltZTtcbnZhciBkcm9wVGltZVJhbmdlID0gbWF4RHJvcFRpbWUgLSBtaW5Ecm9wVGltZTtcbnZhciBtYXhEcm9wVGltZUF0RGlzdGFuY2UgPSAxNTAwO1xudmFyIGNhbmNlbERyb3BNb2RpZmllciA9IDAuNjtcbnZhciBnZXREcm9wRHVyYXRpb24gPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGN1cnJlbnQgPSBfcmVmLmN1cnJlbnQsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICByZWFzb24gPSBfcmVmLnJlYXNvbjtcbiAgdmFyIGRpc3RhbmNlJDEgPSBkaXN0YW5jZShjdXJyZW50LCBkZXN0aW5hdGlvbik7XG5cbiAgaWYgKGRpc3RhbmNlJDEgPD0gMCkge1xuICAgIHJldHVybiBtaW5Ecm9wVGltZTtcbiAgfVxuXG4gIGlmIChkaXN0YW5jZSQxID49IG1heERyb3BUaW1lQXREaXN0YW5jZSkge1xuICAgIHJldHVybiBtYXhEcm9wVGltZTtcbiAgfVxuXG4gIHZhciBwZXJjZW50YWdlID0gZGlzdGFuY2UkMSAvIG1heERyb3BUaW1lQXREaXN0YW5jZTtcbiAgdmFyIGR1cmF0aW9uID0gbWluRHJvcFRpbWUgKyBkcm9wVGltZVJhbmdlICogcGVyY2VudGFnZTtcbiAgdmFyIHdpdGhEdXJhdGlvbiA9IHJlYXNvbiA9PT0gJ0NBTkNFTCcgPyBkdXJhdGlvbiAqIGNhbmNlbERyb3BNb2RpZmllciA6IGR1cmF0aW9uO1xuICByZXR1cm4gTnVtYmVyKHdpdGhEdXJhdGlvbi50b0ZpeGVkKDIpKTtcbn0pO1xuXG52YXIgZ2V0TmV3SG9tZUNsaWVudE9mZnNldCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRpbWVuc2lvbnMgPSBfcmVmLmRpbWVuc2lvbnMsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuICB2YXIgZHJhZ2dhYmxlcyA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZXMgPSBkaW1lbnNpb25zLmRyb3BwYWJsZXM7XG4gIHZhciBkcm9wcGFibGVJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIHZhciBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZUlkID8gZHJvcHBhYmxlc1tkcm9wcGFibGVJZF0gOiBudWxsO1xuICB2YXIgaG9tZSA9IGRyb3BwYWJsZXNbZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdO1xuICB2YXIgbmV3Q2xpZW50Q2VudGVyID0gZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyKHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWwsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbiB8fCBob21lLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICB9KTtcbiAgdmFyIG9mZnNldCA9IHN1YnRyYWN0KG5ld0NsaWVudENlbnRlciwgZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyKTtcbiAgcmV0dXJuIG9mZnNldDtcbn0pO1xuXG52YXIgZ2V0RHJvcEltcGFjdCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIHJlYXNvbiA9IF9yZWYucmVhc29uLFxuICAgICAgbGFzdEltcGFjdCA9IF9yZWYubGFzdEltcGFjdCxcbiAgICAgIGhvbWUgPSBfcmVmLmhvbWUsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBvbkxpZnRJbXBhY3QgPSBfcmVmLm9uTGlmdEltcGFjdDtcblxuICBpZiAoIWxhc3RJbXBhY3QuYXQgfHwgcmVhc29uICE9PSAnRFJPUCcpIHtcbiAgICB2YXIgcmVjb21wdXRlZEhvbWVJbXBhY3QgPSByZWNvbXB1dGUoe1xuICAgICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICAgIGltcGFjdDogb25MaWZ0SW1wYWN0LFxuICAgICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW1wYWN0OiByZWNvbXB1dGVkSG9tZUltcGFjdCxcbiAgICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChsYXN0SW1wYWN0LmF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiB7XG4gICAgICBpbXBhY3Q6IGxhc3RJbXBhY3QsXG4gICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHZhciB3aXRob3V0TW92ZW1lbnQgPSBfZXh0ZW5kcyh7fSwgbGFzdEltcGFjdCwge1xuICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHNcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpbXBhY3Q6IHdpdGhvdXRNb3ZlbWVudCxcbiAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiB0cnVlXG4gIH07XG59KTtcblxudmFyIGRyb3AkMSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlLFxuICAgICAgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoO1xuICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSAnRFJPUCcpIHtcbiAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICB2YXIgcmVhc29uID0gYWN0aW9uLnBheWxvYWQucmVhc29uO1xuXG4gICAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgICAgICBkaXNwYXRjaChkcm9wUGVuZGluZyh7XG4gICAgICAgICAgcmVhc29uOiByZWFzb25cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzV2FpdGluZ0ZvckRyb3AgPSBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycgJiYgc3RhdGUuaXNXYWl0aW5nO1xuICAgICAgISFpc1dhaXRpbmdGb3JEcm9wID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQSBEUk9QIGFjdGlvbiBvY2N1cnJlZCB3aGlsZSBEUk9QX1BFTkRJTkcgYW5kIHN0aWxsIHdhaXRpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IGRyb3AgaW4gcGhhc2U6IFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciBjcml0aWNhbCA9IHN0YXRlLmNyaXRpY2FsO1xuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBzdGF0ZS5kaW1lbnNpb25zO1xuICAgICAgdmFyIGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuXG4gICAgICB2YXIgX2dldERyb3BJbXBhY3QgPSBnZXREcm9wSW1wYWN0KHtcbiAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgIGxhc3RJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICAgICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICAgICAgb25MaWZ0SW1wYWN0OiBzdGF0ZS5vbkxpZnRJbXBhY3QsXG4gICAgICAgIGhvbWU6IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdLFxuICAgICAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgICAgIGRyYWdnYWJsZXM6IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1xuICAgICAgfSksXG4gICAgICAgICAgaW1wYWN0ID0gX2dldERyb3BJbXBhY3QuaW1wYWN0LFxuICAgICAgICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPSBfZ2V0RHJvcEltcGFjdC5kaWREcm9wSW5zaWRlRHJvcHBhYmxlO1xuXG4gICAgICB2YXIgZGVzdGluYXRpb24gPSBkaWREcm9wSW5zaWRlRHJvcHBhYmxlID8gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KSA6IG51bGw7XG4gICAgICB2YXIgY29tYmluZSA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXRDb21iaW5lKGltcGFjdCkgOiBudWxsO1xuICAgICAgdmFyIHNvdXJjZSA9IHtcbiAgICAgICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGNyaXRpY2FsLmRyb3BwYWJsZS5pZFxuICAgICAgfTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCxcbiAgICAgICAgdHlwZTogZHJhZ2dhYmxlLmRlc2NyaXB0b3IudHlwZSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICBtb2RlOiBzdGF0ZS5tb3ZlbWVudE1vZGUsXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICAgICAgY29tYmluZTogY29tYmluZVxuICAgICAgfTtcbiAgICAgIHZhciBuZXdIb21lQ2xpZW50T2Zmc2V0ID0gZ2V0TmV3SG9tZUNsaWVudE9mZnNldCh7XG4gICAgICAgIGltcGFjdDogaW1wYWN0LFxuICAgICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgICAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gICAgICB9KTtcbiAgICAgIHZhciBjb21wbGV0ZWQgPSB7XG4gICAgICAgIGNyaXRpY2FsOiBzdGF0ZS5jcml0aWNhbCxcbiAgICAgICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgIGltcGFjdDogaW1wYWN0XG4gICAgICB9O1xuICAgICAgdmFyIGlzQW5pbWF0aW9uUmVxdWlyZWQgPSAhaXNFcXVhbChzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQsIG5ld0hvbWVDbGllbnRPZmZzZXQpIHx8IEJvb2xlYW4ocmVzdWx0LmNvbWJpbmUpO1xuXG4gICAgICBpZiAoIWlzQW5pbWF0aW9uUmVxdWlyZWQpIHtcbiAgICAgICAgZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICAgICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRlZFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRyb3BEdXJhdGlvbiA9IGdldERyb3BEdXJhdGlvbih7XG4gICAgICAgIGN1cnJlbnQ6IHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldCxcbiAgICAgICAgZGVzdGluYXRpb246IG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICB9KTtcbiAgICAgIHZhciBhcmdzID0ge1xuICAgICAgICBuZXdIb21lQ2xpZW50T2Zmc2V0OiBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgICBkcm9wRHVyYXRpb246IGRyb3BEdXJhdGlvbixcbiAgICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWRcbiAgICAgIH07XG4gICAgICBkaXNwYXRjaChhbmltYXRlRHJvcChhcmdzKSk7XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgZ2V0V2luZG93U2Nyb2xsID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH07XG59KTtcblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmluZGluZyh1cGRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB3aW5kb3cgJiYgZXZlbnQudGFyZ2V0ICE9PSB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbExpc3RlbmVyKF9yZWYpIHtcbiAgdmFyIG9uV2luZG93U2Nyb2xsID0gX3JlZi5vbldpbmRvd1Njcm9sbDtcblxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGwoKSB7XG4gICAgb25XaW5kb3dTY3JvbGwoZ2V0V2luZG93U2Nyb2xsKCkpO1xuICB9XG5cbiAgdmFyIHNjaGVkdWxlZCA9IHJhZlNjaGQodXBkYXRlU2Nyb2xsKTtcbiAgdmFyIGJpbmRpbmcgPSBnZXRXaW5kb3dTY3JvbGxCaW5kaW5nKHNjaGVkdWxlZCk7XG4gIHZhciB1bmJpbmQgPSBub29wO1xuXG4gIGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB1bmJpbmQgIT09IG5vb3A7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAhIWlzQWN0aXZlKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RhcnQgc2Nyb2xsIGxpc3RlbmVyIHdoZW4gYWxyZWFkeSBhY3RpdmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFtiaW5kaW5nXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICFpc0FjdGl2ZSgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3Agc2Nyb2xsIGxpc3RlbmVyIHdoZW4gbm90IGFjdGl2ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBzY2hlZHVsZWQuY2FuY2VsKCk7XG4gICAgdW5iaW5kKCk7XG4gICAgdW5iaW5kID0gbm9vcDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIHN0b3A6IHN0b3AsXG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlXG4gIH07XG59XG5cbnZhciBzaG91bGRFbmQgPSBmdW5jdGlvbiBzaG91bGRFbmQoYWN0aW9uKSB7XG4gIHJldHVybiBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJztcbn07XG5cbnZhciBzY3JvbGxMaXN0ZW5lciA9IChmdW5jdGlvbiAoc3RvcmUpIHtcbiAgdmFyIGxpc3RlbmVyID0gZ2V0U2Nyb2xsTGlzdGVuZXIoe1xuICAgIG9uV2luZG93U2Nyb2xsOiBmdW5jdGlvbiBvbldpbmRvd1Njcm9sbChuZXdTY3JvbGwpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKG1vdmVCeVdpbmRvd1Njcm9sbCh7XG4gICAgICAgIG5ld1Njcm9sbDogbmV3U2Nyb2xsXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGlmICghbGlzdGVuZXIuaXNBY3RpdmUoKSAmJiBhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAgICAgbGlzdGVuZXIuc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3RlbmVyLmlzQWN0aXZlKCkgJiYgc2hvdWxkRW5kKGFjdGlvbikpIHtcbiAgICAgICAgbGlzdGVuZXIuc3RvcCgpO1xuICAgICAgfVxuXG4gICAgICBuZXh0KGFjdGlvbik7XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgZ2V0RXhwaXJpbmdBbm5vdW5jZSA9IChmdW5jdGlvbiAoYW5ub3VuY2UpIHtcbiAgdmFyIHdhc0NhbGxlZCA9IGZhbHNlO1xuICB2YXIgaXNFeHBpcmVkID0gZmFsc2U7XG4gIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpc0V4cGlyZWQgPSB0cnVlO1xuICB9KTtcblxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gcmVzdWx0KG1lc3NhZ2UpIHtcbiAgICBpZiAod2FzQ2FsbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdBbm5vdW5jZW1lbnQgYWxyZWFkeSBtYWRlLiBOb3QgbWFraW5nIGEgc2Vjb25kIGFubm91bmNlbWVudCcpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0V4cGlyZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICAgIEFubm91bmNlbWVudHMgY2Fubm90IGJlIG1hZGUgYXN5bmNocm9ub3VzbHkuXFxuICAgICAgICBEZWZhdWx0IG1lc3NhZ2UgaGFzIGFscmVhZHkgYmVlbiBhbm5vdW5jZWQuXFxuICAgICAgXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhc0NhbGxlZCA9IHRydWU7XG4gICAgYW5ub3VuY2UobWVzc2FnZSk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG5cbiAgcmVzdWx0Lndhc0NhbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2FzQ2FsbGVkO1xuICB9O1xuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxudmFyIGdldEFzeW5jTWFyc2hhbCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBlbnRyaWVzID0gW107XG5cbiAgdmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKHRpbWVySWQpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgoZW50cmllcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLnRpbWVySWQgPT09IHRpbWVySWQ7XG4gICAgfSk7XG4gICAgIShpbmRleCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgdGltZXInKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgX2VudHJpZXMkc3BsaWNlID0gZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpLFxuICAgICAgICBlbnRyeSA9IF9lbnRyaWVzJHNwbGljZVswXTtcblxuICAgIGVudHJ5LmNhbGxiYWNrKCk7XG4gIH07XG5cbiAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChmbikge1xuICAgIHZhciB0aW1lcklkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZSh0aW1lcklkKTtcbiAgICB9KTtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0aW1lcklkOiB0aW1lcklkLFxuICAgICAgY2FsbGJhY2s6IGZuXG4gICAgfTtcbiAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICB9O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hhbGxvdyA9IFtdLmNvbmNhdChlbnRyaWVzKTtcbiAgICBlbnRyaWVzLmxlbmd0aCA9IDA7XG4gICAgc2hhbGxvdy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGVudHJ5LnRpbWVySWQpO1xuICAgICAgZW50cnkuY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFkZDogYWRkLFxuICAgIGZsdXNoOiBmbHVzaFxuICB9O1xufSk7XG5cbnZhciBhcmVMb2NhdGlvbnNFcXVhbCA9IGZ1bmN0aW9uIGFyZUxvY2F0aW9uc0VxdWFsKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09IG51bGwgJiYgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChmaXJzdCA9PSBudWxsIHx8IHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZpcnN0LmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJvcHBhYmxlSWQgJiYgZmlyc3QuaW5kZXggPT09IHNlY29uZC5pbmRleDtcbn07XG52YXIgaXNDb21iaW5lRXF1YWwgPSBmdW5jdGlvbiBpc0NvbWJpbmVFcXVhbChmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZmlyc3QgPT0gbnVsbCB8fCBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBmaXJzdC5kcmFnZ2FibGVJZCA9PT0gc2Vjb25kLmRyYWdnYWJsZUlkICYmIGZpcnN0LmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJvcHBhYmxlSWQ7XG59O1xudmFyIGlzQ3JpdGljYWxFcXVhbCA9IGZ1bmN0aW9uIGlzQ3JpdGljYWxFcXVhbChmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaXNEcmFnZ2FibGVFcXVhbCA9IGZpcnN0LmRyYWdnYWJsZS5pZCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5pZCAmJiBmaXJzdC5kcmFnZ2FibGUuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcmFnZ2FibGUuZHJvcHBhYmxlSWQgJiYgZmlyc3QuZHJhZ2dhYmxlLnR5cGUgPT09IHNlY29uZC5kcmFnZ2FibGUudHlwZSAmJiBmaXJzdC5kcmFnZ2FibGUuaW5kZXggPT09IHNlY29uZC5kcmFnZ2FibGUuaW5kZXg7XG4gIHZhciBpc0Ryb3BwYWJsZUVxdWFsID0gZmlyc3QuZHJvcHBhYmxlLmlkID09PSBzZWNvbmQuZHJvcHBhYmxlLmlkICYmIGZpcnN0LmRyb3BwYWJsZS50eXBlID09PSBzZWNvbmQuZHJvcHBhYmxlLnR5cGU7XG4gIHJldHVybiBpc0RyYWdnYWJsZUVxdWFsICYmIGlzRHJvcHBhYmxlRXF1YWw7XG59O1xuXG52YXIgd2l0aFRpbWluZ3MgPSBmdW5jdGlvbiB3aXRoVGltaW5ncyhrZXksIGZuKSB7XG4gIHN0YXJ0KCk7XG4gIGZuKCk7XG4gIGZpbmlzaCgpO1xufTtcblxudmFyIGdldERyYWdTdGFydCA9IGZ1bmN0aW9uIGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIGRyYWdnYWJsZUlkOiBjcml0aWNhbC5kcmFnZ2FibGUuaWQsXG4gICAgdHlwZTogY3JpdGljYWwuZHJvcHBhYmxlLnR5cGUsXG4gICAgc291cmNlOiB7XG4gICAgICBkcm9wcGFibGVJZDogY3JpdGljYWwuZHJvcHBhYmxlLmlkLFxuICAgICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleFxuICAgIH0sXG4gICAgbW9kZTogbW9kZVxuICB9O1xufTtcblxudmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKHJlc3BvbmRlciwgZGF0YSwgYW5ub3VuY2UsIGdldERlZmF1bHRNZXNzYWdlKSB7XG4gIGlmICghcmVzcG9uZGVyKSB7XG4gICAgYW5ub3VuY2UoZ2V0RGVmYXVsdE1lc3NhZ2UoZGF0YSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB3aWxsRXhwaXJlID0gZ2V0RXhwaXJpbmdBbm5vdW5jZShhbm5vdW5jZSk7XG4gIHZhciBwcm92aWRlZCA9IHtcbiAgICBhbm5vdW5jZTogd2lsbEV4cGlyZVxuICB9O1xuICByZXNwb25kZXIoZGF0YSwgcHJvdmlkZWQpO1xuXG4gIGlmICghd2lsbEV4cGlyZS53YXNDYWxsZWQoKSkge1xuICAgIGFubm91bmNlKGdldERlZmF1bHRNZXNzYWdlKGRhdGEpKTtcbiAgfVxufTtcblxudmFyIGdldFB1Ymxpc2hlciA9IChmdW5jdGlvbiAoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpIHtcbiAgdmFyIGFzeW5jTWFyc2hhbCA9IGdldEFzeW5jTWFyc2hhbCgpO1xuICB2YXIgZHJhZ2dpbmcgPSBudWxsO1xuXG4gIHZhciBiZWZvcmVDYXB0dXJlID0gZnVuY3Rpb24gYmVmb3JlQ2FwdHVyZShkcmFnZ2FibGVJZCwgbW9kZSkge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZUNhcHR1cmUgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZUNhcHR1cmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZm4gPSBnZXRSZXNwb25kZXJzKCkub25CZWZvcmVDYXB0dXJlO1xuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHtcbiAgICAgICAgICBkcmFnZ2FibGVJZDogZHJhZ2dhYmxlSWQsXG4gICAgICAgICAgbW9kZTogbW9kZVxuICAgICAgICB9O1xuICAgICAgICBmbihiZWZvcmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBiZWZvcmVTdGFydCA9IGZ1bmN0aW9uIGJlZm9yZVN0YXJ0KGNyaXRpY2FsLCBtb2RlKSB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlRHJhZ1N0YXJ0IGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB3aXRoVGltaW5ncygnb25CZWZvcmVEcmFnU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZm4gPSBnZXRSZXNwb25kZXJzKCkub25CZWZvcmVEcmFnU3RhcnQ7XG5cbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbihnZXREcmFnU3RhcnQoY3JpdGljYWwsIG1vZGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgc3RhcnQgPSBmdW5jdGlvbiBzdGFydChjcml0aWNhbCwgbW9kZSkge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZURyYWdTdGFydCBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGRhdGEgPSBnZXREcmFnU3RhcnQoY3JpdGljYWwsIG1vZGUpO1xuICAgIGRyYWdnaW5nID0ge1xuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGxhc3RDcml0aWNhbDogY3JpdGljYWwsXG4gICAgICBsYXN0TG9jYXRpb246IGRhdGEuc291cmNlLFxuICAgICAgbGFzdENvbWJpbmU6IG51bGxcbiAgICB9O1xuICAgIGFzeW5jTWFyc2hhbC5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgd2l0aFRpbWluZ3MoJ29uRHJhZ1N0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnU3RhcnQsIGRhdGEsIGFubm91bmNlLCBwcmVzZXQub25EcmFnU3RhcnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShjcml0aWNhbCwgaW1wYWN0KSB7XG4gICAgdmFyIGxvY2F0aW9uID0gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KTtcbiAgICB2YXIgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkRyYWdNb3ZlIHdoZW4gb25EcmFnU3RhcnQgaGFzIG5vdCBiZWVuIGNhbGxlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgaGFzQ3JpdGljYWxDaGFuZ2VkID0gIWlzQ3JpdGljYWxFcXVhbChjcml0aWNhbCwgZHJhZ2dpbmcubGFzdENyaXRpY2FsKTtcblxuICAgIGlmIChoYXNDcml0aWNhbENoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RDcml0aWNhbCA9IGNyaXRpY2FsO1xuICAgIH1cblxuICAgIHZhciBoYXNMb2NhdGlvbkNoYW5nZWQgPSAhYXJlTG9jYXRpb25zRXF1YWwoZHJhZ2dpbmcubGFzdExvY2F0aW9uLCBsb2NhdGlvbik7XG5cbiAgICBpZiAoaGFzTG9jYXRpb25DaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgaGFzR3JvdXBpbmdDaGFuZ2VkID0gIWlzQ29tYmluZUVxdWFsKGRyYWdnaW5nLmxhc3RDb21iaW5lLCBjb21iaW5lKTtcblxuICAgIGlmIChoYXNHcm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RDb21iaW5lID0gY29tYmluZTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc0NyaXRpY2FsQ2hhbmdlZCAmJiAhaGFzTG9jYXRpb25DaGFuZ2VkICYmICFoYXNHcm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCBnZXREcmFnU3RhcnQoY3JpdGljYWwsIGRyYWdnaW5nLm1vZGUpLCB7XG4gICAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgICAgZGVzdGluYXRpb246IGxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBhc3luY01hcnNoYWwuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdVcGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdVcGRhdGUsIGRhdGEsIGFubm91bmNlLCBwcmVzZXQub25EcmFnVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IGZsdXNoIHJlc3BvbmRlcnMgd2hpbGUgZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgYXN5bmNNYXJzaGFsLmZsdXNoKCk7XG4gIH07XG5cbiAgdmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKHJlc3VsdCkge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uRHJhZ0VuZCB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIG9uRHJhZ1N0YXJ0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgICB3aXRoVGltaW5ncygnb25EcmFnRW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ0VuZCwgcmVzdWx0LCBhbm5vdW5jZSwgcHJlc2V0Lm9uRHJhZ0VuZCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBfZXh0ZW5kcyh7fSwgZ2V0RHJhZ1N0YXJ0KGRyYWdnaW5nLmxhc3RDcml0aWNhbCwgZHJhZ2dpbmcubW9kZSksIHtcbiAgICAgIGNvbWJpbmU6IG51bGwsXG4gICAgICBkZXN0aW5hdGlvbjogbnVsbCxcbiAgICAgIHJlYXNvbjogJ0NBTkNFTCdcbiAgICB9KTtcblxuICAgIGRyb3AocmVzdWx0KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGJlZm9yZUNhcHR1cmU6IGJlZm9yZUNhcHR1cmUsXG4gICAgYmVmb3JlU3RhcnQ6IGJlZm9yZVN0YXJ0LFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBmbHVzaDogZmx1c2gsXG4gICAgZHJvcDogZHJvcCxcbiAgICBhYm9ydDogYWJvcnRcbiAgfTtcbn0pO1xuXG52YXIgcmVzcG9uZGVycyA9IChmdW5jdGlvbiAoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpIHtcbiAgdmFyIHB1Ymxpc2hlciA9IGdldFB1Ymxpc2hlcihnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0JFRk9SRV9JTklUSUFMX0NBUFRVUkUnKSB7XG4gICAgICAgICAgcHVibGlzaGVyLmJlZm9yZUNhcHR1cmUoYWN0aW9uLnBheWxvYWQuZHJhZ2dhYmxlSWQsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICAgICAgIHZhciBjcml0aWNhbCA9IGFjdGlvbi5wYXlsb2FkLmNyaXRpY2FsO1xuICAgICAgICAgIHB1Ymxpc2hlci5iZWZvcmVTdGFydChjcml0aWNhbCwgYWN0aW9uLnBheWxvYWQubW92ZW1lbnRNb2RlKTtcbiAgICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgcHVibGlzaGVyLnN0YXJ0KGNyaXRpY2FsLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQ7XG4gICAgICAgICAgcHVibGlzaGVyLmZsdXNoKCk7XG4gICAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICAgIHB1Ymxpc2hlci5kcm9wKHJlc3VsdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChhY3Rpb24pO1xuXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgICAgICAgIHB1Ymxpc2hlci5hYm9ydCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgICAgcHVibGlzaGVyLnVwZGF0ZShzdGF0ZS5jcml0aWNhbCwgc3RhdGUuaW1wYWN0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBkcm9wQW5pbWF0aW9uRmluaXNoID0gKGZ1bmN0aW9uIChzdG9yZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnKSB7XG4gICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluaXNoIGEgZHJvcCBhbmltYXRpbmcgd2hlbiBubyBkcm9wIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICAgIGNvbXBsZXRlZDogc3RhdGUuY29tcGxldGVkXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGwgPSAoZnVuY3Rpb24gKHN0b3JlKSB7XG4gIHZhciB1bmJpbmQgPSBudWxsO1xuICB2YXIgZnJhbWVJZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHVuYmluZCkge1xuICAgICAgdW5iaW5kKCk7XG4gICAgICB1bmJpbmQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFUSU9OX0ZJTklTSEVEJykge1xuICAgICAgICBjbGVhcigpO1xuICAgICAgfVxuXG4gICAgICBuZXh0KGFjdGlvbik7XG5cbiAgICAgIGlmIChhY3Rpb24udHlwZSAhPT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmluZGluZyA9IHtcbiAgICAgICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBmbjogZnVuY3Rpb24gZmx1c2hEcm9wQW5pbWF0aW9uKCkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3BBbmltYXRpb25GaW5pc2hlZCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICAgIHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbYmluZGluZ10pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIgPSAoZnVuY3Rpb24gKG1hcnNoYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRkxVU0gnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgICAgICAgIG1hcnNoYWwuc3RvcFB1Ymxpc2hpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgZm9jdXMgPSAoZnVuY3Rpb24gKG1hcnNoYWwpIHtcbiAgdmFyIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAgICAgICBpc1dhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICBtYXJzaGFsLnRyeVJlY29yZEZvY3VzKGFjdGlvbi5wYXlsb2FkLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCk7XG4gICAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KGFjdGlvbik7XG5cbiAgICAgICAgaWYgKCFpc1dhdGNoaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnKSB7XG4gICAgICAgICAgaXNXYXRjaGluZyA9IGZhbHNlO1xuICAgICAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgICAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcblxuICAgICAgICAgIGlmIChyZXN1bHQuY29tYmluZSkge1xuICAgICAgICAgICAgbWFyc2hhbC50cnlTaGlmdFJlY29yZChyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5jb21iaW5lLmRyYWdnYWJsZUlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXJzaGFsLnRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgc2hvdWxkU3RvcCA9IGZ1bmN0aW9uIHNob3VsZFN0b3AoYWN0aW9uKSB7XG4gIHJldHVybiBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJztcbn07XG5cbnZhciBhdXRvU2Nyb2xsID0gKGZ1bmN0aW9uIChhdXRvU2Nyb2xsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKHNob3VsZFN0b3AoYWN0aW9uKSkge1xuICAgICAgICAgIGF1dG9TY3JvbGxlci5zdG9wKCk7XG4gICAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgdmFyIHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHBoYXNlIHRvIGJlIERSQUdHSU5HIGFmdGVyIElOSVRJQUxfUFVCTElTSCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgICBhdXRvU2Nyb2xsZXIuc3RhcnQoc3RhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgYXV0b1Njcm9sbGVyLnNjcm9sbChzdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgcGVuZGluZ0Ryb3AgPSAoZnVuY3Rpb24gKHN0b3JlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBuZXh0KGFjdGlvbik7XG5cbiAgICAgIGlmIChhY3Rpb24udHlwZSAhPT0gJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc3RBY3Rpb25TdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIGlmIChwb3N0QWN0aW9uU3RhdGUucGhhc2UgIT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc3RBY3Rpb25TdGF0ZS5pc1dhaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzdG9yZS5kaXNwYXRjaChkcm9wKHtcbiAgICAgICAgcmVhc29uOiBwb3N0QWN0aW9uU3RhdGUucmVhc29uXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfTtcbn0pO1xuXG52YXIgY29tcG9zZUVuaGFuY2VycyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBjb21wb3NlO1xudmFyIGNyZWF0ZVN0b3JlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkaW1lbnNpb25NYXJzaGFsID0gX3JlZi5kaW1lbnNpb25NYXJzaGFsLFxuICAgICAgZm9jdXNNYXJzaGFsID0gX3JlZi5mb2N1c01hcnNoYWwsXG4gICAgICBzdHlsZU1hcnNoYWwgPSBfcmVmLnN0eWxlTWFyc2hhbCxcbiAgICAgIGdldFJlc3BvbmRlcnMgPSBfcmVmLmdldFJlc3BvbmRlcnMsXG4gICAgICBhbm5vdW5jZSA9IF9yZWYuYW5ub3VuY2UsXG4gICAgICBhdXRvU2Nyb2xsZXIgPSBfcmVmLmF1dG9TY3JvbGxlcjtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlJDEocmVkdWNlciwgY29tcG9zZUVuaGFuY2VycyhhcHBseU1pZGRsZXdhcmUoc3R5bGUoc3R5bGVNYXJzaGFsKSwgZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIoZGltZW5zaW9uTWFyc2hhbCksIGxpZnQkMShkaW1lbnNpb25NYXJzaGFsKSwgZHJvcCQxLCBkcm9wQW5pbWF0aW9uRmluaXNoLCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCwgcGVuZGluZ0Ryb3AsIGF1dG9TY3JvbGwoYXV0b1Njcm9sbGVyKSwgc2Nyb2xsTGlzdGVuZXIsIGZvY3VzKGZvY3VzTWFyc2hhbCksIHJlc3BvbmRlcnMoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpKSkpO1xufSk7XG5cbnZhciBjbGVhbiQxID0gZnVuY3Rpb24gY2xlYW4oKSB7XG4gIHJldHVybiB7XG4gICAgYWRkaXRpb25zOiB7fSxcbiAgICByZW1vdmFsczoge30sXG4gICAgbW9kaWZpZWQ6IHt9XG4gIH07XG59O1xuZnVuY3Rpb24gY3JlYXRlUHVibGlzaGVyKF9yZWYpIHtcbiAgdmFyIHJlZ2lzdHJ5ID0gX3JlZi5yZWdpc3RyeSxcbiAgICAgIGNhbGxiYWNrcyA9IF9yZWYuY2FsbGJhY2tzO1xuICB2YXIgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgdmFyIGZyYW1lSWQgPSBudWxsO1xuXG4gIHZhciBjb2xsZWN0ID0gZnVuY3Rpb24gY29sbGVjdCgpIHtcbiAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmcoKTtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgc3RhcnQoKTtcbiAgICAgIHZhciBfc3RhZ2luZyA9IHN0YWdpbmcsXG4gICAgICAgICAgYWRkaXRpb25zID0gX3N0YWdpbmcuYWRkaXRpb25zLFxuICAgICAgICAgIHJlbW92YWxzID0gX3N0YWdpbmcucmVtb3ZhbHMsXG4gICAgICAgICAgbW9kaWZpZWQgPSBfc3RhZ2luZy5tb2RpZmllZDtcbiAgICAgIHZhciBhZGRlZCA9IE9iamVjdC5rZXlzKGFkZGl0aW9ucykubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQoaWQpLmdldERpbWVuc2lvbihvcmlnaW4pO1xuICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4O1xuICAgICAgfSk7XG4gICAgICB2YXIgdXBkYXRlZCA9IE9iamVjdC5rZXlzKG1vZGlmaWVkKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGlkKTtcbiAgICAgICAgdmFyIHNjcm9sbCA9IGVudHJ5LmNhbGxiYWNrcy5nZXRTY3JvbGxXaGlsZURyYWdnaW5nKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGlkLFxuICAgICAgICAgIHNjcm9sbDogc2Nyb2xsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGFkZGl0aW9uczogYWRkZWQsXG4gICAgICAgIHJlbW92YWxzOiBPYmplY3Qua2V5cyhyZW1vdmFscyksXG4gICAgICAgIG1vZGlmaWVkOiB1cGRhdGVkXG4gICAgICB9O1xuICAgICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgICAgIGZpbmlzaCgpO1xuICAgICAgY2FsbGJhY2tzLnB1Ymxpc2gocmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGVudHJ5KSB7XG4gICAgdmFyIGlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICBzdGFnaW5nLmFkZGl0aW9uc1tpZF0gPSBlbnRyeTtcbiAgICBzdGFnaW5nLm1vZGlmaWVkW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdID0gdHJ1ZTtcblxuICAgIGlmIChzdGFnaW5nLnJlbW92YWxzW2lkXSkge1xuICAgICAgZGVsZXRlIHN0YWdpbmcucmVtb3ZhbHNbaWRdO1xuICAgIH1cblxuICAgIGNvbGxlY3QoKTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGVudHJ5KSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHN0YWdpbmcucmVtb3ZhbHNbZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgIHN0YWdpbmcubW9kaWZpZWRbZGVzY3JpcHRvci5kcm9wcGFibGVJZF0gPSB0cnVlO1xuXG4gICAgaWYgKHN0YWdpbmcuYWRkaXRpb25zW2Rlc2NyaXB0b3IuaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF07XG4gICAgfVxuXG4gICAgY29sbGVjdCgpO1xuICB9O1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoIWZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICBmcmFtZUlkID0gbnVsbDtcbiAgICBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYWRkOiBhZGQsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgc3RvcDogc3RvcFxuICB9O1xufVxuXG52YXIgZ2V0TWF4U2Nyb2xsID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzY3JvbGxIZWlnaHQgPSBfcmVmLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoID0gX3JlZi5zY3JvbGxXaWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoO1xuICB2YXIgbWF4U2Nyb2xsID0gc3VidHJhY3Qoe1xuICAgIHg6IHNjcm9sbFdpZHRoLFxuICAgIHk6IHNjcm9sbEhlaWdodFxuICB9LCB7XG4gICAgeDogd2lkdGgsXG4gICAgeTogaGVpZ2h0XG4gIH0pO1xuICB2YXIgYWRqdXN0ZWRNYXhTY3JvbGwgPSB7XG4gICAgeDogTWF0aC5tYXgoMCwgbWF4U2Nyb2xsLngpLFxuICAgIHk6IE1hdGgubWF4KDAsIG1heFNjcm9sbC55KVxuICB9O1xuICByZXR1cm4gYWRqdXN0ZWRNYXhTY3JvbGw7XG59KTtcblxudmFyIGdldERvY3VtZW50RWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICFkb2MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2M7XG59KTtcblxudmFyIGdldE1heFdpbmRvd1Njcm9sbCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBkb2MgPSBnZXREb2N1bWVudEVsZW1lbnQoKTtcbiAgdmFyIG1heFNjcm9sbCA9IGdldE1heFNjcm9sbCh7XG4gICAgc2Nyb2xsSGVpZ2h0OiBkb2Muc2Nyb2xsSGVpZ2h0LFxuICAgIHNjcm9sbFdpZHRoOiBkb2Muc2Nyb2xsV2lkdGgsXG4gICAgd2lkdGg6IGRvYy5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGRvYy5jbGllbnRIZWlnaHRcbiAgfSk7XG4gIHJldHVybiBtYXhTY3JvbGw7XG59KTtcblxudmFyIGdldFZpZXdwb3J0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbCgpO1xuICB2YXIgbWF4U2Nyb2xsID0gZ2V0TWF4V2luZG93U2Nyb2xsKCk7XG4gIHZhciB0b3AgPSBzY3JvbGwueTtcbiAgdmFyIGxlZnQgPSBzY3JvbGwueDtcbiAgdmFyIGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICB2YXIgd2lkdGggPSBkb2MuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBkb2MuY2xpZW50SGVpZ2h0O1xuICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIHZhciBmcmFtZSA9IGdldFJlY3Qoe1xuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGJvdHRvbTogYm90dG9tXG4gIH0pO1xuICB2YXIgdmlld3BvcnQgPSB7XG4gICAgZnJhbWU6IGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsLFxuICAgICAgY3VycmVudDogc2Nyb2xsLFxuICAgICAgbWF4OiBtYXhTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgIGRpc3BsYWNlbWVudDogb3JpZ2luXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gdmlld3BvcnQ7XG59KTtcblxudmFyIGdldEluaXRpYWxQdWJsaXNoID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjcml0aWNhbCA9IF9yZWYuY3JpdGljYWwsXG4gICAgICBzY3JvbGxPcHRpb25zID0gX3JlZi5zY3JvbGxPcHRpb25zLFxuICAgICAgcmVnaXN0cnkgPSBfcmVmLnJlZ2lzdHJ5O1xuICBzdGFydCgpO1xuICB2YXIgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCgpO1xuICB2YXIgd2luZG93U2Nyb2xsID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIHZhciBob21lID0gY3JpdGljYWwuZHJvcHBhYmxlO1xuICB2YXIgZHJvcHBhYmxlcyA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmNhbGxiYWNrcy5nZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCh3aW5kb3dTY3JvbGwsIHNjcm9sbE9wdGlvbnMpO1xuICB9KTtcbiAgdmFyIGRyYWdnYWJsZXMgPSByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QWxsQnlUeXBlKGNyaXRpY2FsLmRyYWdnYWJsZS50eXBlKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmdldERpbWVuc2lvbih3aW5kb3dTY3JvbGwpO1xuICB9KTtcbiAgdmFyIGRpbWVuc2lvbnMgPSB7XG4gICAgZHJhZ2dhYmxlczogdG9EcmFnZ2FibGVNYXAoZHJhZ2dhYmxlcyksXG4gICAgZHJvcHBhYmxlczogdG9Ecm9wcGFibGVNYXAoZHJvcHBhYmxlcylcbiAgfTtcbiAgZmluaXNoKCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICBjcml0aWNhbDogY3JpdGljYWwsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGVudHJ5KSB7XG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2luZy5pZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLnR5cGUgIT09IGRyYWdnaW5nLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuXG4gIGlmIChob21lLmRlc2NyaXB0b3IubW9kZSAhPT0gJ3ZpcnR1YWwnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgIFlvdSBhcmUgYXR0ZW1wdGluZyB0byBhZGQgb3IgcmVtb3ZlIGEgRHJhZ2dhYmxlIFtpZDogXCIgKyBlbnRyeS5kZXNjcmlwdG9yLmlkICsgXCJdXFxuICAgICAgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgdmlydHVhbCBsaXN0cy5cXG5cXG4gICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2Jsb2IvbWFzdGVyL2RvY3MvcGF0dGVybnMvdmlydHVhbC1saXN0cy5tZFxcbiAgICBcIikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBjcmVhdGVEaW1lbnNpb25NYXJzaGFsID0gKGZ1bmN0aW9uIChyZWdpc3RyeSwgY2FsbGJhY2tzKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gbnVsbDtcbiAgdmFyIHB1Ymxpc2hlciA9IGNyZWF0ZVB1Ymxpc2hlcih7XG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBwdWJsaXNoOiBjYWxsYmFja3MucHVibGlzaFdoaWxlRHJhZ2dpbmcsXG4gICAgICBjb2xsZWN0aW9uU3RhcnRpbmc6IGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmdcbiAgICB9LFxuICAgIHJlZ2lzdHJ5OiByZWdpc3RyeVxuICB9KTtcblxuICB2YXIgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gZnVuY3Rpb24gdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKGlkLCBpc0VuYWJsZWQpIHtcbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IHVwZGF0ZSBpcyBlbmFibGVkIGZsYWcgb2YgRHJvcHBhYmxlIFwiICsgaWQgKyBcIiBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZFwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlzRW5hYmxlZDogaXNFbmFibGVkXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQgPSBmdW5jdGlvbiB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKGlkLCBpc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCB1cGRhdGUgaXNDb21iaW5lRW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSBcIiArIGlkICsgXCIgYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQ6IGlzQ29tYmluZUVuYWJsZWRcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gZnVuY3Rpb24gdXBkYXRlRHJvcHBhYmxlU2Nyb2xsKGlkLCBuZXdTY3JvbGwpIHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IHVwZGF0ZSB0aGUgc2Nyb2xsIG9uIERyb3BwYWJsZSBcIiArIGlkICsgXCIgYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVTY3JvbGwoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgbmV3U2Nyb2xsOiBuZXdTY3JvbGxcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgc2Nyb2xsRHJvcHBhYmxlID0gZnVuY3Rpb24gc2Nyb2xsRHJvcHBhYmxlKGlkLCBjaGFuZ2UpIHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCkuY2FsbGJhY2tzLnNjcm9sbChjaGFuZ2UpO1xuICB9O1xuXG4gIHZhciBzdG9wUHVibGlzaGluZyA9IGZ1bmN0aW9uIHN0b3BQdWJsaXNoaW5nKCkge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1Ymxpc2hlci5zdG9wKCk7XG4gICAgdmFyIGhvbWUgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QWxsQnlUeXBlKGhvbWUudHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS5jYWxsYmFja3MuZHJhZ1N0b3BwZWQoKTtcbiAgICB9KTtcbiAgICBjb2xsZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgY29sbGVjdGlvbiA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHN1YnNjcmliZXIgPSBmdW5jdGlvbiBzdWJzY3JpYmVyKGV2ZW50KSB7XG4gICAgIWNvbGxlY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgb25seSBiZSBzdWJzY3JpYmVkIHdoZW4gYSBjb2xsZWN0aW9uIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZHJhZ2dpbmcgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyYWdnYWJsZTtcblxuICAgIGlmIChldmVudC50eXBlID09PSAnQURESVRJT04nKSB7XG4gICAgICBpZiAoc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICBwdWJsaXNoZXIuYWRkKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ1JFTU9WQUwnKSB7XG4gICAgICBpZiAoc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICBwdWJsaXNoZXIucmVtb3ZlKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHN0YXJ0UHVibGlzaGluZyA9IGZ1bmN0aW9uIHN0YXJ0UHVibGlzaGluZyhyZXF1ZXN0KSB7XG4gICAgISFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGNhcHR1cmluZyBjcml0aWNhbCBkaW1lbnNpb25zIGFzIHRoZXJlIGlzIGFscmVhZHkgYSBjb2xsZWN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKHJlcXVlc3QuZHJhZ2dhYmxlSWQpO1xuICAgIHZhciBob21lID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZCk7XG4gICAgdmFyIGNyaXRpY2FsID0ge1xuICAgICAgZHJhZ2dhYmxlOiBlbnRyeS5kZXNjcmlwdG9yLFxuICAgICAgZHJvcHBhYmxlOiBob21lLmRlc2NyaXB0b3JcbiAgICB9O1xuICAgIHZhciB1bnN1YnNjcmliZSA9IHJlZ2lzdHJ5LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICBjb2xsZWN0aW9uID0ge1xuICAgICAgY3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0SW5pdGlhbFB1Ymxpc2goe1xuICAgICAgY3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgcmVnaXN0cnk6IHJlZ2lzdHJ5LFxuICAgICAgc2Nyb2xsT3B0aW9uczogcmVxdWVzdC5zY3JvbGxPcHRpb25zXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG1hcnNoYWwgPSB7XG4gICAgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkOiB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZDogdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBzY3JvbGxEcm9wcGFibGU6IHNjcm9sbERyb3BwYWJsZSxcbiAgICB1cGRhdGVEcm9wcGFibGVTY3JvbGw6IHVwZGF0ZURyb3BwYWJsZVNjcm9sbCxcbiAgICBzdGFydFB1Ymxpc2hpbmc6IHN0YXJ0UHVibGlzaGluZyxcbiAgICBzdG9wUHVibGlzaGluZzogc3RvcFB1Ymxpc2hpbmdcbiAgfTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59KTtcblxudmFyIGNhblN0YXJ0RHJhZyA9IChmdW5jdGlvbiAoc3RhdGUsIGlkKSB7XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc3RhdGUucGhhc2UgIT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuY29tcGxldGVkLnJlc3VsdC5yZWFzb24gPT09ICdEUk9QJztcbn0pO1xuXG52YXIgc2Nyb2xsV2luZG93ID0gKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgd2luZG93LnNjcm9sbEJ5KGNoYW5nZS54LCBjaGFuZ2UueSk7XG59KTtcblxudmFyIGdldFNjcm9sbGFibGVEcm9wcGFibGVzID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZHJvcHBhYmxlcykge1xuICByZXR1cm4gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgaWYgKCFkcm9wcGFibGUuaXNFbmFibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFkcm9wcGFibGUuZnJhbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59KTtcblxudmFyIGdldFNjcm9sbGFibGVEcm9wcGFibGVPdmVyID0gZnVuY3Rpb24gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIodGFyZ2V0LCBkcm9wcGFibGVzKSB7XG4gIHZhciBtYXliZSA9IGZpbmQoZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMoZHJvcHBhYmxlcyksIGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICAhZHJvcHBhYmxlLmZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCByZXN1bHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGlzUG9zaXRpb25JbkZyYW1lKGRyb3BwYWJsZS5mcmFtZS5wYWdlTWFyZ2luQm94KSh0YXJnZXQpO1xuICB9KTtcbiAgcmV0dXJuIG1heWJlO1xufTtcblxudmFyIGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjZW50ZXIgPSBfcmVmLmNlbnRlcixcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGRyb3BwYWJsZXMgPSBfcmVmLmRyb3BwYWJsZXM7XG5cbiAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgdmFyIF9kaW1lbnNpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uXTtcblxuICAgIGlmICghX2RpbWVuc2lvbi5mcmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kaW1lbnNpb247XG4gIH1cblxuICB2YXIgZGltZW5zaW9uID0gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIoY2VudGVyLCBkcm9wcGFibGVzKTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn0pO1xuXG52YXIgY29uZmlnID0ge1xuICBzdGFydEZyb21QZXJjZW50YWdlOiAwLjI1LFxuICBtYXhTY3JvbGxBdFBlcmNlbnRhZ2U6IDAuMDUsXG4gIG1heFBpeGVsU2Nyb2xsOiAyOCxcbiAgZWFzZTogZnVuY3Rpb24gZWFzZShwZXJjZW50YWdlKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHBlcmNlbnRhZ2UsIDIpO1xuICB9LFxuICBkdXJhdGlvbkRhbXBlbmluZzoge1xuICAgIHN0b3BEYW1wZW5pbmdBdDogMTIwMCxcbiAgICBhY2NlbGVyYXRlQXQ6IDM2MFxuICB9XG59O1xuXG52YXIgZ2V0RGlzdGFuY2VUaHJlc2hvbGRzID0gKGZ1bmN0aW9uIChjb250YWluZXIsIGF4aXMpIHtcbiAgdmFyIHN0YXJ0U2Nyb2xsaW5nRnJvbSA9IGNvbnRhaW5lcltheGlzLnNpemVdICogY29uZmlnLnN0YXJ0RnJvbVBlcmNlbnRhZ2U7XG4gIHZhciBtYXhTY3JvbGxWYWx1ZUF0ID0gY29udGFpbmVyW2F4aXMuc2l6ZV0gKiBjb25maWcubWF4U2Nyb2xsQXRQZXJjZW50YWdlO1xuICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICBzdGFydFNjcm9sbGluZ0Zyb206IHN0YXJ0U2Nyb2xsaW5nRnJvbSxcbiAgICBtYXhTY3JvbGxWYWx1ZUF0OiBtYXhTY3JvbGxWYWx1ZUF0XG4gIH07XG4gIHJldHVybiB0aHJlc2hvbGRzO1xufSk7XG5cbnZhciBnZXRQZXJjZW50YWdlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdGFydE9mUmFuZ2UgPSBfcmVmLnN0YXJ0T2ZSYW5nZSxcbiAgICAgIGVuZE9mUmFuZ2UgPSBfcmVmLmVuZE9mUmFuZ2UsXG4gICAgICBjdXJyZW50ID0gX3JlZi5jdXJyZW50O1xuICB2YXIgcmFuZ2UgPSBlbmRPZlJhbmdlIC0gc3RhcnRPZlJhbmdlO1xuXG4gIGlmIChyYW5nZSA9PT0gMCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICBEZXRlY3RlZCBkaXN0YW5jZSByYW5nZSBvZiAwIGluIHRoZSBmbHVpZCBhdXRvIHNjcm9sbGVyXFxuICAgICAgVGhpcyBpcyB1bmV4cGVjdGVkIGFuZCB3b3VsZCBjYXVzZSBhIGRpdmlkZSBieSAwIGlzc3VlLlxcbiAgICAgIE5vdCBhbGxvd2luZyBhbiBhdXRvIHNjcm9sbFxcbiAgICBcIikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgY3VycmVudEluUmFuZ2UgPSBjdXJyZW50IC0gc3RhcnRPZlJhbmdlO1xuICB2YXIgcGVyY2VudGFnZSA9IGN1cnJlbnRJblJhbmdlIC8gcmFuZ2U7XG4gIHJldHVybiBwZXJjZW50YWdlO1xufSk7XG5cbnZhciBtaW5TY3JvbGwgPSAxO1xuXG52YXIgZ2V0VmFsdWVGcm9tRGlzdGFuY2UgPSAoZnVuY3Rpb24gKGRpc3RhbmNlVG9FZGdlLCB0aHJlc2hvbGRzKSB7XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA+IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPD0gdGhyZXNob2xkcy5tYXhTY3JvbGxWYWx1ZUF0KSB7XG4gICAgcmV0dXJuIGNvbmZpZy5tYXhQaXhlbFNjcm9sbDtcbiAgfVxuXG4gIGlmIChkaXN0YW5jZVRvRWRnZSA9PT0gdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20pIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG5cbiAgdmFyIHBlcmNlbnRhZ2VGcm9tTWF4U2Nyb2xsVmFsdWVBdCA9IGdldFBlcmNlbnRhZ2Uoe1xuICAgIHN0YXJ0T2ZSYW5nZTogdGhyZXNob2xkcy5tYXhTY3JvbGxWYWx1ZUF0LFxuICAgIGVuZE9mUmFuZ2U6IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tLFxuICAgIGN1cnJlbnQ6IGRpc3RhbmNlVG9FZGdlXG4gIH0pO1xuICB2YXIgcGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20gPSAxIC0gcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0O1xuICB2YXIgc2Nyb2xsID0gY29uZmlnLm1heFBpeGVsU2Nyb2xsICogY29uZmlnLmVhc2UocGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20pO1xuICByZXR1cm4gTWF0aC5jZWlsKHNjcm9sbCk7XG59KTtcblxudmFyIGFjY2VsZXJhdGVBdCA9IGNvbmZpZy5kdXJhdGlvbkRhbXBlbmluZy5hY2NlbGVyYXRlQXQ7XG52YXIgc3RvcEF0ID0gY29uZmlnLmR1cmF0aW9uRGFtcGVuaW5nLnN0b3BEYW1wZW5pbmdBdDtcbnZhciBkYW1wZW5WYWx1ZUJ5VGltZSA9IChmdW5jdGlvbiAocHJvcG9zZWRTY3JvbGwsIGRyYWdTdGFydFRpbWUpIHtcbiAgdmFyIHN0YXJ0T2ZSYW5nZSA9IGRyYWdTdGFydFRpbWU7XG4gIHZhciBlbmRPZlJhbmdlID0gc3RvcEF0O1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgdmFyIHJ1blRpbWUgPSBub3cgLSBzdGFydE9mUmFuZ2U7XG5cbiAgaWYgKHJ1blRpbWUgPj0gc3RvcEF0KSB7XG4gICAgcmV0dXJuIHByb3Bvc2VkU2Nyb2xsO1xuICB9XG5cbiAgaWYgKHJ1blRpbWUgPCBhY2NlbGVyYXRlQXQpIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG5cbiAgdmFyIGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlID0gZ2V0UGVyY2VudGFnZSh7XG4gICAgc3RhcnRPZlJhbmdlOiBhY2NlbGVyYXRlQXQsXG4gICAgZW5kT2ZSYW5nZTogZW5kT2ZSYW5nZSxcbiAgICBjdXJyZW50OiBydW5UaW1lXG4gIH0pO1xuICB2YXIgc2Nyb2xsID0gcHJvcG9zZWRTY3JvbGwgKiBjb25maWcuZWFzZShiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSk7XG4gIHJldHVybiBNYXRoLmNlaWwoc2Nyb2xsKTtcbn0pO1xuXG52YXIgZ2V0VmFsdWUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRpc3RhbmNlVG9FZGdlID0gX3JlZi5kaXN0YW5jZVRvRWRnZSxcbiAgICAgIHRocmVzaG9sZHMgPSBfcmVmLnRocmVzaG9sZHMsXG4gICAgICBkcmFnU3RhcnRUaW1lID0gX3JlZi5kcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9yZWYuc2hvdWxkVXNlVGltZURhbXBlbmluZztcbiAgdmFyIHNjcm9sbCA9IGdldFZhbHVlRnJvbURpc3RhbmNlKGRpc3RhbmNlVG9FZGdlLCB0aHJlc2hvbGRzKTtcblxuICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoIXNob3VsZFVzZVRpbWVEYW1wZW5pbmcpIHtcbiAgICByZXR1cm4gc2Nyb2xsO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4KGRhbXBlblZhbHVlQnlUaW1lKHNjcm9sbCwgZHJhZ1N0YXJ0VGltZSksIG1pblNjcm9sbCk7XG59KTtcblxudmFyIGdldFNjcm9sbE9uQXhpcyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICBkaXN0YW5jZVRvRWRnZXMgPSBfcmVmLmRpc3RhbmNlVG9FZGdlcyxcbiAgICAgIGRyYWdTdGFydFRpbWUgPSBfcmVmLmRyYWdTdGFydFRpbWUsXG4gICAgICBheGlzID0gX3JlZi5heGlzLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9yZWYuc2hvdWxkVXNlVGltZURhbXBlbmluZztcbiAgdmFyIHRocmVzaG9sZHMgPSBnZXREaXN0YW5jZVRocmVzaG9sZHMoY29udGFpbmVyLCBheGlzKTtcbiAgdmFyIGlzQ2xvc2VyVG9FbmQgPSBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdIDwgZGlzdGFuY2VUb0VkZ2VzW2F4aXMuc3RhcnRdO1xuXG4gIGlmIChpc0Nsb3NlclRvRW5kKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKHtcbiAgICAgIGRpc3RhbmNlVG9FZGdlOiBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdLFxuICAgICAgdGhyZXNob2xkczogdGhyZXNob2xkcyxcbiAgICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gLTEgKiBnZXRWYWx1ZSh7XG4gICAgZGlzdGFuY2VUb0VkZ2U6IGRpc3RhbmNlVG9FZGdlc1theGlzLnN0YXJ0XSxcbiAgICB0aHJlc2hvbGRzOiB0aHJlc2hvbGRzLFxuICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogc2hvdWxkVXNlVGltZURhbXBlbmluZ1xuICB9KTtcbn0pO1xuXG52YXIgYWRqdXN0Rm9yU2l6ZUxpbWl0cyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gX3JlZi5zdWJqZWN0LFxuICAgICAgcHJvcG9zZWRTY3JvbGwgPSBfcmVmLnByb3Bvc2VkU2Nyb2xsO1xuICB2YXIgaXNUb29CaWdWZXJ0aWNhbGx5ID0gc3ViamVjdC5oZWlnaHQgPiBjb250YWluZXIuaGVpZ2h0O1xuICB2YXIgaXNUb29CaWdIb3Jpem9udGFsbHkgPSBzdWJqZWN0LndpZHRoID4gY29udGFpbmVyLndpZHRoO1xuXG4gIGlmICghaXNUb29CaWdIb3Jpem9udGFsbHkgJiYgIWlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBwcm9wb3NlZFNjcm9sbDtcbiAgfVxuXG4gIGlmIChpc1Rvb0JpZ0hvcml6b250YWxseSAmJiBpc1Rvb0JpZ1ZlcnRpY2FsbHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogaXNUb29CaWdIb3Jpem9udGFsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueCxcbiAgICB5OiBpc1Rvb0JpZ1ZlcnRpY2FsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueVxuICB9O1xufSk7XG5cbnZhciBjbGVhbiQyID0gYXBwbHkoZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbn0pO1xudmFyIGdldFNjcm9sbCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZHJhZ1N0YXJ0VGltZSA9IF9yZWYuZHJhZ1N0YXJ0VGltZSxcbiAgICAgIGNvbnRhaW5lciA9IF9yZWYuY29udGFpbmVyLFxuICAgICAgc3ViamVjdCA9IF9yZWYuc3ViamVjdCxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9yZWYuc2hvdWxkVXNlVGltZURhbXBlbmluZztcbiAgdmFyIGRpc3RhbmNlVG9FZGdlcyA9IHtcbiAgICB0b3A6IGNlbnRlci55IC0gY29udGFpbmVyLnRvcCxcbiAgICByaWdodDogY29udGFpbmVyLnJpZ2h0IC0gY2VudGVyLngsXG4gICAgYm90dG9tOiBjb250YWluZXIuYm90dG9tIC0gY2VudGVyLnksXG4gICAgbGVmdDogY2VudGVyLnggLSBjb250YWluZXIubGVmdFxuICB9O1xuICB2YXIgeSA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzOiBkaXN0YW5jZVRvRWRnZXMsXG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBheGlzOiB2ZXJ0aWNhbCxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gIH0pO1xuICB2YXIgeCA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzOiBkaXN0YW5jZVRvRWRnZXMsXG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBheGlzOiBob3Jpem9udGFsLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHNob3VsZFVzZVRpbWVEYW1wZW5pbmdcbiAgfSk7XG4gIHZhciByZXF1aXJlZCA9IGNsZWFuJDIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KTtcblxuICBpZiAoaXNFcXVhbChyZXF1aXJlZCwgb3JpZ2luKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpbWl0ZWQgPSBhZGp1c3RGb3JTaXplTGltaXRzKHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgIHByb3Bvc2VkU2Nyb2xsOiByZXF1aXJlZFxuICB9KTtcblxuICBpZiAoIWxpbWl0ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBpc0VxdWFsKGxpbWl0ZWQsIG9yaWdpbikgPyBudWxsIDogbGltaXRlZDtcbn0pO1xuXG52YXIgc21hbGxlc3RTaWduZWQgPSBhcHBseShmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdmFsdWUgPiAwID8gMSA6IC0xO1xufSk7XG52YXIgZ2V0T3ZlcmxhcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdldFJlbWFpbmRlciA9IGZ1bmN0aW9uIGdldFJlbWFpbmRlcih0YXJnZXQsIG1heCkge1xuICAgIGlmICh0YXJnZXQgPCAwKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQgPiBtYXgpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgLSBtYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBfcmVmLmN1cnJlbnQsXG4gICAgICAgIG1heCA9IF9yZWYubWF4LFxuICAgICAgICBjaGFuZ2UgPSBfcmVmLmNoYW5nZTtcbiAgICB2YXIgdGFyZ2V0U2Nyb2xsID0gYWRkKGN1cnJlbnQsIGNoYW5nZSk7XG4gICAgdmFyIG92ZXJsYXAgPSB7XG4gICAgICB4OiBnZXRSZW1haW5kZXIodGFyZ2V0U2Nyb2xsLngsIG1heC54KSxcbiAgICAgIHk6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueSwgbWF4LnkpXG4gICAgfTtcblxuICAgIGlmIChpc0VxdWFsKG92ZXJsYXAsIG9yaWdpbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBvdmVybGFwO1xuICB9O1xufSgpO1xudmFyIGNhblBhcnRpYWxseVNjcm9sbCA9IGZ1bmN0aW9uIGNhblBhcnRpYWxseVNjcm9sbChfcmVmMikge1xuICB2YXIgcmF3TWF4ID0gX3JlZjIubWF4LFxuICAgICAgY3VycmVudCA9IF9yZWYyLmN1cnJlbnQsXG4gICAgICBjaGFuZ2UgPSBfcmVmMi5jaGFuZ2U7XG4gIHZhciBtYXggPSB7XG4gICAgeDogTWF0aC5tYXgoY3VycmVudC54LCByYXdNYXgueCksXG4gICAgeTogTWF0aC5tYXgoY3VycmVudC55LCByYXdNYXgueSlcbiAgfTtcbiAgdmFyIHNtYWxsZXN0Q2hhbmdlID0gc21hbGxlc3RTaWduZWQoY2hhbmdlKTtcbiAgdmFyIG92ZXJsYXAgPSBnZXRPdmVybGFwKHtcbiAgICBtYXg6IG1heCxcbiAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgIGNoYW5nZTogc21hbGxlc3RDaGFuZ2VcbiAgfSk7XG5cbiAgaWYgKCFvdmVybGFwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc21hbGxlc3RDaGFuZ2UueCAhPT0gMCAmJiBvdmVybGFwLnggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzbWFsbGVzdENoYW5nZS55ICE9PSAwICYmIG92ZXJsYXAueSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBjYW5TY3JvbGxXaW5kb3cgPSBmdW5jdGlvbiBjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkge1xuICByZXR1cm4gY2FuUGFydGlhbGx5U2Nyb2xsKHtcbiAgICBjdXJyZW50OiB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlOiBjaGFuZ2VcbiAgfSk7XG59O1xudmFyIGdldFdpbmRvd092ZXJsYXAgPSBmdW5jdGlvbiBnZXRXaW5kb3dPdmVybGFwKHZpZXdwb3J0LCBjaGFuZ2UpIHtcbiAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXggPSB2aWV3cG9ydC5zY3JvbGwubWF4O1xuICB2YXIgY3VycmVudCA9IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50O1xuICByZXR1cm4gZ2V0T3ZlcmxhcCh7XG4gICAgY3VycmVudDogY3VycmVudCxcbiAgICBtYXg6IG1heCxcbiAgICBjaGFuZ2U6IGNoYW5nZVxuICB9KTtcbn07XG52YXIgY2FuU2Nyb2xsRHJvcHBhYmxlID0gZnVuY3Rpb24gY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSB7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNhblBhcnRpYWxseVNjcm9sbCh7XG4gICAgY3VycmVudDogZnJhbWUuc2Nyb2xsLmN1cnJlbnQsXG4gICAgbWF4OiBmcmFtZS5zY3JvbGwubWF4LFxuICAgIGNoYW5nZTogY2hhbmdlXG4gIH0pO1xufTtcbnZhciBnZXREcm9wcGFibGVPdmVybGFwID0gZnVuY3Rpb24gZ2V0RHJvcHBhYmxlT3ZlcmxhcChkcm9wcGFibGUsIGNoYW5nZSkge1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBjaGFuZ2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0T3ZlcmxhcCh7XG4gICAgY3VycmVudDogZnJhbWUuc2Nyb2xsLmN1cnJlbnQsXG4gICAgbWF4OiBmcmFtZS5zY3JvbGwubWF4LFxuICAgIGNoYW5nZTogY2hhbmdlXG4gIH0pO1xufTtcblxudmFyIGdldFdpbmRvd1Njcm9sbENoYW5nZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgc3ViamVjdCA9IF9yZWYuc3ViamVjdCxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgZHJhZ1N0YXJ0VGltZSA9IF9yZWYuZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcgPSBfcmVmLnNob3VsZFVzZVRpbWVEYW1wZW5pbmc7XG4gIHZhciBzY3JvbGwgPSBnZXRTY3JvbGwoe1xuICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgY29udGFpbmVyOiB2aWV3cG9ydC5mcmFtZSxcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHNob3VsZFVzZVRpbWVEYW1wZW5pbmdcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBzY3JvbGwpID8gc2Nyb2xsIDogbnVsbDtcbn0pO1xuXG52YXIgZ2V0RHJvcHBhYmxlU2Nyb2xsQ2hhbmdlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkcm9wcGFibGUgPSBfcmVmLmRyb3BwYWJsZSxcbiAgICAgIHN1YmplY3QgPSBfcmVmLnN1YmplY3QsXG4gICAgICBjZW50ZXIgPSBfcmVmLmNlbnRlcixcbiAgICAgIGRyYWdTdGFydFRpbWUgPSBfcmVmLmRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nID0gX3JlZi5zaG91bGRVc2VUaW1lRGFtcGVuaW5nO1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjcm9sbCA9IGdldFNjcm9sbCh7XG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IGZyYW1lLnBhZ2VNYXJnaW5Cb3gsXG4gICAgc3ViamVjdDogc3ViamVjdCxcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gIH0pO1xuICByZXR1cm4gc2Nyb2xsICYmIGNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufSk7XG5cbnZhciBzY3JvbGwkMSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgZHJhZ1N0YXJ0VGltZSA9IF9yZWYuZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcgPSBfcmVmLnNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBzY3JvbGxXaW5kb3cgPSBfcmVmLnNjcm9sbFdpbmRvdyxcbiAgICAgIHNjcm9sbERyb3BwYWJsZSA9IF9yZWYuc2Nyb2xsRHJvcHBhYmxlO1xuICB2YXIgY2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgdmFyIGRyYWdnYWJsZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICB2YXIgc3ViamVjdCA9IGRyYWdnYWJsZS5wYWdlLm1hcmdpbkJveDtcblxuICBpZiAoc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkKSB7XG4gICAgdmFyIHZpZXdwb3J0ID0gc3RhdGUudmlld3BvcnQ7XG5cbiAgICB2YXIgX2NoYW5nZSA9IGdldFdpbmRvd1Njcm9sbENoYW5nZSh7XG4gICAgICBkcmFnU3RhcnRUaW1lOiBkcmFnU3RhcnRUaW1lLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgc3ViamVjdDogc3ViamVjdCxcbiAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogc2hvdWxkVXNlVGltZURhbXBlbmluZ1xuICAgIH0pO1xuXG4gICAgaWYgKF9jaGFuZ2UpIHtcbiAgICAgIHNjcm9sbFdpbmRvdyhfY2hhbmdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2YXIgZHJvcHBhYmxlID0gZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUoe1xuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIGRlc3RpbmF0aW9uOiB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpLFxuICAgIGRyb3BwYWJsZXM6IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcblxuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGFuZ2UgPSBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2Uoe1xuICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGUsXG4gICAgc3ViamVjdDogc3ViamVjdCxcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gIH0pO1xuXG4gIGlmIChjaGFuZ2UpIHtcbiAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGNoYW5nZSk7XG4gIH1cbn0pO1xuXG52YXIgY3JlYXRlRmx1aWRTY3JvbGxlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc2Nyb2xsV2luZG93ID0gX3JlZi5zY3JvbGxXaW5kb3csXG4gICAgICBzY3JvbGxEcm9wcGFibGUgPSBfcmVmLnNjcm9sbERyb3BwYWJsZTtcbiAgdmFyIHNjaGVkdWxlV2luZG93U2Nyb2xsID0gcmFmU2NoZChzY3JvbGxXaW5kb3cpO1xuICB2YXIgc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwgPSByYWZTY2hkKHNjcm9sbERyb3BwYWJsZSk7XG4gIHZhciBkcmFnZ2luZyA9IG51bGw7XG5cbiAgdmFyIHRyeVNjcm9sbCA9IGZ1bmN0aW9uIHRyeVNjcm9sbChzdGF0ZSkge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmbHVpZCBzY3JvbGwgaWYgbm90IGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfZHJhZ2dpbmcgPSBkcmFnZ2luZyxcbiAgICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9kcmFnZ2luZy5zaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgICBkcmFnU3RhcnRUaW1lID0gX2RyYWdnaW5nLmRyYWdTdGFydFRpbWU7XG4gICAgc2Nyb2xsJDEoe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2Nyb2xsV2luZG93OiBzY2hlZHVsZVdpbmRvd1Njcm9sbCxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwsXG4gICAgICBkcmFnU3RhcnRUaW1lOiBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogc2hvdWxkVXNlVGltZURhbXBlbmluZ1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzdGFydCQxID0gZnVuY3Rpb24gc3RhcnQkMShzdGF0ZSkge1xuICAgIHN0YXJ0KCk7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBhdXRvIHNjcm9sbGluZyB3aGVuIGFscmVhZHkgc3RhcnRlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZHJhZ1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdmFyIHdhc1Njcm9sbE5lZWRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGZha2VTY3JvbGxDYWxsYmFjayA9IGZ1bmN0aW9uIGZha2VTY3JvbGxDYWxsYmFjaygpIHtcbiAgICAgIHdhc1Njcm9sbE5lZWRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIHNjcm9sbCQxKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGRyYWdTdGFydFRpbWU6IDAsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBmYWxzZSxcbiAgICAgIHNjcm9sbFdpbmRvdzogZmFrZVNjcm9sbENhbGxiYWNrLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBmYWtlU2Nyb2xsQ2FsbGJhY2tcbiAgICB9KTtcbiAgICBkcmFnZ2luZyA9IHtcbiAgICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiB3YXNTY3JvbGxOZWVkZWRcbiAgICB9O1xuICAgIGZpbmlzaCgpO1xuXG4gICAgaWYgKHdhc1Njcm9sbE5lZWRlZCkge1xuICAgICAgdHJ5U2Nyb2xsKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVdpbmRvd1Njcm9sbC5jYW5jZWwoKTtcbiAgICBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbC5jYW5jZWwoKTtcbiAgICBkcmFnZ2luZyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQkMSxcbiAgICBzdG9wOiBzdG9wLFxuICAgIHNjcm9sbDogdHJ5U2Nyb2xsXG4gIH07XG59KTtcblxudmFyIGNyZWF0ZUp1bXBTY3JvbGxlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbW92ZSA9IF9yZWYubW92ZSxcbiAgICAgIHNjcm9sbERyb3BwYWJsZSA9IF9yZWYuc2Nyb2xsRHJvcHBhYmxlLFxuICAgICAgc2Nyb2xsV2luZG93ID0gX3JlZi5zY3JvbGxXaW5kb3c7XG5cbiAgdmFyIG1vdmVCeU9mZnNldCA9IGZ1bmN0aW9uIG1vdmVCeU9mZnNldChzdGF0ZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGNsaWVudCA9IGFkZChzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24sIG9mZnNldCk7XG4gICAgbW92ZSh7XG4gICAgICBjbGllbnQ6IGNsaWVudFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuID0gZnVuY3Rpb24gc2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbihkcm9wcGFibGUsIGNoYW5nZSkge1xuICAgIGlmICghY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxhcCA9IGdldERyb3BwYWJsZU92ZXJsYXAoZHJvcHBhYmxlLCBjaGFuZ2UpO1xuXG4gICAgaWYgKCFvdmVybGFwKSB7XG4gICAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsKTtcbiAgICB2YXIgcmVtYWluZGVyID0gc3VidHJhY3QoY2hhbmdlLCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsKTtcbiAgICByZXR1cm4gcmVtYWluZGVyO1xuICB9O1xuXG4gIHZhciBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuID0gZnVuY3Rpb24gc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbihpc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBjaGFuZ2UpIHtcbiAgICBpZiAoIWlzV2luZG93U2Nyb2xsQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICBpZiAoIWNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxhcCA9IGdldFdpbmRvd092ZXJsYXAodmlld3BvcnQsIGNoYW5nZSk7XG5cbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbFdpbmRvdyhjaGFuZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwgPSBzdWJ0cmFjdChjaGFuZ2UsIG92ZXJsYXApO1xuICAgIHNjcm9sbFdpbmRvdyh3aGF0VGhlV2luZG93Q2FuU2Nyb2xsKTtcbiAgICB2YXIgcmVtYWluZGVyID0gc3VidHJhY3QoY2hhbmdlLCB3aGF0VGhlV2luZG93Q2FuU2Nyb2xsKTtcbiAgICByZXR1cm4gcmVtYWluZGVyO1xuICB9O1xuXG4gIHZhciBqdW1wU2Nyb2xsZXIgPSBmdW5jdGlvbiBqdW1wU2Nyb2xsZXIoc3RhdGUpIHtcbiAgICB2YXIgcmVxdWVzdCA9IHN0YXRlLnNjcm9sbEp1bXBSZXF1ZXN0O1xuXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlc3RpbmF0aW9uID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgICAhZGVzdGluYXRpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcGVyZm9ybSBhIGp1bXAgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZGVzdGluYXRpb24nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGRyb3BwYWJsZVJlbWFpbmRlciA9IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4oc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2Rlc3RpbmF0aW9uXSwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIWRyb3BwYWJsZVJlbWFpbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2aWV3cG9ydCA9IHN0YXRlLnZpZXdwb3J0O1xuICAgIHZhciB3aW5kb3dSZW1haW5kZXIgPSBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuKHN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCwgdmlld3BvcnQsIGRyb3BwYWJsZVJlbWFpbmRlcik7XG5cbiAgICBpZiAoIXdpbmRvd1JlbWFpbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vdmVCeU9mZnNldChzdGF0ZSwgd2luZG93UmVtYWluZGVyKTtcbiAgfTtcblxuICByZXR1cm4ganVtcFNjcm9sbGVyO1xufSk7XG5cbnZhciBjcmVhdGVBdXRvU2Nyb2xsZXIgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHNjcm9sbERyb3BwYWJsZSA9IF9yZWYuc2Nyb2xsRHJvcHBhYmxlLFxuICAgICAgc2Nyb2xsV2luZG93ID0gX3JlZi5zY3JvbGxXaW5kb3csXG4gICAgICBtb3ZlID0gX3JlZi5tb3ZlO1xuICB2YXIgZmx1aWRTY3JvbGxlciA9IGNyZWF0ZUZsdWlkU2Nyb2xsZXIoe1xuICAgIHNjcm9sbFdpbmRvdzogc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZTogc2Nyb2xsRHJvcHBhYmxlXG4gIH0pO1xuICB2YXIganVtcFNjcm9sbCA9IGNyZWF0ZUp1bXBTY3JvbGxlcih7XG4gICAgbW92ZTogbW92ZSxcbiAgICBzY3JvbGxXaW5kb3c6IHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGU6IHNjcm9sbERyb3BwYWJsZVxuICB9KTtcblxuICB2YXIgc2Nyb2xsID0gZnVuY3Rpb24gc2Nyb2xsKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ0ZMVUlEJykge1xuICAgICAgZmx1aWRTY3JvbGxlci5zY3JvbGwoc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghc3RhdGUuc2Nyb2xsSnVtcFJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBqdW1wU2Nyb2xsKHN0YXRlKTtcbiAgfTtcblxuICB2YXIgc2Nyb2xsZXIgPSB7XG4gICAgc2Nyb2xsOiBzY3JvbGwsXG4gICAgc3RhcnQ6IGZsdWlkU2Nyb2xsZXIuc3RhcnQsXG4gICAgc3RvcDogZmx1aWRTY3JvbGxlci5zdG9wXG4gIH07XG4gIHJldHVybiBzY3JvbGxlcjtcbn0pO1xuXG52YXIgcHJlZml4JDEgPSAnZGF0YS1yYmQnO1xudmFyIGRyYWdIYW5kbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXNlID0gcHJlZml4JDEgKyBcIi1kcmFnLWhhbmRsZVwiO1xuICByZXR1cm4ge1xuICAgIGJhc2U6IGJhc2UsXG4gICAgZHJhZ2dhYmxlSWQ6IGJhc2UgKyBcIi1kcmFnZ2FibGUtaWRcIixcbiAgICBjb250ZXh0SWQ6IGJhc2UgKyBcIi1jb250ZXh0LWlkXCJcbiAgfTtcbn0oKTtcbnZhciBkcmFnZ2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXNlID0gcHJlZml4JDEgKyBcIi1kcmFnZ2FibGVcIjtcbiAgcmV0dXJuIHtcbiAgICBiYXNlOiBiYXNlLFxuICAgIGNvbnRleHRJZDogYmFzZSArIFwiLWNvbnRleHQtaWRcIixcbiAgICBpZDogYmFzZSArIFwiLWlkXCJcbiAgfTtcbn0oKTtcbnZhciBkcm9wcGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXNlID0gcHJlZml4JDEgKyBcIi1kcm9wcGFibGVcIjtcbiAgcmV0dXJuIHtcbiAgICBiYXNlOiBiYXNlLFxuICAgIGNvbnRleHRJZDogYmFzZSArIFwiLWNvbnRleHQtaWRcIixcbiAgICBpZDogYmFzZSArIFwiLWlkXCJcbiAgfTtcbn0oKTtcbnZhciBzY3JvbGxDb250YWluZXIgPSB7XG4gIGNvbnRleHRJZDogcHJlZml4JDEgKyBcIi1zY3JvbGwtY29udGFpbmVyLWNvbnRleHQtaWRcIlxufTtcblxudmFyIG1ha2VHZXRTZWxlY3RvciA9IGZ1bmN0aW9uIG1ha2VHZXRTZWxlY3Rvcihjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIFwiW1wiICsgYXR0cmlidXRlICsgXCI9XFxcIlwiICsgY29udGV4dCArIFwiXFxcIl1cIjtcbiAgfTtcbn07XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiBnZXRTdHlsZXMocnVsZXMsIHByb3BlcnR5KSB7XG4gIHJldHVybiBydWxlcy5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICB2YXIgdmFsdWUgPSBydWxlLnN0eWxlc1twcm9wZXJ0eV07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGUuc2VsZWN0b3IgKyBcIiB7IFwiICsgdmFsdWUgKyBcIiB9XCI7XG4gIH0pLmpvaW4oJyAnKTtcbn07XG5cbnZhciBub1BvaW50ZXJFdmVudHMgPSAncG9pbnRlci1ldmVudHM6IG5vbmU7JztcbnZhciBnZXRTdHlsZXMkMSA9IChmdW5jdGlvbiAoY29udGV4dElkKSB7XG4gIHZhciBnZXRTZWxlY3RvciA9IG1ha2VHZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuXG4gIHZhciBkcmFnSGFuZGxlJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdyYWJDdXJzb3IgPSBcIlxcbiAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcbiAgICAgIGN1cnNvcjogZ3JhYjtcXG4gICAgXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnSGFuZGxlLmNvbnRleHRJZCksXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgYWx3YXlzOiBcIlxcbiAgICAgICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTtcXG4gICAgICAgICAgdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb247XFxuICAgICAgICBcIixcbiAgICAgICAgcmVzdGluZzogZ3JhYkN1cnNvcixcbiAgICAgICAgZHJhZ2dpbmc6IG5vUG9pbnRlckV2ZW50cyxcbiAgICAgICAgZHJvcEFuaW1hdGluZzogZ3JhYkN1cnNvclxuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgZHJhZ2dhYmxlJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyYW5zaXRpb24gPSBcIlxcbiAgICAgIHRyYW5zaXRpb246IFwiICsgdHJhbnNpdGlvbnMub3V0T2ZUaGVXYXkgKyBcIjtcXG4gICAgXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnZ2FibGUuY29udGV4dElkKSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICBkcmFnZ2luZzogdHJhbnNpdGlvbixcbiAgICAgICAgZHJvcEFuaW1hdGluZzogdHJhbnNpdGlvbixcbiAgICAgICAgdXNlckNhbmNlbDogdHJhbnNpdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgZHJvcHBhYmxlJDEgPSB7XG4gICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyb3BwYWJsZS5jb250ZXh0SWQpLFxuICAgIHN0eWxlczoge1xuICAgICAgYWx3YXlzOiBcIm92ZXJmbG93LWFuY2hvcjogbm9uZTtcIlxuICAgIH1cbiAgfTtcbiAgdmFyIGJvZHkgPSB7XG4gICAgc2VsZWN0b3I6ICdib2R5JyxcbiAgICBzdHlsZXM6IHtcbiAgICAgIGRyYWdnaW5nOiBcIlxcbiAgICAgICAgY3Vyc29yOiBncmFiYmluZztcXG4gICAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcXG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICBvdmVyZmxvdy1hbmNob3I6IG5vbmU7XFxuICAgICAgXCJcbiAgICB9XG4gIH07XG4gIHZhciBydWxlcyA9IFtkcmFnZ2FibGUkMSwgZHJhZ0hhbmRsZSQxLCBkcm9wcGFibGUkMSwgYm9keV07XG4gIHJldHVybiB7XG4gICAgYWx3YXlzOiBnZXRTdHlsZXMocnVsZXMsICdhbHdheXMnKSxcbiAgICByZXN0aW5nOiBnZXRTdHlsZXMocnVsZXMsICdyZXN0aW5nJyksXG4gICAgZHJhZ2dpbmc6IGdldFN0eWxlcyhydWxlcywgJ2RyYWdnaW5nJyksXG4gICAgZHJvcEFuaW1hdGluZzogZ2V0U3R5bGVzKHJ1bGVzLCAnZHJvcEFuaW1hdGluZycpLFxuICAgIHVzZXJDYW5jZWw6IGdldFN0eWxlcyhydWxlcywgJ3VzZXJDYW5jZWwnKVxuICB9O1xufSk7XG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxudmFyIGdldEhlYWQgPSBmdW5jdGlvbiBnZXRIZWFkKCkge1xuICB2YXIgaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgIWhlYWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCB0aGUgaGVhZCB0byBhcHBlbmQgYSBzdHlsZSB0bycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGhlYWQ7XG59O1xuXG52YXIgY3JlYXRlU3R5bGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWwobm9uY2UpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBpZiAobm9uY2UpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG5cbiAgZWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIHJldHVybiBlbDtcbn07XG5cbmZ1bmN0aW9uIHVzZVN0eWxlTWFyc2hhbChjb250ZXh0SWQsIG5vbmNlKSB7XG4gIHZhciBzdHlsZXMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0U3R5bGVzJDEoY29udGV4dElkKTtcbiAgfSwgW2NvbnRleHRJZF0pO1xuICB2YXIgYWx3YXlzUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZHluYW1pY1JlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNldER5bmFtaWNTdHlsZSA9IHVzZUNhbGxiYWNrKG1lbW9pemVPbmUoZnVuY3Rpb24gKHByb3Bvc2VkKSB7XG4gICAgdmFyIGVsID0gZHluYW1pY1JlZi5jdXJyZW50O1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzZXQgZHluYW1pYyBzdHlsZSBlbGVtZW50IGlmIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgZWwudGV4dENvbnRlbnQgPSBwcm9wb3NlZDtcbiAgfSksIFtdKTtcbiAgdmFyIHNldEFsd2F5c1N0eWxlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHByb3Bvc2VkKSB7XG4gICAgdmFyIGVsID0gYWx3YXlzUmVmLmN1cnJlbnQ7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNldCBkeW5hbWljIHN0eWxlIGVsZW1lbnQgaWYgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICEoIWFsd2F5c1JlZi5jdXJyZW50ICYmICFkeW5hbWljUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnc3R5bGUgZWxlbWVudHMgYWxyZWFkeSBtb3VudGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBhbHdheXMgPSBjcmVhdGVTdHlsZUVsKG5vbmNlKTtcbiAgICB2YXIgZHluYW1pYyA9IGNyZWF0ZVN0eWxlRWwobm9uY2UpO1xuICAgIGFsd2F5c1JlZi5jdXJyZW50ID0gYWx3YXlzO1xuICAgIGR5bmFtaWNSZWYuY3VycmVudCA9IGR5bmFtaWM7XG4gICAgYWx3YXlzLnNldEF0dHJpYnV0ZShwcmVmaXgkMSArIFwiLWFsd2F5c1wiLCBjb250ZXh0SWQpO1xuICAgIGR5bmFtaWMuc2V0QXR0cmlidXRlKHByZWZpeCQxICsgXCItZHluYW1pY1wiLCBjb250ZXh0SWQpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChhbHdheXMpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChkeW5hbWljKTtcbiAgICBzZXRBbHdheXNTdHlsZShzdHlsZXMuYWx3YXlzKTtcbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHJlZikge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAhY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCB1bm1vdW50IHJlZiBhcyBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICBnZXRIZWFkKCkucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHJlbW92ZShhbHdheXNSZWYpO1xuICAgICAgcmVtb3ZlKGR5bmFtaWNSZWYpO1xuICAgIH07XG4gIH0sIFtub25jZSwgc2V0QWx3YXlzU3R5bGUsIHNldER5bmFtaWNTdHlsZSwgc3R5bGVzLmFsd2F5cywgc3R5bGVzLnJlc3RpbmcsIGNvbnRleHRJZF0pO1xuICB2YXIgZHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldER5bmFtaWNTdHlsZShzdHlsZXMuZHJhZ2dpbmcpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJhZ2dpbmddKTtcbiAgdmFyIGRyb3BwaW5nID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChyZWFzb24gPT09ICdEUk9QJykge1xuICAgICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5kcm9wQW5pbWF0aW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnVzZXJDYW5jZWwpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJvcEFuaW1hdGluZywgc3R5bGVzLnVzZXJDYW5jZWxdKTtcbiAgdmFyIHJlc3RpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkeW5hbWljUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMucmVzdGluZ10pO1xuICB2YXIgbWFyc2hhbCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkcmFnZ2luZzogZHJhZ2dpbmcsXG4gICAgICBkcm9wcGluZzogZHJvcHBpbmcsXG4gICAgICByZXN0aW5nOiByZXN0aW5nXG4gICAgfTtcbiAgfSwgW2RyYWdnaW5nLCBkcm9wcGluZywgcmVzdGluZ10pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxudmFyIGdldFdpbmRvd0Zyb21FbCA9IChmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsICYmIGVsLm93bmVyRG9jdW1lbnQgPyBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufSk7XG5cbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgZ2V0V2luZG93RnJvbUVsKGVsKS5IVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICB2YXIgc2VsZWN0b3IgPSBcIltcIiArIGRyYWdIYW5kbGUuY29udGV4dElkICsgXCI9XFxcIlwiICsgY29udGV4dElkICsgXCJcXFwiXVwiO1xuICB2YXIgcG9zc2libGUgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcblxuICBpZiAoIXBvc3NpYmxlLmxlbmd0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJVbmFibGUgdG8gZmluZCBhbnkgZHJhZyBoYW5kbGVzIGluIHRoZSBjb250ZXh0IFxcXCJcIiArIGNvbnRleHRJZCArIFwiXFxcIlwiKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBoYW5kbGUgPSBmaW5kKHBvc3NpYmxlLCBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG5cbiAgaWYgKCFoYW5kbGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiVW5hYmxlIHRvIGZpbmQgZHJhZyBoYW5kbGUgd2l0aCBpZCBcXFwiXCIgKyBkcmFnZ2FibGVJZCArIFwiXFxcIiBhcyBubyBoYW5kbGUgd2l0aCBhIG1hdGNoaW5nIGlkIHdhcyBmb3VuZFwiKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghaXNIdG1sRWxlbWVudChoYW5kbGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZHJhZyBoYW5kbGUgbmVlZHMgdG8gYmUgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCkge1xuICB2YXIgZW50cmllc1JlZiA9IHVzZVJlZih7fSk7XG4gIHZhciByZWNvcmRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciByZXN0b3JlRm9jdXNGcmFtZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGlzTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciByZWdpc3RlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHJlZ2lzdGVyKGlkLCBmb2N1cykge1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07XG4gICAgZW50cmllc1JlZi5jdXJyZW50W2lkXSA9IGVudHJ5O1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgdmFyIGVudHJpZXMgPSBlbnRyaWVzUmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgY3VycmVudCA9IGVudHJpZXNbaWRdO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gZW50cnkpIHtcbiAgICAgICAgZGVsZXRlIGVudHJpZXNbaWRdO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIHRyeUdpdmVGb2N1cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeUdpdmVGb2N1cyh0cnlHaXZlRm9jdXNUbykge1xuICAgIHZhciBoYW5kbGUgPSBmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIHRyeUdpdmVGb2N1c1RvKTtcblxuICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICBoYW5kbGUuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFtjb250ZXh0SWRdKTtcbiAgdmFyIHRyeVNoaWZ0UmVjb3JkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U2hpZnRSZWNvcmQocHJldmlvdXMsIHJlZGlyZWN0VG8pIHtcbiAgICBpZiAocmVjb3JkUmVmLmN1cnJlbnQgPT09IHByZXZpb3VzKSB7XG4gICAgICByZWNvcmRSZWYuY3VycmVudCA9IHJlZGlyZWN0VG87XG4gICAgfVxuICB9LCBbXSk7XG4gIHZhciB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCkge1xuICAgIGlmIChyZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB2YXIgcmVjb3JkID0gcmVjb3JkUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgdHJ5R2l2ZUZvY3VzKHJlY29yZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFt0cnlHaXZlRm9jdXNdKTtcbiAgdmFyIHRyeVJlY29yZEZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVjb3JkRm9jdXMoaWQpIHtcbiAgICByZWNvcmRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZvY3VzZWQuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpICE9PSBpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlY29yZFJlZi5jdXJyZW50ID0gaWQ7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhckZyYW1lT25Vbm1vdW50KCkge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBmcmFtZUlkID0gcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudDtcblxuICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB2YXIgbWFyc2hhbCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlcjogcmVnaXN0ZXIsXG4gICAgICB0cnlSZWNvcmRGb2N1czogdHJ5UmVjb3JkRm9jdXMsXG4gICAgICB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZDogdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQsXG4gICAgICB0cnlTaGlmdFJlY29yZDogdHJ5U2hpZnRSZWNvcmRcbiAgICB9O1xuICB9LCBbcmVnaXN0ZXIsIHRyeVJlY29yZEZvY3VzLCB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCwgdHJ5U2hpZnRSZWNvcmRdKTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lzdHJ5KCkge1xuICB2YXIgZW50cmllcyA9IHtcbiAgICBkcmFnZ2FibGVzOiB7fSxcbiAgICBkcm9wcGFibGVzOiB7fVxuICB9O1xuICB2YXIgc3Vic2NyaWJlcnMgPSBbXTtcblxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2IpIHtcbiAgICBzdWJzY3JpYmVycy5wdXNoKGNiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICB2YXIgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNiKTtcblxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGgpIHtcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRHJhZ2dhYmxlQnlJZChpZCkge1xuICAgIHJldHVybiBlbnRyaWVzLmRyYWdnYWJsZXNbaWRdIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREcmFnZ2FibGVCeUlkKGlkKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZERyYWdnYWJsZUJ5SWQoaWQpO1xuICAgICFlbnRyeSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgZmluZCBkcmFnZ2FibGUgZW50cnkgd2l0aCBpZCBbXCIgKyBpZCArIFwiXVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgdmFyIGRyYWdnYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZW50cnkpIHtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgICAgbm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ0FERElUSU9OJyxcbiAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGVudHJ5LCBsYXN0KSB7XG4gICAgICB2YXIgY3VycmVudCA9IGVudHJpZXMuZHJhZ2dhYmxlc1tsYXN0LmRlc2NyaXB0b3IuaWRdO1xuXG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudC51bmlxdWVJZCAhPT0gZW50cnkudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZW50cmllcy5kcmFnZ2FibGVzW2xhc3QuZGVzY3JpcHRvci5pZF07XG4gICAgICBlbnRyaWVzLmRyYWdnYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICB9LFxuICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXIoZW50cnkpIHtcbiAgICAgIHZhciBkcmFnZ2FibGVJZCA9IGVudHJ5LmRlc2NyaXB0b3IuaWQ7XG4gICAgICB2YXIgY3VycmVudCA9IGZpbmREcmFnZ2FibGVCeUlkKGRyYWdnYWJsZUlkKTtcblxuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5LnVuaXF1ZUlkICE9PSBjdXJyZW50LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJhZ2dhYmxlc1tkcmFnZ2FibGVJZF07XG4gICAgICBub3RpZnkoe1xuICAgICAgICB0eXBlOiAnUkVNT1ZBTCcsXG4gICAgICAgIHZhbHVlOiBlbnRyeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcmFnZ2FibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJhZ2dhYmxlQnlJZCxcbiAgICBleGlzdHM6IGZ1bmN0aW9uIGV4aXN0cyhpZCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZmluZERyYWdnYWJsZUJ5SWQoaWQpKTtcbiAgICB9LFxuICAgIGdldEFsbEJ5VHlwZTogZnVuY3Rpb24gZ2V0QWxsQnlUeXBlKHR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMoZW50cmllcy5kcmFnZ2FibGVzKS5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZERyb3BwYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcm9wcGFibGVzW2lkXSB8fCBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RHJvcHBhYmxlQnlJZChpZCkge1xuICAgIHZhciBlbnRyeSA9IGZpbmREcm9wcGFibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IGZpbmQgZHJvcHBhYmxlIGVudHJ5IHdpdGggaWQgW1wiICsgaWQgKyBcIl1cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuXG4gIHZhciBkcm9wcGFibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGVudHJ5KSB7XG4gICAgICBlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICB9LFxuICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXIoZW50cnkpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gZmluZERyb3BwYWJsZUJ5SWQoZW50cnkuZGVzY3JpcHRvci5pZCk7XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF07XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcm9wcGFibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJvcHBhYmxlQnlJZCxcbiAgICBleGlzdHM6IGZ1bmN0aW9uIGV4aXN0cyhpZCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZmluZERyb3BwYWJsZUJ5SWQoaWQpKTtcbiAgICB9LFxuICAgIGdldEFsbEJ5VHlwZTogZnVuY3Rpb24gZ2V0QWxsQnlUeXBlKHR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMoZW50cmllcy5kcm9wcGFibGVzKS5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgZW50cmllcy5kcmFnZ2FibGVzID0ge307XG4gICAgZW50cmllcy5kcm9wcGFibGVzID0ge307XG4gICAgc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGVBUEksXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGVBUEksXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgY2xlYW46IGNsZWFuXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdHJ5KCkge1xuICB2YXIgcmVnaXN0cnkgPSB1c2VNZW1vKGNyZWF0ZVJlZ2lzdHJ5LCBbXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVnaXN0cnkuY2xlYW4pO1xuICAgIH07XG4gIH0sIFtyZWdpc3RyeV0pO1xuICByZXR1cm4gcmVnaXN0cnk7XG59XG5cbnZhciBTdG9yZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG52YXIgZ2V0Qm9keUVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICFib2R5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgZG9jdW1lbnQuYm9keScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGJvZHk7XG59KTtcblxudmFyIHZpc3VhbGx5SGlkZGVuID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgd2lkdGg6ICcxcHgnLFxuICBoZWlnaHQ6ICcxcHgnLFxuICBtYXJnaW46ICctMXB4JyxcbiAgYm9yZGVyOiAnMCcsXG4gIHBhZGRpbmc6ICcwJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICdjbGlwLXBhdGgnOiAnaW5zZXQoMTAwJSknXG59O1xuXG52YXIgZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZChjb250ZXh0SWQpIHtcbiAgcmV0dXJuIFwicmJkLWFubm91bmNlbWVudC1cIiArIGNvbnRleHRJZDtcbn07XG5mdW5jdGlvbiB1c2VBbm5vdW5jZXIoY29udGV4dElkKSB7XG4gIHZhciBpZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRJZChjb250ZXh0SWQpO1xuICB9LCBbY29udGV4dElkXSk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWF0b21pYycsICd0cnVlJyk7XG5cbiAgICBfZXh0ZW5kcyhlbC5zdHlsZSwgdmlzdWFsbHlIaWRkZW4pO1xuXG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuXG4gICAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsID09PSByZWYuY3VycmVudCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2lkXSk7XG4gIHZhciBhbm5vdW5jZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdmFyIGVsID0gcmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgQSBzY3JlZW4gcmVhZGVyIG1lc3NhZ2Ugd2FzIHRyeWluZyB0byBiZSBhbm5vdW5jZWQgYnV0IGl0IHdhcyB1bmFibGUgdG8gZG8gc28uXFxuICAgICAgVGhpcyBjYW4gb2NjdXIgaWYgeW91IHVubW91bnQgeW91ciA8RHJhZ0Ryb3BDb250ZXh0IC8+IGluIHlvdXIgb25EcmFnRW5kLlxcbiAgICAgIENvbnNpZGVyIGNhbGxpbmcgcHJvdmlkZWQuYW5ub3VuY2UoKSBiZWZvcmUgdGhlIHVubW91bnQgc28gdGhhdCB0aGUgaW5zdHJ1Y3Rpb24gd2lsbFxcbiAgICAgIG5vdCBiZSBsb3N0IGZvciB1c2VycyByZWx5aW5nIG9uIGEgc2NyZWVuIHJlYWRlci5cXG5cXG4gICAgICBNZXNzYWdlIG5vdCBwYXNzZWQgdG8gc2NyZWVuIHJlYWRlcjpcXG5cXG4gICAgICBcXFwiXCIgKyBtZXNzYWdlICsgXCJcXFwiXFxuICAgIFwiKSA6IHZvaWQgMDtcbiAgfSwgW10pO1xuICByZXR1cm4gYW5ub3VuY2U7XG59XG5cbnZhciBjb3VudCA9IDA7XG52YXIgZGVmYXVsdHMgPSB7XG4gIHNlcGFyYXRvcjogJzo6J1xufTtcbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb3VudCA9IDA7XG59XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChwcmVmaXgsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cztcbiAgfVxuXG4gIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIG9wdGlvbnMuc2VwYXJhdG9yICsgY291bnQrKztcbiAgfSwgW29wdGlvbnMuc2VwYXJhdG9yLCBwcmVmaXhdKTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudElkKF9yZWYpIHtcbiAgdmFyIGNvbnRleHRJZCA9IF9yZWYuY29udGV4dElkLFxuICAgICAgdW5pcXVlSWQgPSBfcmVmLnVuaXF1ZUlkO1xuICByZXR1cm4gXCJyYmQtaGlkZGVuLXRleHQtXCIgKyBjb250ZXh0SWQgKyBcIi1cIiArIHVuaXF1ZUlkO1xufVxuZnVuY3Rpb24gdXNlSGlkZGVuVGV4dEVsZW1lbnQoX3JlZjIpIHtcbiAgdmFyIGNvbnRleHRJZCA9IF9yZWYyLmNvbnRleHRJZCxcbiAgICAgIHRleHQgPSBfcmVmMi50ZXh0O1xuICB2YXIgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCgnaGlkZGVuLXRleHQnLCB7XG4gICAgc2VwYXJhdG9yOiAnLSdcbiAgfSk7XG4gIHZhciBpZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50SWQoe1xuICAgICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgICB1bmlxdWVJZDogdW5pcXVlSWRcbiAgICB9KTtcbiAgfSwgW3VuaXF1ZUlkLCBjb250ZXh0SWRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB2YXIgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG5cbiAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaWQsIHRleHRdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG52YXIgQXBwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBwZWVyRGVwZW5kZW5jaWVzID0ge1xuXHRyZWFjdDogXCJeMTYuOC41XCIsXG5cdFwicmVhY3QtZG9tXCI6IFwiXjE2LjguNVwiXG59O1xuXG52YXIgc2VtdmVyID0gLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKS87XG5cbnZhciBnZXRWZXJzaW9uID0gZnVuY3Rpb24gZ2V0VmVyc2lvbih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gc2VtdmVyLmV4ZWModmFsdWUpO1xuICAhKHJlc3VsdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJVbmFibGUgdG8gcGFyc2UgUmVhY3QgdmVyc2lvbiBcIiArIHZhbHVlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBtYWpvciA9IE51bWJlcihyZXN1bHRbMV0pO1xuICB2YXIgbWlub3IgPSBOdW1iZXIocmVzdWx0WzJdKTtcbiAgdmFyIHBhdGNoID0gTnVtYmVyKHJlc3VsdFszXSk7XG4gIHJldHVybiB7XG4gICAgbWFqb3I6IG1ham9yLFxuICAgIG1pbm9yOiBtaW5vcixcbiAgICBwYXRjaDogcGF0Y2gsXG4gICAgcmF3OiB2YWx1ZVxuICB9O1xufTtcblxudmFyIGlzU2F0aXNmaWVkID0gZnVuY3Rpb24gaXNTYXRpc2ZpZWQoZXhwZWN0ZWQsIGFjdHVhbCkge1xuICBpZiAoYWN0dWFsLm1ham9yID4gZXhwZWN0ZWQubWFqb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhY3R1YWwubWFqb3IgPCBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhY3R1YWwubWlub3IgPiBleHBlY3RlZC5taW5vcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFjdHVhbC5taW5vciA8IGV4cGVjdGVkLm1pbm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGFjdHVhbC5wYXRjaCA+PSBleHBlY3RlZC5wYXRjaDtcbn07XG5cbnZhciBjaGVja1JlYWN0VmVyc2lvbiA9IChmdW5jdGlvbiAocGVlckRlcFZhbHVlLCBhY3R1YWxWYWx1ZSkge1xuICB2YXIgcGVlckRlcCA9IGdldFZlcnNpb24ocGVlckRlcFZhbHVlKTtcbiAgdmFyIGFjdHVhbCA9IGdldFZlcnNpb24oYWN0dWFsVmFsdWUpO1xuXG4gIGlmIChpc1NhdGlzZmllZChwZWVyRGVwLCBhY3R1YWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICBSZWFjdCB2ZXJzaW9uOiBbXCIgKyBhY3R1YWwucmF3ICsgXCJdXFxuICAgIGRvZXMgbm90IHNhdGlzZnkgZXhwZWN0ZWQgcGVlciBkZXBlbmRlbmN5IHZlcnNpb246IFtcIiArIHBlZXJEZXAucmF3ICsgXCJdXFxuXFxuICAgIFRoaXMgY2FuIHJlc3VsdCBpbiBydW4gdGltZSBidWdzLCBhbmQgZXZlbiBmYXRhbCBjcmFzaGVzXFxuICBcIikgOiB2b2lkIDA7XG59KTtcblxudmFyIHN1ZmZpeCA9IFwiXFxuICBXZSBleHBlY3QgYSBodG1sNSBkb2N0eXBlOiA8IWRvY3R5cGUgaHRtbD5cXG4gIFRoaXMgaXMgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYnJvd3NlciBsYXlvdXQgYW5kIG1lYXN1cmVtZW50XFxuXFxuICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvYmxvYi9tYXN0ZXIvZG9jcy9ndWlkZXMvZG9jdHlwZS5tZFxcblwiO1xudmFyIGNoZWNrRG9jdHlwZSA9IChmdW5jdGlvbiAoZG9jKSB7XG4gIHZhciBkb2N0eXBlID0gZG9jLmRvY3R5cGU7XG5cbiAgaWYgKCFkb2N0eXBlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgIE5vIDwhZG9jdHlwZSBodG1sPiBmb3VuZC5cXG5cXG4gICAgICBcIiArIHN1ZmZpeCArIFwiXFxuICAgIFwiKSA6IHZvaWQgMDtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZG9jdHlwZS5uYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICBVbmV4cGVjdGVkIDwhZG9jdHlwZT4gZm91bmQ6IChcIiArIGRvY3R5cGUubmFtZSArIFwiKVxcblxcbiAgICAgIFwiICsgc3VmZml4ICsgXCJcXG4gICAgXCIpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKGRvY3R5cGUucHVibGljSWQgIT09ICcnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgIFVuZXhwZWN0ZWQgPCFkb2N0eXBlPiBwdWJsaWNJZCBmb3VuZDogKFwiICsgZG9jdHlwZS5wdWJsaWNJZCArIFwiKVxcbiAgICAgIEEgaHRtbDUgZG9jdHlwZSBkb2VzIG5vdCBoYXZlIGEgcHVibGljSWRcXG5cXG4gICAgICBcIiArIHN1ZmZpeCArIFwiXFxuICAgIFwiKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVzZURldih1c2VIb29rKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdXNlSG9vaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZURldlNldHVwV2FybmluZyhmbiwgaW5wdXRzKSB7XG4gIHVzZURldihmdW5jdGlvbiAoKSB7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKFwiXFxuICAgICAgICAgIEEgc2V0dXAgcHJvYmxlbSB3YXMgZW5jb3VudGVyZWQuXFxuXFxuICAgICAgICAgID4gXCIgKyBlLm1lc3NhZ2UgKyBcIlxcbiAgICAgICAgXCIpO1xuICAgICAgfVxuICAgIH0sIGlucHV0cyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VTdGFydHVwVmFsaWRhdGlvbigpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKGZ1bmN0aW9uICgpIHtcbiAgICBjaGVja1JlYWN0VmVyc2lvbihwZWVyRGVwZW5kZW5jaWVzLnJlYWN0LCBSZWFjdC52ZXJzaW9uKTtcbiAgICBjaGVja0RvY3R5cGUoZG9jdW1lbnQpO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKGN1cnJlbnQpIHtcbiAgdmFyIHJlZiA9IHVzZVJlZihjdXJyZW50KTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBsb2NrID0gbnVsbDtcblxuICBmdW5jdGlvbiBpc0NsYWltZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obG9jayk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FjdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbG9jaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYWltKGFiYW5kb24pIHtcbiAgICAhIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY2xhaW0gbG9jayBhcyBpdCBpcyBhbHJlYWR5IGNsYWltZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5ld0xvY2sgPSB7XG4gICAgICBhYmFuZG9uOiBhYmFuZG9uXG4gICAgfTtcbiAgICBsb2NrID0gbmV3TG9jaztcbiAgICByZXR1cm4gbmV3TG9jaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVsZWFzZSBsb2NrIHdoZW4gdGhlcmUgaXMgbm8gbG9jaycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsb2NrID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUFiYW5kb24oKSB7XG4gICAgaWYgKGxvY2spIHtcbiAgICAgIGxvY2suYWJhbmRvbigpO1xuICAgICAgcmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNDbGFpbWVkOiBpc0NsYWltZWQsXG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxuICAgIGNsYWltOiBjbGFpbSxcbiAgICByZWxlYXNlOiByZWxlYXNlLFxuICAgIHRyeUFiYW5kb246IHRyeUFiYW5kb25cbiAgfTtcbn1cblxudmFyIHRhYiA9IDk7XG52YXIgZW50ZXIgPSAxMztcbnZhciBlc2NhcGUgPSAyNztcbnZhciBzcGFjZSA9IDMyO1xudmFyIHBhZ2VVcCA9IDMzO1xudmFyIHBhZ2VEb3duID0gMzQ7XG52YXIgZW5kID0gMzU7XG52YXIgaG9tZSA9IDM2O1xudmFyIGFycm93TGVmdCA9IDM3O1xudmFyIGFycm93VXAgPSAzODtcbnZhciBhcnJvd1JpZ2h0ID0gMzk7XG52YXIgYXJyb3dEb3duID0gNDA7XG5cbnZhciBfcHJldmVudGVkS2V5cztcbnZhciBwcmV2ZW50ZWRLZXlzID0gKF9wcmV2ZW50ZWRLZXlzID0ge30sIF9wcmV2ZW50ZWRLZXlzW2VudGVyXSA9IHRydWUsIF9wcmV2ZW50ZWRLZXlzW3RhYl0gPSB0cnVlLCBfcHJldmVudGVkS2V5cyk7XG52YXIgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzID0gKGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAocHJldmVudGVkS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn0pO1xuXG52YXIgc3VwcG9ydGVkRXZlbnROYW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYmFzZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBbYmFzZSwgXCJtc1wiICsgYmFzZSwgXCJ3ZWJraXRcIiArIGJhc2UsIFwibW96XCIgKyBiYXNlLCBcIm9cIiArIGJhc2VdO1xuICB2YXIgc3VwcG9ydGVkID0gZmluZChjYW5kaWRhdGVzLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIFwib25cIiArIGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcbiAgfSk7XG4gIHJldHVybiBzdXBwb3J0ZWQgfHwgYmFzZTtcbn0oKTtcblxudmFyIHByaW1hcnlCdXR0b24gPSAwO1xudmFyIHNsb3BweUNsaWNrVGhyZXNob2xkID0gNTtcblxuZnVuY3Rpb24gaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkKG9yaWdpbmFsLCBjdXJyZW50KSB7XG4gIHJldHVybiBNYXRoLmFicyhjdXJyZW50LnggLSBvcmlnaW5hbC54KSA+PSBzbG9wcHlDbGlja1RocmVzaG9sZCB8fCBNYXRoLmFicyhjdXJyZW50LnkgLSBvcmlnaW5hbC55KSA+PSBzbG9wcHlDbGlja1RocmVzaG9sZDtcbn1cblxudmFyIGlkbGUkMSA9IHtcbiAgdHlwZTogJ0lETEUnXG59O1xuXG5mdW5jdGlvbiBnZXRDYXB0dXJlQmluZGluZ3MoX3JlZikge1xuICB2YXIgY2FuY2VsID0gX3JlZi5jYW5jZWwsXG4gICAgICBjb21wbGV0ZWQgPSBfcmVmLmNvbXBsZXRlZCxcbiAgICAgIGdldFBoYXNlID0gX3JlZi5nZXRQaGFzZSxcbiAgICAgIHNldFBoYXNlID0gX3JlZi5zZXRQaGFzZTtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vtb3ZlJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b24sXG4gICAgICAgICAgY2xpZW50WCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICAgIGlmIChidXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICB2YXIgcGhhc2UgPSBnZXRQaGFzZSgpO1xuXG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwaGFzZS5hY3Rpb25zLm1vdmUocG9pbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICEocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBiZSBJRExFJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIHBlbmRpbmcgPSBwaGFzZS5wb2ludDtcblxuICAgICAgaWYgKCFpc1Nsb3BweUNsaWNrVGhyZXNob2xkRXhjZWVkZWQocGVuZGluZywgcG9pbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBhY3Rpb25zID0gcGhhc2UuYWN0aW9ucy5mbHVpZExpZnQocG9pbnQpO1xuICAgICAgc2V0UGhhc2Uoe1xuICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICBhY3Rpb25zOiBhY3Rpb25zXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZXVwJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG5cbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwaGFzZS5hY3Rpb25zLmRyb3Aoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG5cbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiBmdW5jdGlvbiBmbigpIHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd3ZWJraXRtb3VzZWZvcmNlZG93bicsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICB2YXIgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgIShwaGFzZS50eXBlICE9PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBwaGFzZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSkge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5cbmZ1bmN0aW9uIHVzZU1vdXNlU2Vuc29yKGFwaSkge1xuICB2YXIgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSQxKTtcbiAgdmFyIHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wKTtcbiAgdmFyIHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICAgIGZuOiBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcblxuICAgICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgIH07XG4gICAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICAgIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFthcGldKTtcbiAgdmFyIHByZXZlbnRGb3JjZVByZXNzQmluZGluZyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBldmVudE5hbWU6ICd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJyxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcGkuZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUoaWQpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhcGkuY2FuR2V0TG9jayhpZCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFthcGldKTtcbiAgdmFyIGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nLCBzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgdmFyIHN0b3AgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBwaGFzZVJlZi5jdXJyZW50O1xuXG4gICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGhhc2VSZWYuY3VycmVudCA9IGlkbGUkMTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbiAgdmFyIGNhbmNlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGhhc2UgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIHN0b3AoKTtcblxuICAgIGlmIChwaGFzZS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmNhbmNlbCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICB2YXIgYmluZENhcHR1cmluZ0V2ZW50cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGJpbmRDYXB0dXJpbmdFdmVudHMoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIHZhciBiaW5kaW5ncyA9IGdldENhcHR1cmVCaW5kaW5ncyh7XG4gICAgICBjYW5jZWw6IGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlOiBmdW5jdGlvbiBnZXRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgICB9LFxuICAgICAgc2V0UGhhc2U6IGZ1bmN0aW9uIHNldFBoYXNlKHBoYXNlKSB7XG4gICAgICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBwaGFzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBiaW5kaW5ncywgb3B0aW9ucyk7XG4gIH0sIFtjYW5jZWwsIHN0b3BdKTtcbiAgdmFyIHN0YXJ0UGVuZGluZ0RyYWcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KSB7XG4gICAgIShwaGFzZVJlZi5jdXJyZW50LnR5cGUgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBtb3ZlIGZyb20gSURMRSB0byBQRU5ESU5HIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IHtcbiAgICAgIHR5cGU6ICdQRU5ESU5HJyxcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGFjdGlvbnM6IGFjdGlvbnNcbiAgICB9O1xuICAgIGJpbmRDYXB0dXJpbmdFdmVudHMoKTtcbiAgfSwgW2JpbmRDYXB0dXJpbmdFdmVudHNdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG59XG5cbnZhciBfc2Nyb2xsSnVtcEtleXM7XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbnZhciBzY3JvbGxKdW1wS2V5cyA9IChfc2Nyb2xsSnVtcEtleXMgPSB7fSwgX3Njcm9sbEp1bXBLZXlzW3BhZ2VEb3duXSA9IHRydWUsIF9zY3JvbGxKdW1wS2V5c1twYWdlVXBdID0gdHJ1ZSwgX3Njcm9sbEp1bXBLZXlzW2hvbWVdID0gdHJ1ZSwgX3Njcm9sbEp1bXBLZXlzW2VuZF0gPSB0cnVlLCBfc2Nyb2xsSnVtcEtleXMpO1xuXG5mdW5jdGlvbiBnZXREcmFnZ2luZ0JpbmRpbmdzKGFjdGlvbnMsIHN0b3ApIHtcbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHN0b3AoKTtcbiAgICBhY3Rpb25zLmNhbmNlbCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZHJvcCgpIHtcbiAgICBzdG9wKCk7XG4gICAgYWN0aW9ucy5kcm9wKCk7XG4gIH1cblxuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IHNwYWNlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRyb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dEb3duKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZURvd24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dVcCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVVcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd1JpZ2h0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZVJpZ2h0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93TGVmdCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVMZWZ0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcm9sbEp1bXBLZXlzW2V2ZW50LmtleUNvZGVdKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzKGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNldXAnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2NsaWNrJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaHN0YXJ0JyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3doZWVsJyxcbiAgICBmbjogY2FuY2VsLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuXG5mdW5jdGlvbiB1c2VLZXlib2FyZFNlbnNvcihhcGkpIHtcbiAgdmFyIHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDEpO1xuICB2YXIgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICAgIGZuOiBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPT0gc3BhY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG5cbiAgICAgICAgaWYgKCFkcmFnZ2FibGVJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVEcmFnID0gYXBpLnRyeUdldExvY2soZHJhZ2dhYmxlSWQsIHN0b3AsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFwcmVEcmFnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGlzQ2FwdHVyaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBwcmVEcmFnLnNuYXBMaWZ0KCk7XG4gICAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAhaXNDYXB0dXJpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBjYXB0dXJpbmcgYSBrZXlib2FyZCBkcmFnIHdoZW4gbm90IGNhcHR1cmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgICBpc0NhcHR1cmluZyA9IGZhbHNlO1xuICAgICAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICAgICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0RHJhZ2dpbmdCaW5kaW5ncyhhY3Rpb25zLCBzdG9wKSwge1xuICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FwaV0pO1xuICB2YXIgbGlzdGVuRm9yQ2FwdHVyZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVN0YXJ0Q2FwdHVyZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH07XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3N0YXJ0Q2FwdHVyZUJpbmRpbmddLCBvcHRpb25zKTtcbiAgfSwgW3N0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG59XG5cbnZhciBpZGxlJDIgPSB7XG4gIHR5cGU6ICdJRExFJ1xufTtcbnZhciB0aW1lRm9yTG9uZ1ByZXNzID0gMTIwO1xudmFyIGZvcmNlUHJlc3NUaHJlc2hvbGQgPSAwLjE1O1xuXG5mdW5jdGlvbiBnZXRXaW5kb3dCaW5kaW5ncyhfcmVmKSB7XG4gIHZhciBjYW5jZWwgPSBfcmVmLmNhbmNlbCxcbiAgICAgIGdldFBoYXNlID0gX3JlZi5nZXRQaGFzZTtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAnb3JpZW50YXRpb25jaGFuZ2UnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnY29udGV4dG1lbnUnLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuXG5mdW5jdGlvbiBnZXRIYW5kbGVCaW5kaW5ncyhfcmVmMikge1xuICB2YXIgY2FuY2VsID0gX3JlZjIuY2FuY2VsLFxuICAgICAgY29tcGxldGVkID0gX3JlZjIuY29tcGxldGVkLFxuICAgICAgZ2V0UGhhc2UgPSBfcmVmMi5nZXRQaGFzZTtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICB2YXIgcGhhc2UgPSBnZXRQaGFzZSgpO1xuXG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwaGFzZS5oYXNNb3ZlZCA9IHRydWU7XG4gICAgICB2YXIgX2V2ZW50JHRvdWNoZXMkID0gZXZlbnQudG91Y2hlc1swXSxcbiAgICAgICAgICBjbGllbnRYID0gX2V2ZW50JHRvdWNoZXMkLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9ldmVudCR0b3VjaGVzJC5jbGllbnRZO1xuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMubW92ZShwb2ludCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hlbmQnLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcblxuICAgICAgaWYgKHBoYXNlLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoY2FuY2VsJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoZm9yY2VjaGFuZ2UnLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgICEocGhhc2UudHlwZSAhPT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcblxuICAgICAgaWYgKCF0b3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0ZvcmNlUHJlc3MgPSB0b3VjaC5mb3JjZSA+PSBmb3JjZVByZXNzVGhyZXNob2xkO1xuXG4gICAgICBpZiAoIWlzRm9yY2VQcmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG91bGRSZXNwZWN0ID0gcGhhc2UuYWN0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpO1xuXG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGlmIChzaG91bGRSZXNwZWN0KSB7XG4gICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRSZXNwZWN0KSB7XG4gICAgICAgIGlmIChwaGFzZS5oYXNNb3ZlZCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuXG5mdW5jdGlvbiB1c2VNb3VzZVNlbnNvciQxKGFwaSkge1xuICB2YXIgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSQyKTtcbiAgdmFyIHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wKTtcbiAgdmFyIGdldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gZ2V0UGhhc2UoKSB7XG4gICAgcmV0dXJuIHBoYXNlUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdmFyIHNldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc2V0UGhhc2UocGhhc2UpIHtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7XG4gIH0sIFtdKTtcbiAgdmFyIHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgICBmbjogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdnYWJsZUlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuXG4gICAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghYWN0aW9ucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgIHZhciBjbGllbnRYID0gdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgICB5OiBjbGllbnRZXG4gICAgICAgIH07XG4gICAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICAgIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFthcGldKTtcbiAgdmFyIGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICB2YXIgc3RvcCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHBoYXNlUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIGNsZWFyVGltZW91dChjdXJyZW50LmxvbmdQcmVzc1RpbWVySWQpO1xuICAgIH1cblxuICAgIHNldFBoYXNlKGlkbGUkMik7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlLCBzZXRQaGFzZV0pO1xuICB2YXIgY2FuY2VsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwaGFzZSA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgc3RvcCgpO1xuXG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuYWJvcnQoKTtcbiAgICB9XG4gIH0sIFtzdG9wXSk7XG4gIHZhciBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGFyZ3MgPSB7XG4gICAgICBjYW5jZWw6IGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlOiBnZXRQaGFzZVxuICAgIH07XG4gICAgdmFyIHVuYmluZFRhcmdldCA9IGJpbmRFdmVudHMod2luZG93LCBnZXRIYW5kbGVCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgdmFyIHVuYmluZFdpbmRvdyA9IGJpbmRFdmVudHMod2luZG93LCBnZXRXaW5kb3dCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG5cbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICAgIHVuYmluZFRhcmdldCgpO1xuICAgICAgdW5iaW5kV2luZG93KCk7XG4gICAgfTtcbiAgfSwgW2NhbmNlbCwgZ2V0UGhhc2UsIHN0b3BdKTtcbiAgdmFyIHN0YXJ0RHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydERyYWdnaW5nKCkge1xuICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgIShwaGFzZS50eXBlID09PSAnUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBzdGFydCBkcmFnZ2luZyBmcm9tIHBoYXNlIFwiICsgcGhhc2UudHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb25zID0gcGhhc2UuYWN0aW9ucy5mbHVpZExpZnQocGhhc2UucG9pbnQpO1xuICAgIHNldFBoYXNlKHtcbiAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgICAgaGFzTW92ZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sIFtnZXRQaGFzZSwgc2V0UGhhc2VdKTtcbiAgdmFyIHN0YXJ0UGVuZGluZ0RyYWcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KSB7XG4gICAgIShnZXRQaGFzZSgpLnR5cGUgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBtb3ZlIGZyb20gSURMRSB0byBQRU5ESU5HIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGxvbmdQcmVzc1RpbWVySWQgPSBzZXRUaW1lb3V0KHN0YXJ0RHJhZ2dpbmcsIHRpbWVGb3JMb25nUHJlc3MpO1xuICAgIHNldFBoYXNlKHtcbiAgICAgIHR5cGU6ICdQRU5ESU5HJyxcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICBsb25nUHJlc3NUaW1lcklkOiBsb25nUHJlc3NUaW1lcklkXG4gICAgfSk7XG4gICAgYmluZENhcHR1cmluZ0V2ZW50cygpO1xuICB9LCBbYmluZENhcHR1cmluZ0V2ZW50cywgZ2V0UGhhc2UsIHNldFBoYXNlLCBzdGFydERyYWdnaW5nXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG5cbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBoYXNlLmxvbmdQcmVzc1RpbWVySWQpO1xuICAgICAgICBzZXRQaGFzZShpZGxlJDIpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtnZXRQaGFzZSwgbGlzdGVuRm9yQ2FwdHVyZSwgc2V0UGhhc2VdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiB3ZWJraXRIYWNrKCkge1xuICAgIHZhciB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiB1bmJpbmQ7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGVTZW5zb3JIb29rcyhzZW5zb3JIb29rcykge1xuICB1c2VEZXYoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKHNlbnNvckhvb2tzKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoZnVuY3Rpb24gKCkge1xuICAgICAgIShwcmV2aW91c1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gc2Vuc29ySG9va3MubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjaGFuZ2UgdGhlIGFtb3VudCBvZiBzZW5zb3IgaG9va3MgYWZ0ZXIgbW91bnRpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfSk7XG4gIH0pO1xufVxuXG52YXIgaW50ZXJhY3RpdmVUYWdOYW1lcyA9IHtcbiAgaW5wdXQ6IHRydWUsXG4gIGJ1dHRvbjogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWUsXG4gIHNlbGVjdDogdHJ1ZSxcbiAgb3B0aW9uOiB0cnVlLFxuICBvcHRncm91cDogdHJ1ZSxcbiAgdmlkZW86IHRydWUsXG4gIGF1ZGlvOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudCkge1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhhc0FuSW50ZXJhY3RpdmVUYWcgPSBCb29sZWFuKGludGVyYWN0aXZlVGFnTmFtZXNbY3VycmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCldKTtcblxuICBpZiAoaGFzQW5JbnRlcmFjdGl2ZVRhZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGF0dHJpYnV0ZSA9IGN1cnJlbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcblxuICBpZiAoYXR0cmlidXRlID09PSAndHJ1ZScgfHwgYXR0cmlidXRlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgPT09IHBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudC5wYXJlbnRFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICBpZiAoIWlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgdGFyZ2V0KTtcbn1cblxudmFyIGdldEJvcmRlckJveENlbnRlclBvc2l0aW9uID0gKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZ2V0UmVjdChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkuY2VudGVyO1xufSk7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChlbCkge1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBnZXRXaW5kb3dGcm9tRWwoZWwpLkVsZW1lbnQ7XG59XG5cbnZhciBzdXBwb3J0ZWRNYXRjaGVzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhc2UgPSAnbWF0Y2hlcyc7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVzID0gW2Jhc2UsICdtc01hdGNoZXNTZWxlY3RvcicsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InXTtcbiAgdmFyIHZhbHVlID0gZmluZChjYW5kaWRhdGVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIEVsZW1lbnQucHJvdG90eXBlO1xuICB9KTtcbiAgcmV0dXJuIHZhbHVlIHx8IGJhc2U7XG59KCk7XG5cbmZ1bmN0aW9uIGNsb3Nlc3RQb255ZmlsbChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChlbFtzdXBwb3J0ZWRNYXRjaGVzTmFtZV0oc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3RQb255ZmlsbChlbC5wYXJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGNsb3Nlc3QkMShlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbnRleHRJZCkge1xuICByZXR1cm4gXCJbXCIgKyBkcmFnSGFuZGxlLmNvbnRleHRJZCArIFwiPVxcXCJcIiArIGNvbnRleHRJZCArIFwiXFxcIl1cIjtcbn1cblxuZnVuY3Rpb24gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZXZlbnQudGFyZ2V0IG11c3QgYmUgYSBFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuICB2YXIgaGFuZGxlID0gY2xvc2VzdCQxKHRhcmdldCwgc2VsZWN0b3IpO1xuXG4gIGlmICghaGFuZGxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWlzSHRtbEVsZW1lbnQoaGFuZGxlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2RyYWcgaGFuZGxlIG11c3QgYmUgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gdHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgdmFyIGhhbmRsZSA9IGZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KTtcblxuICBpZiAoIWhhbmRsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZS5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCk7XG59XG5cbmZ1bmN0aW9uIGZpbmREcmFnZ2FibGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICB2YXIgc2VsZWN0b3IgPSBcIltcIiArIGRyYWdnYWJsZS5jb250ZXh0SWQgKyBcIj1cXFwiXCIgKyBjb250ZXh0SWQgKyBcIlxcXCJdXCI7XG4gIHZhciBwb3NzaWJsZSA9IHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICB2YXIgZHJhZ2dhYmxlJDEgPSBmaW5kKHBvc3NpYmxlLCBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdnYWJsZS5pZCkgPT09IGRyYWdnYWJsZUlkO1xuICB9KTtcblxuICBpZiAoIWRyYWdnYWJsZSQxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWlzSHRtbEVsZW1lbnQoZHJhZ2dhYmxlJDEpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnRHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBkcmFnZ2FibGUkMTtcbn1cblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gX2lzQWN0aXZlKF9yZWYpIHtcbiAgdmFyIGV4cGVjdGVkID0gX3JlZi5leHBlY3RlZCxcbiAgICAgIHBoYXNlID0gX3JlZi5waGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSA9IF9yZWYuaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybiA9IF9yZWYuc2hvdWxkV2FybjtcblxuICBpZiAoIWlzTG9ja0FjdGl2ZSgpKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cXG4gICAgICAgIFRoZSBzZW5zb3Igbm8gbG9uZ2VyIGhhcyBhbiBhY3Rpb24gbG9jay5cXG5cXG4gICAgICAgIFRpcHM6XFxuXFxuICAgICAgICAtIFRocm93IGF3YXkgeW91ciBhY3Rpb24gaGFuZGxlcnMgd2hlbiBmb3JjZVN0b3AoKSBpcyBjYWxsZWRcXG4gICAgICAgIC0gQ2hlY2sgYWN0aW9ucy5pc0FjdGl2ZSgpIGlmIHlvdSByZWFsbHkgbmVlZCB0b1xcbiAgICAgIFwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgIT09IHBoYXNlKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cXG4gICAgICAgIFRoZSBhY3Rpb25zIHlvdSB1c2VkIGJlbG9uZyB0byBhbiBvdXRkYXRlZCBwaGFzZVxcblxcbiAgICAgICAgQ3VycmVudCBwaGFzZTogXCIgKyBleHBlY3RlZCArIFwiXFxuICAgICAgICBZb3UgY2FsbGVkIGFuIGFjdGlvbiBmcm9tIG91dGRhdGVkIHBoYXNlOiBcIiArIHBoYXNlICsgXCJcXG5cXG4gICAgICAgIFRpcHM6XFxuXFxuICAgICAgICAtIERvIG5vdCB1c2UgcHJlRHJhZ0FjdGlvbnMgYWN0aW9ucyBhZnRlciBjYWxsaW5nIHByZURyYWdBY3Rpb25zLmxpZnQoKVxcbiAgICAgIFwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2FuU3RhcnQoX3JlZjIpIHtcbiAgdmFyIGxvY2tBUEkgPSBfcmVmMi5sb2NrQVBJLFxuICAgICAgc3RvcmUgPSBfcmVmMi5zdG9yZSxcbiAgICAgIHJlZ2lzdHJ5ID0gX3JlZjIucmVnaXN0cnksXG4gICAgICBkcmFnZ2FibGVJZCA9IF9yZWYyLmRyYWdnYWJsZUlkO1xuXG4gIGlmIChsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmZpbmRCeUlkKGRyYWdnYWJsZUlkKTtcblxuICBpZiAoIWVudHJ5KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlVuYWJsZSB0byBmaW5kIGRyYWdnYWJsZSB3aXRoIGlkOiBcIiArIGRyYWdnYWJsZUlkKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWVudHJ5Lm9wdGlvbnMuaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjYW5TdGFydERyYWcoc3RvcmUuZ2V0U3RhdGUoKSwgZHJhZ2dhYmxlSWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHRyeVN0YXJ0KF9yZWYzKSB7XG4gIHZhciBsb2NrQVBJID0gX3JlZjMubG9ja0FQSSxcbiAgICAgIGNvbnRleHRJZCA9IF9yZWYzLmNvbnRleHRJZCxcbiAgICAgIHN0b3JlID0gX3JlZjMuc3RvcmUsXG4gICAgICByZWdpc3RyeSA9IF9yZWYzLnJlZ2lzdHJ5LFxuICAgICAgZHJhZ2dhYmxlSWQgPSBfcmVmMy5kcmFnZ2FibGVJZCxcbiAgICAgIGZvcmNlU2Vuc29yU3RvcCA9IF9yZWYzLmZvcmNlU2Vuc29yU3RvcCxcbiAgICAgIHNvdXJjZUV2ZW50ID0gX3JlZjMuc291cmNlRXZlbnQ7XG4gIHZhciBzaG91bGRTdGFydCA9IGNhblN0YXJ0KHtcbiAgICBsb2NrQVBJOiBsb2NrQVBJLFxuICAgIHN0b3JlOiBzdG9yZSxcbiAgICByZWdpc3RyeTogcmVnaXN0cnksXG4gICAgZHJhZ2dhYmxlSWQ6IGRyYWdnYWJsZUlkXG4gIH0pO1xuXG4gIGlmICghc2hvdWxkU3RhcnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKGRyYWdnYWJsZUlkKTtcbiAgdmFyIGVsID0gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuXG4gIGlmICghZWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiVW5hYmxlIHRvIGZpbmQgZHJhZ2dhYmxlIGVsZW1lbnQgd2l0aCBpZDogXCIgKyBkcmFnZ2FibGVJZCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc291cmNlRXZlbnQgJiYgIWVudHJ5Lm9wdGlvbnMuY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgJiYgaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGVsLCBzb3VyY2VFdmVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsb2NrID0gbG9ja0FQSS5jbGFpbShmb3JjZVNlbnNvclN0b3AgfHwgbm9vcCk7XG4gIHZhciBwaGFzZSA9ICdQUkVfRFJBRyc7XG5cbiAgZnVuY3Rpb24gZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSB7XG4gICAgcmV0dXJuIGVudHJ5Lm9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xvY2tBY3RpdmUoKSB7XG4gICAgcmV0dXJuIGxvY2tBUEkuaXNBY3RpdmUobG9jayk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlEaXNwYXRjaChleHBlY3RlZCwgZ2V0QWN0aW9uKSB7XG4gICAgaWYgKF9pc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBwaGFzZTogcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmU6IGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZ2V0QWN0aW9uKCkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyA9IHRyeURpc3BhdGNoLmJpbmQobnVsbCwgJ0RSQUdHSU5HJyk7XG5cbiAgZnVuY3Rpb24gbGlmdCQxKGFyZ3MpIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICAgIHBoYXNlID0gJ0NPTVBMRVRFRCc7XG4gICAgfVxuXG4gICAgaWYgKHBoYXNlICE9PSAnUFJFX0RSQUcnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgICEocGhhc2UgPT09ICdQUkVfRFJBRycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBsaWZ0IGluIHBoYXNlIFwiICsgcGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBzdG9yZS5kaXNwYXRjaChsaWZ0KGFyZ3MubGlmdEFjdGlvbkFyZ3MpKTtcbiAgICBwaGFzZSA9ICdEUkFHR0lORyc7XG5cbiAgICBmdW5jdGlvbiBmaW5pc2gocmVhc29uLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MuY2xlYW51cCgpO1xuXG4gICAgICBpZiAob3B0aW9ucy5zaG91bGRCbG9ja05leHRDbGljaykge1xuICAgICAgICB2YXIgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICAgICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgICAgICAgIGZuOiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHNldFRpbWVvdXQodW5iaW5kKTtcbiAgICAgIH1cblxuICAgICAgY29tcGxldGVkKCk7XG4gICAgICBzdG9yZS5kaXNwYXRjaChkcm9wKHtcbiAgICAgICAgcmVhc29uOiByZWFzb25cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gX2lzQWN0aXZlKHtcbiAgICAgICAgICBleHBlY3RlZDogJ0RSQUdHSU5HJyxcbiAgICAgICAgICBwaGFzZTogcGhhc2UsXG4gICAgICAgICAgaXNMb2NrQWN0aXZlOiBpc0xvY2tBY3RpdmUsXG4gICAgICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgZHJvcDogZnVuY3Rpb24gZHJvcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goJ0RST1AnLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goJ0NBTkNFTCcsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIGFyZ3MuYWN0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVpZExpZnQoY2xpZW50U2VsZWN0aW9uKSB7XG4gICAgdmFyIG1vdmUkMSA9IHJhZlNjaGQoZnVuY3Rpb24gKGNsaWVudCkge1xuICAgICAgdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW92ZSh7XG4gICAgICAgICAgY2xpZW50OiBjbGllbnRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgYXBpID0gbGlmdCQxKHtcbiAgICAgIGxpZnRBY3Rpb25BcmdzOiB7XG4gICAgICAgIGlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgICAgIG1vdmVtZW50TW9kZTogJ0ZMVUlEJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIHJldHVybiBtb3ZlJDEuY2FuY2VsKCk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBtb3ZlOiBtb3ZlJDFcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFwaSwge1xuICAgICAgbW92ZTogbW92ZSQxXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzbmFwTGlmdCgpIHtcbiAgICB2YXIgYWN0aW9ucyA9IHtcbiAgICAgIG1vdmVVcDogZnVuY3Rpb24gbW92ZVVwJDEoKSB7XG4gICAgICAgIHJldHVybiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlVXApO1xuICAgICAgfSxcbiAgICAgIG1vdmVSaWdodDogZnVuY3Rpb24gbW92ZVJpZ2h0JDEoKSB7XG4gICAgICAgIHJldHVybiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlUmlnaHQpO1xuICAgICAgfSxcbiAgICAgIG1vdmVEb3duOiBmdW5jdGlvbiBtb3ZlRG93biQxKCkge1xuICAgICAgICByZXR1cm4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZURvd24pO1xuICAgICAgfSxcbiAgICAgIG1vdmVMZWZ0OiBmdW5jdGlvbiBtb3ZlTGVmdCQxKCkge1xuICAgICAgICByZXR1cm4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZUxlZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpZnQkMSh7XG4gICAgICBsaWZ0QWN0aW9uQXJnczoge1xuICAgICAgICBpZDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGNsaWVudFNlbGVjdGlvbjogZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24oZWwpLFxuICAgICAgICBtb3ZlbWVudE1vZGU6ICdTTkFQJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6IG5vb3AsXG4gICAgICBhY3Rpb25zOiBhY3Rpb25zXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydFByZURyYWcoKSB7XG4gICAgdmFyIHNob3VsZFJlbGVhc2UgPSBfaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICBwaGFzZTogcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmU6IGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRSZWxlYXNlKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJlRHJhZyA9IHtcbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gX2lzQWN0aXZlKHtcbiAgICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgICAgaXNMb2NrQWN0aXZlOiBpc0xvY2tBY3RpdmUsXG4gICAgICAgIHNob3VsZFdhcm46IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBmbHVpZExpZnQ6IGZsdWlkTGlmdCxcbiAgICBzbmFwTGlmdDogc25hcExpZnQsXG4gICAgYWJvcnQ6IGFib3J0UHJlRHJhZ1xuICB9O1xuICByZXR1cm4gcHJlRHJhZztcbn1cblxudmFyIGRlZmF1bHRTZW5zb3JzID0gW3VzZU1vdXNlU2Vuc29yLCB1c2VLZXlib2FyZFNlbnNvciwgdXNlTW91c2VTZW5zb3IkMV07XG5mdW5jdGlvbiB1c2VTZW5zb3JNYXJzaGFsKF9yZWY0KSB7XG4gIHZhciBjb250ZXh0SWQgPSBfcmVmNC5jb250ZXh0SWQsXG4gICAgICBzdG9yZSA9IF9yZWY0LnN0b3JlLFxuICAgICAgcmVnaXN0cnkgPSBfcmVmNC5yZWdpc3RyeSxcbiAgICAgIGN1c3RvbVNlbnNvcnMgPSBfcmVmNC5jdXN0b21TZW5zb3JzLFxuICAgICAgZW5hYmxlRGVmYXVsdFNlbnNvcnMgPSBfcmVmNC5lbmFibGVEZWZhdWx0U2Vuc29ycztcbiAgdmFyIHVzZVNlbnNvcnMgPSBbXS5jb25jYXQoZW5hYmxlRGVmYXVsdFNlbnNvcnMgPyBkZWZhdWx0U2Vuc29ycyA6IFtdLCBjdXN0b21TZW5zb3JzIHx8IFtdKTtcbiAgdmFyIGxvY2tBUEkgPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSgpO1xuICB9KVswXTtcbiAgdmFyIHRyeUFiYW5kb25Mb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBpZiAocHJldmlvdXMuaXNEcmFnZ2luZyAmJiAhY3VycmVudC5pc0RyYWdnaW5nKSB7XG4gICAgICBsb2NrQVBJLnRyeUFiYW5kb24oKTtcbiAgICB9XG4gIH0sIFtsb2NrQVBJXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbGlzdGVuVG9TdG9yZSgpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHZhciB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICB0cnlBYmFuZG9uTG9jayhwcmV2aW91cywgY3VycmVudCk7XG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbbG9ja0FQSSwgc3RvcmUsIHRyeUFiYW5kb25Mb2NrXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NrQVBJLnRyeUFiYW5kb247XG4gIH0sIFtsb2NrQVBJLnRyeUFiYW5kb25dKTtcbiAgdmFyIGNhbkdldExvY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZHJhZ2dhYmxlSWQpIHtcbiAgICByZXR1cm4gY2FuU3RhcnQoe1xuICAgICAgbG9ja0FQSTogbG9ja0FQSSxcbiAgICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2FibGVJZFxuICAgIH0pO1xuICB9LCBbbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIHZhciB0cnlHZXRMb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRyYWdnYWJsZUlkLCBmb3JjZVN0b3AsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHJ5U3RhcnQoe1xuICAgICAgbG9ja0FQSTogbG9ja0FQSSxcbiAgICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgZHJhZ2dhYmxlSWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgZm9yY2VTZW5zb3JTdG9wOiBmb3JjZVN0b3AsXG4gICAgICBzb3VyY2VFdmVudDogb3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZUV2ZW50ID8gb3B0aW9ucy5zb3VyY2VFdmVudCA6IG51bGxcbiAgICB9KTtcbiAgfSwgW2NvbnRleHRJZCwgbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIHZhciBmaW5kQ2xvc2VzdERyYWdnYWJsZUlkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KTtcbiAgfSwgW2NvbnRleHRJZF0pO1xuICB2YXIgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoaWQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5Lm9wdGlvbnMgOiBudWxsO1xuICB9LCBbcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG4gIHZhciB0cnlSZWxlYXNlTG9jayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlbGVhc2VMb2NrKCkge1xuICAgIGlmICghbG9ja0FQSS5pc0NsYWltZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuXG4gICAgaWYgKHN0b3JlLmdldFN0YXRlKCkucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgfVxuICB9LCBbbG9ja0FQSSwgc3RvcmVdKTtcbiAgdmFyIGlzTG9ja0NsYWltZWQgPSB1c2VDYWxsYmFjayhsb2NrQVBJLmlzQ2xhaW1lZCwgW2xvY2tBUEldKTtcbiAgdmFyIGFwaSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5HZXRMb2NrOiBjYW5HZXRMb2NrLFxuICAgICAgdHJ5R2V0TG9jazogdHJ5R2V0TG9jayxcbiAgICAgIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQ6IGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsXG4gICAgICBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZTogZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsXG4gICAgICB0cnlSZWxlYXNlTG9jazogdHJ5UmVsZWFzZUxvY2ssXG4gICAgICBpc0xvY2tDbGFpbWVkOiBpc0xvY2tDbGFpbWVkXG4gICAgfTtcbiAgfSwgW2NhbkdldExvY2ssIHRyeUdldExvY2ssIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsIGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlLCB0cnlSZWxlYXNlTG9jaywgaXNMb2NrQ2xhaW1lZF0pO1xuICB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHVzZVNlbnNvcnMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlU2Vuc29ycy5sZW5ndGg7IGkrKykge1xuICAgIHVzZVNlbnNvcnNbaV0oYXBpKTtcbiAgfVxufVxuXG52YXIgY3JlYXRlUmVzcG9uZGVycyA9IGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbmRlcnMocHJvcHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvbkJlZm9yZUNhcHR1cmU6IHByb3BzLm9uQmVmb3JlQ2FwdHVyZSxcbiAgICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gICAgb25EcmFnU3RhcnQ6IHByb3BzLm9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kLFxuICAgIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTdG9yZShsYXp5UmVmKSB7XG4gICFsYXp5UmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBzdG9yZSBmcm9tIGxhenkgcmVmJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gbGF6eVJlZi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBBcHAocHJvcHMpIHtcbiAgdmFyIGNvbnRleHRJZCA9IHByb3BzLmNvbnRleHRJZCxcbiAgICAgIHNldENhbGxiYWNrcyA9IHByb3BzLnNldENhbGxiYWNrcyxcbiAgICAgIHNlbnNvcnMgPSBwcm9wcy5zZW5zb3JzLFxuICAgICAgbm9uY2UgPSBwcm9wcy5ub25jZSxcbiAgICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyA9IHByb3BzLmRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucztcbiAgdmFyIGxhenlTdG9yZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlU3RhcnR1cFZhbGlkYXRpb24oKTtcbiAgdmFyIGxhc3RQcm9wc1JlZiA9IHVzZVByZXZpb3VzKHByb3BzKTtcbiAgdmFyIGdldFJlc3BvbmRlcnMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlc3BvbmRlcnMobGFzdFByb3BzUmVmLmN1cnJlbnQpO1xuICB9LCBbbGFzdFByb3BzUmVmXSk7XG4gIHZhciBhbm5vdW5jZSA9IHVzZUFubm91bmNlcihjb250ZXh0SWQpO1xuICB2YXIgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQgPSB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgdGV4dDogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zXG4gIH0pO1xuICB2YXIgc3R5bGVNYXJzaGFsID0gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpO1xuICB2YXIgbGF6eURpc3BhdGNoID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGFjdGlvbikge1xuICAgIGdldFN0b3JlKGxhenlTdG9yZVJlZikuZGlzcGF0Y2goYWN0aW9uKTtcbiAgfSwgW10pO1xuICB2YXIgbWFyc2hhbENhbGxiYWNrcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgcHVibGlzaFdoaWxlRHJhZ2dpbmc6IHB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgICAgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsOiB1cGRhdGVEcm9wcGFibGVTY3JvbGwsXG4gICAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQ6IHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICAgIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQ6IHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBjb2xsZWN0aW9uU3RhcnRpbmc6IGNvbGxlY3Rpb25TdGFydGluZ1xuICAgIH0sIGxhenlEaXNwYXRjaCk7XG4gIH0sIFtsYXp5RGlzcGF0Y2hdKTtcbiAgdmFyIHJlZ2lzdHJ5ID0gdXNlUmVnaXN0cnkoKTtcbiAgdmFyIGRpbWVuc2lvbk1hcnNoYWwgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlRGltZW5zaW9uTWFyc2hhbChyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrcyk7XG4gIH0sIFtyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrc10pO1xuICB2YXIgYXV0b1Njcm9sbGVyID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUF1dG9TY3JvbGxlcihfZXh0ZW5kcyh7XG4gICAgICBzY3JvbGxXaW5kb3c6IHNjcm9sbFdpbmRvdyxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogZGltZW5zaW9uTWFyc2hhbC5zY3JvbGxEcm9wcGFibGVcbiAgICB9LCBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgbW92ZTogbW92ZVxuICAgIH0sIGxhenlEaXNwYXRjaCkpKTtcbiAgfSwgW2RpbWVuc2lvbk1hcnNoYWwuc2Nyb2xsRHJvcHBhYmxlLCBsYXp5RGlzcGF0Y2hdKTtcbiAgdmFyIGZvY3VzTWFyc2hhbCA9IHVzZUZvY3VzTWFyc2hhbChjb250ZXh0SWQpO1xuICB2YXIgc3RvcmUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUoe1xuICAgICAgYW5ub3VuY2U6IGFubm91bmNlLFxuICAgICAgYXV0b1Njcm9sbGVyOiBhdXRvU2Nyb2xsZXIsXG4gICAgICBkaW1lbnNpb25NYXJzaGFsOiBkaW1lbnNpb25NYXJzaGFsLFxuICAgICAgZm9jdXNNYXJzaGFsOiBmb2N1c01hcnNoYWwsXG4gICAgICBnZXRSZXNwb25kZXJzOiBnZXRSZXNwb25kZXJzLFxuICAgICAgc3R5bGVNYXJzaGFsOiBzdHlsZU1hcnNoYWxcbiAgICB9KTtcbiAgfSwgW2Fubm91bmNlLCBhdXRvU2Nyb2xsZXIsIGRpbWVuc2lvbk1hcnNoYWwsIGZvY3VzTWFyc2hhbCwgZ2V0UmVzcG9uZGVycywgc3R5bGVNYXJzaGFsXSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAobGF6eVN0b3JlUmVmLmN1cnJlbnQgJiYgbGF6eVN0b3JlUmVmLmN1cnJlbnQgIT09IHN0b3JlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCd1bmV4cGVjdGVkIHN0b3JlIGNoYW5nZScpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIGxhenlTdG9yZVJlZi5jdXJyZW50ID0gc3RvcmU7XG4gIHZhciB0cnlSZXNldFN0b3JlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKTtcbiAgICB2YXIgc3RhdGUgPSBjdXJyZW50LmdldFN0YXRlKCk7XG5cbiAgICBpZiAoc3RhdGUucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgY3VycmVudC5kaXNwYXRjaChmbHVzaCgpKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIGlzRHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiBzdGF0ZS5pc0RyYWdnaW5nIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnO1xuICB9LCBbXSk7XG4gIHZhciBhcHBDYWxsYmFja3MgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNEcmFnZ2luZzogaXNEcmFnZ2luZyxcbiAgICAgIHRyeUFib3J0OiB0cnlSZXNldFN0b3JlXG4gICAgfTtcbiAgfSwgW2lzRHJhZ2dpbmcsIHRyeVJlc2V0U3RvcmVdKTtcbiAgc2V0Q2FsbGJhY2tzKGFwcENhbGxiYWNrcyk7XG4gIHZhciBnZXRDYW5MaWZ0ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGNhblN0YXJ0RHJhZyhnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCksIGlkKTtcbiAgfSwgW10pO1xuICB2YXIgZ2V0SXNNb3ZlbWVudEFsbG93ZWQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzTW92ZW1lbnRBbGxvd2VkKGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKSk7XG4gIH0sIFtdKTtcbiAgdmFyIGFwcENvbnRleHQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFyc2hhbDogZGltZW5zaW9uTWFyc2hhbCxcbiAgICAgIGZvY3VzOiBmb2N1c01hcnNoYWwsXG4gICAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICAgIGNhbkxpZnQ6IGdldENhbkxpZnQsXG4gICAgICBpc01vdmVtZW50QWxsb3dlZDogZ2V0SXNNb3ZlbWVudEFsbG93ZWQsXG4gICAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZDogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgICByZWdpc3RyeTogcmVnaXN0cnlcbiAgICB9O1xuICB9LCBbY29udGV4dElkLCBkaW1lbnNpb25NYXJzaGFsLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZm9jdXNNYXJzaGFsLCBnZXRDYW5MaWZ0LCBnZXRJc01vdmVtZW50QWxsb3dlZCwgcmVnaXN0cnldKTtcbiAgdXNlU2Vuc29yTWFyc2hhbCh7XG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgc3RvcmU6IHN0b3JlLFxuICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICBjdXN0b21TZW5zb3JzOiBzZW5zb3JzLFxuICAgIGVuYWJsZURlZmF1bHRTZW5zb3JzOiBwcm9wcy5lbmFibGVEZWZhdWx0U2Vuc29ycyAhPT0gZmFsc2VcbiAgfSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRyeVJlc2V0U3RvcmU7XG4gIH0sIFt0cnlSZXNldFN0b3JlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEFwcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYXBwQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICAgIHN0b3JlOiBzdG9yZVxuICB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxuXG52YXIgY291bnQkMSA9IDA7XG5mdW5jdGlvbiByZXNldCQxKCkge1xuICBjb3VudCQxID0gMDtcbn1cbmZ1bmN0aW9uIHVzZUluc3RhbmNlQ291bnQoKSB7XG4gIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIiArIGNvdW50JDErKztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiByZXNldFNlcnZlckNvbnRleHQoKSB7XG4gIHJlc2V0JDEoKTtcbiAgcmVzZXQoKTtcbn1cbmZ1bmN0aW9uIERyYWdEcm9wQ29udGV4dChwcm9wcykge1xuICB2YXIgY29udGV4dElkID0gdXNlSW5zdGFuY2VDb3VudCgpO1xuICB2YXIgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gcHJvcHMuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zIHx8IHByZXNldC5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIG51bGwsIGZ1bmN0aW9uIChzZXRDYWxsYmFja3MpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHAsIHtcbiAgICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgICAgc2V0Q2FsbGJhY2tzOiBzZXRDYWxsYmFja3MsXG4gICAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyxcbiAgICAgIGVuYWJsZURlZmF1bHRTZW5zb3JzOiBwcm9wcy5lbmFibGVEZWZhdWx0U2Vuc29ycyxcbiAgICAgIHNlbnNvcnM6IHByb3BzLnNlbnNvcnMsXG4gICAgICBvbkJlZm9yZUNhcHR1cmU6IHByb3BzLm9uQmVmb3JlQ2FwdHVyZSxcbiAgICAgIG9uQmVmb3JlRHJhZ1N0YXJ0OiBwcm9wcy5vbkJlZm9yZURyYWdTdGFydCxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlLFxuICAgICAgb25EcmFnRW5kOiBwcm9wcy5vbkRyYWdFbmRcbiAgICB9LCBwcm9wcy5jaGlsZHJlbik7XG4gIH0pO1xufVxuXG52YXIgaXNFcXVhbCQxID0gZnVuY3Rpb24gaXNFcXVhbChiYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYmFzZSA9PT0gdmFsdWU7XG4gIH07XG59O1xuXG52YXIgaXNTY3JvbGwgPSBpc0VxdWFsJDEoJ3Njcm9sbCcpO1xudmFyIGlzQXV0byA9IGlzRXF1YWwkMSgnYXV0bycpO1xudmFyIGlzVmlzaWJsZSQxID0gaXNFcXVhbCQxKCd2aXNpYmxlJyk7XG5cbnZhciBpc0VpdGhlciA9IGZ1bmN0aW9uIGlzRWl0aGVyKG92ZXJmbG93LCBmbikge1xuICByZXR1cm4gZm4ob3ZlcmZsb3cub3ZlcmZsb3dYKSB8fCBmbihvdmVyZmxvdy5vdmVyZmxvd1kpO1xufTtcblxudmFyIGlzQm90aCA9IGZ1bmN0aW9uIGlzQm90aChvdmVyZmxvdywgZm4pIHtcbiAgcmV0dXJuIGZuKG92ZXJmbG93Lm92ZXJmbG93WCkgJiYgZm4ob3ZlcmZsb3cub3ZlcmZsb3dZKTtcbn07XG5cbnZhciBpc0VsZW1lbnRTY3JvbGxhYmxlID0gZnVuY3Rpb24gaXNFbGVtZW50U2Nyb2xsYWJsZShlbCkge1xuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciBvdmVyZmxvdyA9IHtcbiAgICBvdmVyZmxvd1g6IHN0eWxlLm92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1k6IHN0eWxlLm92ZXJmbG93WVxuICB9O1xuICByZXR1cm4gaXNFaXRoZXIob3ZlcmZsb3csIGlzU2Nyb2xsKSB8fCBpc0VpdGhlcihvdmVyZmxvdywgaXNBdXRvKTtcbn07XG5cbnZhciBpc0JvZHlTY3JvbGxhYmxlID0gZnVuY3Rpb24gaXNCb2R5U2Nyb2xsYWJsZSgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAhaHRtbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIGlmICghaXNFbGVtZW50U2Nyb2xsYWJsZShib2R5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBodG1sU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcbiAgdmFyIGh0bWxPdmVyZmxvdyA9IHtcbiAgICBvdmVyZmxvd1g6IGh0bWxTdHlsZS5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZOiBodG1sU3R5bGUub3ZlcmZsb3dZXG4gIH07XG5cbiAgaWYgKGlzQm90aChodG1sT3ZlcmZsb3csIGlzVmlzaWJsZSQxKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgV2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHlvdXIgPGJvZHk+IGVsZW1lbnQgbWlnaHQgYmUgYSBzY3JvbGwgY29udGFpbmVyLlxcbiAgICBXZSBoYXZlIGZvdW5kIG5vIHJlbGlhYmxlIHdheSBvZiBkZXRlY3Rpbmcgd2hldGhlciB0aGUgPGJvZHk+IGVsZW1lbnQgaXMgYSBzY3JvbGwgY29udGFpbmVyLlxcbiAgICBVbmRlciBtb3N0IGNpcmN1bXN0YW5jZXMgYSA8Ym9keT4gc2Nyb2xsIGJhciB3aWxsIGJlIG9uIHRoZSA8aHRtbD4gZWxlbWVudCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxcblxcbiAgICBCZWNhdXNlIHdlIGNhbm5vdCBkZXRlcm1pbmUgaWYgdGhlIDxib2R5PiBpcyBhIHNjcm9sbCBjb250YWluZXIsIGFuZCBnZW5lcmFsbHkgaXQgaXMgbm90IG9uZSxcXG4gICAgd2Ugd2lsbCBiZSB0cmVhdGluZyB0aGUgPGJvZHk+IGFzICpub3QqIGEgc2Nyb2xsIGNvbnRhaW5lclxcblxcbiAgICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvYmxvYi9tYXN0ZXIvZG9jcy9ndWlkZXMvaG93LXdlLWRldGVjdC1zY3JvbGwtY29udGFpbmVycy5tZFxcbiAgXCIpIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgZ2V0Q2xvc2VzdFNjcm9sbGFibGUgPSBmdW5jdGlvbiBnZXRDbG9zZXN0U2Nyb2xsYWJsZShlbCkge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIGlzQm9keVNjcm9sbGFibGUoKSA/IGVsIDogbnVsbDtcbiAgfVxuXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWlzRWxlbWVudFNjcm9sbGFibGUoZWwpKSB7XG4gICAgcmV0dXJuIGdldENsb3Nlc3RTY3JvbGxhYmxlKGVsLnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyA9IChmdW5jdGlvbiAoc2Nyb2xsYWJsZSkge1xuICBpZiAoIXNjcm9sbGFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYW5vdGhlclNjcm9sbFBhcmVudCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHNjcm9sbGFibGUucGFyZW50RWxlbWVudCk7XG5cbiAgaWYgKCFhbm90aGVyU2Nyb2xsUGFyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICBEcm9wcGFibGU6IHVuc3VwcG9ydGVkIG5lc3RlZCBzY3JvbGwgY29udGFpbmVyIGRldGVjdGVkLlxcbiAgICBBIERyb3BwYWJsZSBjYW4gb25seSBoYXZlIG9uZSBzY3JvbGwgcGFyZW50ICh3aGljaCBjYW4gYmUgaXRzZWxmKVxcbiAgICBOZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxcblxcbiAgICBXZSBob3BlIHRvIHN1cHBvcnQgbmVzdGVkIHNjcm9sbCBjb250YWluZXJzIHNvb246IGh0dHBzOi8vZ2l0aHViLmNvbS9hdGxhc3NpYW4vcmVhY3QtYmVhdXRpZnVsLWRuZC9pc3N1ZXMvMTMxXFxuICBcIikgOiB2b2lkIDA7XG59KTtcblxudmFyIGdldFNjcm9sbCQxID0gKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4ge1xuICAgIHg6IGVsLnNjcm9sbExlZnQsXG4gICAgeTogZWwuc2Nyb2xsVG9wXG4gIH07XG59KTtcblxudmFyIGdldElzRml4ZWQgPSBmdW5jdGlvbiBnZXRJc0ZpeGVkKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZ2V0SXNGaXhlZChlbC5wYXJlbnRFbGVtZW50KTtcbn07XG5cbnZhciBnZXRFbnYgPSAoZnVuY3Rpb24gKHN0YXJ0KSB7XG4gIHZhciBjbG9zZXN0U2Nyb2xsYWJsZSA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHN0YXJ0KTtcbiAgdmFyIGlzRml4ZWRPblBhZ2UgPSBnZXRJc0ZpeGVkKHN0YXJ0KTtcbiAgcmV0dXJuIHtcbiAgICBjbG9zZXN0U2Nyb2xsYWJsZTogY2xvc2VzdFNjcm9sbGFibGUsXG4gICAgaXNGaXhlZE9uUGFnZTogaXNGaXhlZE9uUGFnZVxuICB9O1xufSk7XG5cbnZhciBnZXREcm9wcGFibGVEaW1lbnNpb24gPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBfcmVmLmRlc2NyaXB0b3IsXG4gICAgICBpc0VuYWJsZWQgPSBfcmVmLmlzRW5hYmxlZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQgPSBfcmVmLmlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBpc0ZpeGVkT25QYWdlID0gX3JlZi5pc0ZpeGVkT25QYWdlLFxuICAgICAgZGlyZWN0aW9uID0gX3JlZi5kaXJlY3Rpb24sXG4gICAgICBjbGllbnQgPSBfcmVmLmNsaWVudCxcbiAgICAgIHBhZ2UgPSBfcmVmLnBhZ2UsXG4gICAgICBjbG9zZXN0ID0gX3JlZi5jbG9zZXN0O1xuXG4gIHZhciBmcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNsb3Nlc3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxTaXplID0gY2xvc2VzdC5zY3JvbGxTaXplLFxuICAgICAgICBmcmFtZUNsaWVudCA9IGNsb3Nlc3QuY2xpZW50O1xuICAgIHZhciBtYXhTY3JvbGwgPSBnZXRNYXhTY3JvbGwoe1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBzY3JvbGxTaXplLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBzY3JvbGxTaXplLnNjcm9sbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBmcmFtZUNsaWVudC5wYWRkaW5nQm94LmhlaWdodCxcbiAgICAgIHdpZHRoOiBmcmFtZUNsaWVudC5wYWRkaW5nQm94LndpZHRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VNYXJnaW5Cb3g6IGNsb3Nlc3QucGFnZS5tYXJnaW5Cb3gsXG4gICAgICBmcmFtZUNsaWVudDogZnJhbWVDbGllbnQsXG4gICAgICBzY3JvbGxTaXplOiBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6IGNsb3Nlc3Quc2hvdWxkQ2xpcFN1YmplY3QsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgaW5pdGlhbDogY2xvc2VzdC5zY3JvbGwsXG4gICAgICAgIGN1cnJlbnQ6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgICAgZGlmZjoge1xuICAgICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgYXhpcyA9IGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHZlcnRpY2FsIDogaG9yaXpvbnRhbDtcbiAgdmFyIHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBheGlzOiBheGlzLFxuICAgIGZyYW1lOiBmcmFtZVxuICB9KTtcbiAgdmFyIGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgIGlzQ29tYmluZUVuYWJsZWQ6IGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaXNGaXhlZE9uUGFnZTogaXNGaXhlZE9uUGFnZSxcbiAgICBheGlzOiBheGlzLFxuICAgIGlzRW5hYmxlZDogaXNFbmFibGVkLFxuICAgIGNsaWVudDogY2xpZW50LFxuICAgIHBhZ2U6IHBhZ2UsXG4gICAgZnJhbWU6IGZyYW1lLFxuICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn0pO1xuXG52YXIgZ2V0Q2xpZW50ID0gZnVuY3Rpb24gZ2V0Q2xpZW50KHRhcmdldFJlZiwgY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgdmFyIGJhc2UgPSBnZXRCb3godGFyZ2V0UmVmKTtcblxuICBpZiAoIWNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICBpZiAodGFyZ2V0UmVmICE9PSBjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgdmFyIHRvcCA9IGJhc2UucGFkZGluZ0JveC50b3AgLSBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxUb3A7XG4gIHZhciBsZWZ0ID0gYmFzZS5wYWRkaW5nQm94LmxlZnQgLSBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxMZWZ0O1xuICB2YXIgYm90dG9tID0gdG9wICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0O1xuICB2YXIgcmlnaHQgPSBsZWZ0ICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGg7XG4gIHZhciBwYWRkaW5nQm94ID0ge1xuICAgIHRvcDogdG9wLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICBsZWZ0OiBsZWZ0XG4gIH07XG4gIHZhciBib3JkZXJCb3ggPSBleHBhbmQocGFkZGluZ0JveCwgYmFzZS5ib3JkZXIpO1xuICB2YXIgY2xpZW50ID0gY3JlYXRlQm94KHtcbiAgICBib3JkZXJCb3g6IGJvcmRlckJveCxcbiAgICBtYXJnaW46IGJhc2UubWFyZ2luLFxuICAgIGJvcmRlcjogYmFzZS5ib3JkZXIsXG4gICAgcGFkZGluZzogYmFzZS5wYWRkaW5nXG4gIH0pO1xuICByZXR1cm4gY2xpZW50O1xufTtcblxudmFyIGdldERpbWVuc2lvbiA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmVmID0gX3JlZi5yZWYsXG4gICAgICBkZXNjcmlwdG9yID0gX3JlZi5kZXNjcmlwdG9yLFxuICAgICAgZW52ID0gX3JlZi5lbnYsXG4gICAgICB3aW5kb3dTY3JvbGwgPSBfcmVmLndpbmRvd1Njcm9sbCxcbiAgICAgIGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uLFxuICAgICAgaXNEcm9wRGlzYWJsZWQgPSBfcmVmLmlzRHJvcERpc2FibGVkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZCA9IF9yZWYuaXNDb21iaW5lRW5hYmxlZCxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0ID0gX3JlZi5zaG91bGRDbGlwU3ViamVjdDtcbiAgdmFyIGNsb3Nlc3RTY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICB2YXIgY2xpZW50ID0gZ2V0Q2xpZW50KHJlZiwgY2xvc2VzdFNjcm9sbGFibGUpO1xuICB2YXIgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCB3aW5kb3dTY3JvbGwpO1xuXG4gIHZhciBjbG9zZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcmFtZUNsaWVudCA9IGdldEJveChjbG9zZXN0U2Nyb2xsYWJsZSk7XG4gICAgdmFyIHNjcm9sbFNpemUgPSB7XG4gICAgICBzY3JvbGxIZWlnaHQ6IGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxXaWR0aFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudDogZnJhbWVDbGllbnQsXG4gICAgICBwYWdlOiB3aXRoU2Nyb2xsKGZyYW1lQ2xpZW50LCB3aW5kb3dTY3JvbGwpLFxuICAgICAgc2Nyb2xsOiBnZXRTY3JvbGwkMShjbG9zZXN0U2Nyb2xsYWJsZSksXG4gICAgICBzY3JvbGxTaXplOiBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6IHNob3VsZENsaXBTdWJqZWN0XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBkaW1lbnNpb24gPSBnZXREcm9wcGFibGVEaW1lbnNpb24oe1xuICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgaXNFbmFibGVkOiAhaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZDogaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpc0ZpeGVkT25QYWdlOiBlbnYuaXNGaXhlZE9uUGFnZSxcbiAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICBjbGllbnQ6IGNsaWVudCxcbiAgICBwYWdlOiBwYWdlLFxuICAgIGNsb3Nlc3Q6IGNsb3Nlc3RcbiAgfSk7XG4gIHJldHVybiBkaW1lbnNpb247XG59KTtcblxudmFyIGltbWVkaWF0ZSA9IHtcbiAgcGFzc2l2ZTogZmFsc2Vcbn07XG52YXIgZGVsYXllZCA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcbnZhciBnZXRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5ID8gaW1tZWRpYXRlIDogZGVsYXllZDtcbn0pO1xuXG5mdW5jdGlvbiB1c2VSZXF1aXJlZENvbnRleHQoQ29udGV4dCkge1xuICB2YXIgcmVzdWx0ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgIXJlc3VsdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHJlcXVpcmVkIGNvbnRleHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZykge1xuICByZXR1cm4gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlIHx8IG51bGw7XG59O1xuXG5mdW5jdGlvbiB1c2VEcm9wcGFibGVQdWJsaXNoZXIoYXJncykge1xuICB2YXIgd2hpbGVEcmFnZ2luZ1JlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGFwcENvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIHZhciB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdkcm9wcGFibGUnKTtcbiAgdmFyIHJlZ2lzdHJ5ID0gYXBwQ29udGV4dC5yZWdpc3RyeSxcbiAgICAgIG1hcnNoYWwgPSBhcHBDb250ZXh0Lm1hcnNoYWw7XG4gIHZhciBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKGFyZ3MpO1xuICB2YXIgZGVzY3JpcHRvciA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogYXJncy5kcm9wcGFibGVJZCxcbiAgICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICAgIG1vZGU6IGFyZ3MubW9kZVxuICAgIH07XG4gIH0sIFthcmdzLmRyb3BwYWJsZUlkLCBhcmdzLm1vZGUsIGFyZ3MudHlwZV0pO1xuICB2YXIgcHVibGlzaGVkRGVzY3JpcHRvclJlZiA9IHVzZVJlZihkZXNjcmlwdG9yKTtcbiAgdmFyIG1lbW9pemVkVXBkYXRlU2Nyb2xsID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1lbW9pemVPbmUoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgc2Nyb2xsIHdoZW4gZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgc2Nyb2xsID0ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVTY3JvbGwoZGVzY3JpcHRvci5pZCwgc2Nyb2xsKTtcbiAgICB9KTtcbiAgfSwgW2Rlc2NyaXB0b3IuaWQsIG1hcnNoYWxdKTtcbiAgdmFyIGdldENsb3Nlc3RTY3JvbGwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuXG4gICAgaWYgKCFkcmFnZ2luZyB8fCAhZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTY3JvbGwkMShkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUpO1xuICB9LCBbXSk7XG4gIHZhciB1cGRhdGVTY3JvbGwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbCA9IGdldENsb3Nlc3RTY3JvbGwoKTtcbiAgICBtZW1vaXplZFVwZGF0ZVNjcm9sbChzY3JvbGwueCwgc2Nyb2xsLnkpO1xuICB9LCBbZ2V0Q2xvc2VzdFNjcm9sbCwgbWVtb2l6ZWRVcGRhdGVTY3JvbGxdKTtcbiAgdmFyIHNjaGVkdWxlU2Nyb2xsVXBkYXRlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhZlNjaGQodXBkYXRlU2Nyb2xsKTtcbiAgfSwgW3VwZGF0ZVNjcm9sbF0pO1xuICB2YXIgb25DbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICB2YXIgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICEoZHJhZ2dpbmcgJiYgY2xvc2VzdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBzY3JvbGwgb3B0aW9ucyB3aGlsZSBzY3JvbGxpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIG9wdGlvbnMgPSBkcmFnZ2luZy5zY3JvbGxPcHRpb25zO1xuXG4gICAgaWYgKG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5KSB7XG4gICAgICB1cGRhdGVTY3JvbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVNjcm9sbFVwZGF0ZSgpO1xuICB9LCBbc2NoZWR1bGVTY3JvbGxVcGRhdGUsIHVwZGF0ZVNjcm9sbF0pO1xuICB2YXIgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAod2luZG93U2Nyb2xsLCBvcHRpb25zKSB7XG4gICAgISF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCBhIGRyb3BwYWJsZSB3aGlsZSBhIGRyYWcgaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBwcmV2aW91cyA9IHByZXZpb3VzUmVmLmN1cnJlbnQ7XG4gICAgdmFyIHJlZiA9IHByZXZpb3VzLmdldERyb3BwYWJsZVJlZigpO1xuICAgICFyZWYgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCB3aXRob3V0IGEgZHJvcHBhYmxlIHJlZicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZW52ID0gZ2V0RW52KHJlZik7XG4gICAgdmFyIGRyYWdnaW5nID0ge1xuICAgICAgcmVmOiByZWYsXG4gICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgZW52OiBlbnYsXG4gICAgICBzY3JvbGxPcHRpb25zOiBvcHRpb25zXG4gICAgfTtcbiAgICB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPSBkcmFnZ2luZztcbiAgICB2YXIgZGltZW5zaW9uID0gZ2V0RGltZW5zaW9uKHtcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICAgIGVudjogZW52LFxuICAgICAgd2luZG93U2Nyb2xsOiB3aW5kb3dTY3JvbGwsXG4gICAgICBkaXJlY3Rpb246IHByZXZpb3VzLmRpcmVjdGlvbixcbiAgICAgIGlzRHJvcERpc2FibGVkOiBwcmV2aW91cy5pc0Ryb3BEaXNhYmxlZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQ6IHByZXZpb3VzLmlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdDogIXByZXZpb3VzLmlnbm9yZUNvbnRhaW5lckNsaXBwaW5nXG4gICAgfSk7XG4gICAgdmFyIHNjcm9sbGFibGUgPSBlbnYuY2xvc2VzdFNjcm9sbGFibGU7XG5cbiAgICBpZiAoc2Nyb2xsYWJsZSkge1xuICAgICAgc2Nyb2xsYWJsZS5zZXRBdHRyaWJ1dGUoc2Nyb2xsQ29udGFpbmVyLmNvbnRleHRJZCwgYXBwQ29udGV4dC5jb250ZXh0SWQpO1xuICAgICAgc2Nyb2xsYWJsZS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbkNsb3Nlc3RTY3JvbGwsIGdldExpc3RlbmVyT3B0aW9ucyhkcmFnZ2luZy5zY3JvbGxPcHRpb25zKSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyhzY3JvbGxhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xuICB9LCBbYXBwQ29udGV4dC5jb250ZXh0SWQsIGRlc2NyaXB0b3IsIG9uQ2xvc2VzdFNjcm9sbCwgcHJldmlvdXNSZWZdKTtcbiAgdmFyIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIHZhciBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIShkcmFnZ2luZyAmJiBjbG9zZXN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHJlY29sbGVjdCBEcm9wcGFibGUgY2xpZW50IGZvciBEcm9wcGFibGVzIHRoYXQgaGF2ZSBhIHNjcm9sbCBjb250YWluZXInKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldFNjcm9sbCQxKGNsb3Nlc3QpO1xuICB9LCBbXSk7XG4gIHZhciBkcmFnU3RvcHBlZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3AgZHJhZyB3aGVuIG5vIGFjdGl2ZSBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID0gbnVsbDtcblxuICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlLmNhbmNlbCgpO1xuICAgIGNsb3Nlc3QucmVtb3ZlQXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQpO1xuICAgIGNsb3Nlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICB9LCBbb25DbG9zZXN0U2Nyb2xsLCBzY2hlZHVsZVNjcm9sbFVwZGF0ZV0pO1xuICB2YXIgc2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgIHZhciBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICFjbG9zZXN0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNjcm9sbCBhIGRyb3BwYWJsZSB3aXRoIG5vIGNsb3Nlc3Qgc2Nyb2xsYWJsZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjbG9zZXN0LnNjcm9sbFRvcCArPSBjaGFuZ2UueTtcbiAgICBjbG9zZXN0LnNjcm9sbExlZnQgKz0gY2hhbmdlLng7XG4gIH0sIFtdKTtcbiAgdmFyIGNhbGxiYWNrcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbDogZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwsXG4gICAgICBnZXRTY3JvbGxXaGlsZURyYWdnaW5nOiBnZXRTY3JvbGxXaGlsZURyYWdnaW5nLFxuICAgICAgZHJhZ1N0b3BwZWQ6IGRyYWdTdG9wcGVkLFxuICAgICAgc2Nyb2xsOiBzY3JvbGxcbiAgICB9O1xuICB9LCBbZHJhZ1N0b3BwZWQsIGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsLCBnZXRTY3JvbGxXaGlsZURyYWdnaW5nLCBzY3JvbGxdKTtcbiAgdmFyIGVudHJ5ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXF1ZUlkOiB1bmlxdWVJZCxcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICBjYWxsYmFja3M6IGNhbGxiYWNrc1xuICAgIH07XG4gIH0sIFtjYWxsYmFja3MsIGRlc2NyaXB0b3IsIHVuaXF1ZUlkXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudCA9IGVudHJ5LmRlc2NyaXB0b3I7XG4gICAgcmVnaXN0cnkuZHJvcHBhYmxlLnJlZ2lzdGVyKGVudHJ5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdVbnN1cHBvcnRlZDogY2hhbmdpbmcgdGhlIGRyb3BwYWJsZUlkIG9yIHR5cGUgb2YgYSBEcm9wcGFibGUgZHVyaW5nIGEgZHJhZycpIDogdm9pZCAwO1xuICAgICAgICBkcmFnU3RvcHBlZCgpO1xuICAgICAgfVxuXG4gICAgICByZWdpc3RyeS5kcm9wcGFibGUudW5yZWdpc3RlcihlbnRyeSk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgZHJhZ1N0b3BwZWQsIGVudHJ5LCBtYXJzaGFsLCByZWdpc3RyeS5kcm9wcGFibGVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsICFhcmdzLmlzRHJvcERpc2FibGVkKTtcbiAgfSwgW2FyZ3MuaXNEcm9wRGlzYWJsZWQsIG1hcnNoYWxdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQocHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50LmlkLCBhcmdzLmlzQ29tYmluZUVuYWJsZWQpO1xuICB9LCBbYXJncy5pc0NvbWJpbmVFbmFibGVkLCBtYXJzaGFsXSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbnZhciBlbXB0eSA9IHtcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgbWFyZ2luOiBub1NwYWNpbmdcbn07XG5cbnZhciBnZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZShfcmVmKSB7XG4gIHZhciBpc0FuaW1hdGluZ09wZW5Pbk1vdW50ID0gX3JlZi5pc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgICAgcGxhY2Vob2xkZXIgPSBfcmVmLnBsYWNlaG9sZGVyLFxuICAgICAgYW5pbWF0ZSA9IF9yZWYuYW5pbWF0ZTtcblxuICBpZiAoaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuXG4gIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHdpZHRoOiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LndpZHRoLFxuICAgIG1hcmdpbjogcGxhY2Vob2xkZXIuY2xpZW50Lm1hcmdpblxuICB9O1xufTtcblxudmFyIGdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUoX3JlZjIpIHtcbiAgdmFyIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQgPSBfcmVmMi5pc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgICAgcGxhY2Vob2xkZXIgPSBfcmVmMi5wbGFjZWhvbGRlcixcbiAgICAgIGFuaW1hdGUgPSBfcmVmMi5hbmltYXRlO1xuICB2YXIgc2l6ZSA9IGdldFNpemUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQ6IGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgIGFuaW1hdGU6IGFuaW1hdGVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxheTogcGxhY2Vob2xkZXIuZGlzcGxheSxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgIG1hcmdpblRvcDogc2l6ZS5tYXJnaW4udG9wLFxuICAgIG1hcmdpblJpZ2h0OiBzaXplLm1hcmdpbi5yaWdodCxcbiAgICBtYXJnaW5Cb3R0b206IHNpemUubWFyZ2luLmJvdHRvbSxcbiAgICBtYXJnaW5MZWZ0OiBzaXplLm1hcmdpbi5sZWZ0LFxuICAgIGZsZXhTaHJpbms6ICcwJyxcbiAgICBmbGV4R3JvdzogJzAnLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB0cmFuc2l0aW9uOiBhbmltYXRlICE9PSAnbm9uZScgPyB0cmFuc2l0aW9ucy5wbGFjZWhvbGRlciA6IG51bGxcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHByb3BzKSB7XG4gIHZhciBhbmltYXRlT3BlblRpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmICghYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfSwgW10pO1xuICB2YXIgYW5pbWF0ZSA9IHByb3BzLmFuaW1hdGUsXG4gICAgICBvblRyYW5zaXRpb25FbmQgPSBwcm9wcy5vblRyYW5zaXRpb25FbmQsXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIGNvbnRleHRJZCA9IHByb3BzLmNvbnRleHRJZDtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUocHJvcHMuYW5pbWF0ZSA9PT0gJ29wZW4nKSxcbiAgICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50ID0gX3VzZVN0YXRlWzFdO1xuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc0FuaW1hdGluZ09wZW5Pbk1vdW50KSB7XG4gICAgICByZXR1cm4gbm9vcCQyO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcigpO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgICByZXR1cm4gbm9vcCQyO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybiBub29wJDI7XG4gICAgfVxuXG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcjtcbiAgfSwgW2FuaW1hdGUsIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcl0pO1xuICB2YXIgb25TaXplQ2hhbmdlRW5kID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ2hlaWdodCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvblRyYW5zaXRpb25FbmQoKTtcblxuICAgIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9LCBbYW5pbWF0ZSwgb25DbG9zZSwgb25UcmFuc2l0aW9uRW5kXSk7XG4gIHZhciBzdHlsZSA9IGdldFN0eWxlKHtcbiAgICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50OiBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgIGFuaW1hdGU6IHByb3BzLmFuaW1hdGUsXG4gICAgcGxhY2Vob2xkZXI6IHByb3BzLnBsYWNlaG9sZGVyXG4gIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wcy5wbGFjZWhvbGRlci50YWdOYW1lLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgICdkYXRhLXJiZC1wbGFjZWhvbGRlci1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25TaXplQ2hhbmdlRW5kLFxuICAgIHJlZjogcHJvcHMuaW5uZXJSZWZcbiAgfSk7XG59XG5cbnZhciBQbGFjZWhvbGRlciQxID0gUmVhY3QubWVtbyhQbGFjZWhvbGRlcik7XG5cbnZhciBEcm9wcGFibGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZWwpIHtcbiAgIShlbCAmJiBpc0h0bWxFbGVtZW50KGVsKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiXFxuICAgIHByb3ZpZGVkLmlubmVyUmVmIGhhcyBub3QgYmVlbiBwcm92aWRlZCB3aXRoIGEgSFRNTEVsZW1lbnQuXFxuXFxuICAgIFlvdSBjYW4gZmluZCBhIGd1aWRlIG9uIHVzaW5nIHRoZSBpbm5lclJlZiBjYWxsYmFjayBmdW5jdGlvbnMgYXQ6XFxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hdGxhc3NpYW4vcmVhY3QtYmVhdXRpZnVsLWRuZC9ibG9iL21hc3Rlci9kb2NzL2d1aWRlcy91c2luZy1pbm5lci1yZWYubWRcXG4gIFwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5cbmZ1bmN0aW9uIHJ1bkNoZWNrcyhhcmdzLCBjaGVja3MpIHtcbiAgY2hlY2tzLmZvckVhY2goZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgcmV0dXJuIGNoZWNrKGFyZ3MpO1xuICB9KTtcbn1cblxudmFyIHNoYXJlZCA9IFtmdW5jdGlvbiByZXF1aXJlZChfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICFwcm9wcy5kcm9wcGFibGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRHJvcHBhYmxlIHJlcXVpcmVzIGEgZHJvcHBhYmxlSWQgcHJvcCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgISh0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJBIERyb3BwYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyb3BwYWJsZUlkLiBQcm92aWRlZDogW1wiICsgdHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkICsgXCJdXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIF9ib29sZWFuKF9yZWYyKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAhaXNCb29sZWFuKHByb3BzLmlzRHJvcERpc2FibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzRHJvcERpc2FibGVkIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhaXNCb29sZWFuKHByb3BzLmlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNDb21iaW5lRW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpZ25vcmVDb250YWluZXJDbGlwcGluZyBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIHJlZihfcmVmMykge1xuICB2YXIgZ2V0RHJvcHBhYmxlUmVmID0gX3JlZjMuZ2V0RHJvcHBhYmxlUmVmO1xuICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXREcm9wcGFibGVSZWYoKSk7XG59XTtcbnZhciBzdGFuZGFyZCA9IFtmdW5jdGlvbiBwbGFjZWhvbGRlcihfcmVmNCkge1xuICB2YXIgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgIGdldFBsYWNlaG9sZGVyUmVmID0gX3JlZjQuZ2V0UGxhY2Vob2xkZXJSZWY7XG5cbiAgaWYgKCFwcm9wcy5wbGFjZWhvbGRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWYgPSBnZXRQbGFjZWhvbGRlclJlZigpO1xuXG4gIGlmIChyZWYpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgRHJvcHBhYmxlIHNldHVwIGlzc3VlIFtkcm9wcGFibGVJZDogXFxcIlwiICsgcHJvcHMuZHJvcHBhYmxlSWQgKyBcIlxcXCJdOlxcbiAgICAgIERyb3BwYWJsZVByb3ZpZGVkID4gcGxhY2Vob2xkZXIgY291bGQgbm90IGJlIGZvdW5kLlxcblxcbiAgICAgIFBsZWFzZSBiZSBzdXJlIHRvIGFkZCB0aGUge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfSBSZWFjdCBOb2RlIGFzIGEgY2hpbGQgb2YgeW91ciBEcm9wcGFibGUuXFxuICAgICAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2Jsb2IvbWFzdGVyL2RvY3MvYXBpL2Ryb3BwYWJsZS5tZFxcbiAgICBcIikgOiB2b2lkIDA7XG59XTtcbnZhciB2aXJ0dWFsID0gW2Z1bmN0aW9uIGhhc0Nsb25lKF9yZWY1KSB7XG4gIHZhciBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAhcHJvcHMucmVuZGVyQ2xvbmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IHByb3ZpZGUgYSBjbG9uZSByZW5kZXIgZnVuY3Rpb24gKHJlbmRlckNsb25lKSBmb3IgdmlydHVhbCBsaXN0cycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIGhhc05vUGxhY2Vob2xkZXIoX3JlZjYpIHtcbiAgdmFyIGdldFBsYWNlaG9sZGVyUmVmID0gX3JlZjYuZ2V0UGxhY2Vob2xkZXJSZWY7XG4gICEhZ2V0UGxhY2Vob2xkZXJSZWYoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHZpcnR1YWwgbGlzdCB0byBub3QgaGF2ZSBhIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufV07XG5mdW5jdGlvbiB1c2VWYWxpZGF0aW9uKGFyZ3MpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKGZ1bmN0aW9uICgpIHtcbiAgICBydW5DaGVja3MoYXJncywgc2hhcmVkKTtcblxuICAgIGlmIChhcmdzLnByb3BzLm1vZGUgPT09ICdzdGFuZGFyZCcpIHtcbiAgICAgIHJ1bkNoZWNrcyhhcmdzLCBzdGFuZGFyZCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MucHJvcHMubW9kZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgdmlydHVhbCk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIEFuaW1hdGVJbk91dCA9IGZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShBbmltYXRlSW5PdXQsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBBbmltYXRlSW5PdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JFB1cmVDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkUHVyZUNvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzVmlzaWJsZTogQm9vbGVhbihfdGhpcy5wcm9wcy5vbiksXG4gICAgICBkYXRhOiBfdGhpcy5wcm9wcy5vbixcbiAgICAgIGFuaW1hdGU6IF90aGlzLnByb3BzLnNob3VsZEFuaW1hdGUgJiYgX3RoaXMucHJvcHMub24gPyAnb3BlbicgOiAnbm9uZSdcbiAgICB9O1xuXG4gICAgX3RoaXMub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5hbmltYXRlICE9PSAnY2xvc2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc1Zpc2libGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQW5pbWF0ZUluT3V0LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoIXByb3BzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbihwcm9wcy5vbiksXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnbm9uZSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLm9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnb3BlbidcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLFxuICAgICAgICBhbmltYXRlOiAnY2xvc2UnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogJ2Nsb3NlJyxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBBbmltYXRlSW5PdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByb3ZpZGVkID0ge1xuICAgICAgb25DbG9zZTogdGhpcy5vbkNsb3NlLFxuICAgICAgZGF0YTogdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgYW5pbWF0ZTogdGhpcy5zdGF0ZS5hbmltYXRlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbihwcm92aWRlZCk7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGVJbk91dDtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbnZhciB6SW5kZXhPcHRpb25zID0ge1xuICBkcmFnZ2luZzogNTAwMCxcbiAgZHJvcEFuaW1hdGluZzogNDUwMFxufTtcblxudmFyIGdldERyYWdnaW5nVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGdldERyYWdnaW5nVHJhbnNpdGlvbihzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50LCBkcm9wcGluZykge1xuICBpZiAoZHJvcHBpbmcpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbnMuZHJvcChkcm9wcGluZy5kdXJhdGlvbik7XG4gIH1cblxuICBpZiAoc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9ucy5zbmFwO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zaXRpb25zLmZsdWlkO1xufTtcblxudmFyIGdldERyYWdnaW5nT3BhY2l0eSA9IGZ1bmN0aW9uIGdldERyYWdnaW5nT3BhY2l0eShpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSB7XG4gIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBpc0Ryb3BBbmltYXRpbmcgPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IGNvbWJpbmUub3BhY2l0eS5jb21iaW5pbmc7XG59O1xuXG52YXIgZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlID0gZnVuY3Rpb24gZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlKGRyYWdnaW5nKSB7XG4gIGlmIChkcmFnZ2luZy5mb3JjZVNob3VsZEFuaW1hdGUgIT0gbnVsbCkge1xuICAgIHJldHVybiBkcmFnZ2luZy5mb3JjZVNob3VsZEFuaW1hdGU7XG4gIH1cblxuICByZXR1cm4gZHJhZ2dpbmcubW9kZSA9PT0gJ1NOQVAnO1xufTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dpbmdTdHlsZShkcmFnZ2luZykge1xuICB2YXIgZGltZW5zaW9uID0gZHJhZ2dpbmcuZGltZW5zaW9uO1xuICB2YXIgYm94ID0gZGltZW5zaW9uLmNsaWVudDtcbiAgdmFyIG9mZnNldCA9IGRyYWdnaW5nLm9mZnNldCxcbiAgICAgIGNvbWJpbmVXaXRoID0gZHJhZ2dpbmcuY29tYmluZVdpdGgsXG4gICAgICBkcm9wcGluZyA9IGRyYWdnaW5nLmRyb3BwaW5nO1xuICB2YXIgaXNDb21iaW5pbmcgPSBCb29sZWFuKGNvbWJpbmVXaXRoKTtcbiAgdmFyIHNob3VsZEFuaW1hdGUgPSBnZXRTaG91bGREcmFnZ2luZ0FuaW1hdGUoZHJhZ2dpbmcpO1xuICB2YXIgaXNEcm9wQW5pbWF0aW5nID0gQm9vbGVhbihkcm9wcGluZyk7XG4gIHZhciB0cmFuc2Zvcm0gPSBpc0Ryb3BBbmltYXRpbmcgPyB0cmFuc2Zvcm1zLmRyb3Aob2Zmc2V0LCBpc0NvbWJpbmluZykgOiB0cmFuc2Zvcm1zLm1vdmVUbyhvZmZzZXQpO1xuICB2YXIgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgdG9wOiBib3gubWFyZ2luQm94LnRvcCxcbiAgICBsZWZ0OiBib3gubWFyZ2luQm94LmxlZnQsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IGJveC5ib3JkZXJCb3gud2lkdGgsXG4gICAgaGVpZ2h0OiBib3guYm9yZGVyQm94LmhlaWdodCxcbiAgICB0cmFuc2l0aW9uOiBnZXREcmFnZ2luZ1RyYW5zaXRpb24oc2hvdWxkQW5pbWF0ZSwgZHJvcHBpbmcpLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIG9wYWNpdHk6IGdldERyYWdnaW5nT3BhY2l0eShpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSxcbiAgICB6SW5kZXg6IGlzRHJvcEFuaW1hdGluZyA/IHpJbmRleE9wdGlvbnMuZHJvcEFuaW1hdGluZyA6IHpJbmRleE9wdGlvbnMuZHJhZ2dpbmcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gIH07XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U3R5bGUoc2Vjb25kYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1zLm1vdmVUbyhzZWNvbmRhcnkub2Zmc2V0KSxcbiAgICB0cmFuc2l0aW9uOiBzZWNvbmRhcnkuc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCA/IG51bGwgOiAnbm9uZSdcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGUkMShtYXBwZWQpIHtcbiAgcmV0dXJuIG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnID8gZ2V0RHJhZ2dpbmdTdHlsZShtYXBwZWQpIDogZ2V0U2Vjb25kYXJ5U3R5bGUobWFwcGVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCkge1xuICBpZiAod2luZG93U2Nyb2xsID09PSB2b2lkIDApIHtcbiAgICB3aW5kb3dTY3JvbGwgPSBvcmlnaW47XG4gIH1cblxuICB2YXIgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciBib3JkZXJCb3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGNsaWVudCA9IGNhbGN1bGF0ZUJveChib3JkZXJCb3gsIGNvbXB1dGVkU3R5bGVzKTtcbiAgdmFyIHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcbiAgdmFyIHBsYWNlaG9sZGVyID0ge1xuICAgIGNsaWVudDogY2xpZW50LFxuICAgIHRhZ05hbWU6IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICBkaXNwbGF5OiBjb21wdXRlZFN0eWxlcy5kaXNwbGF5XG4gIH07XG4gIHZhciBkaXNwbGFjZUJ5ID0ge1xuICAgIHg6IGNsaWVudC5tYXJnaW5Cb3gud2lkdGgsXG4gICAgeTogY2xpZW50Lm1hcmdpbkJveC5oZWlnaHRcbiAgfTtcbiAgdmFyIGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICBkaXNwbGFjZUJ5OiBkaXNwbGFjZUJ5LFxuICAgIGNsaWVudDogY2xpZW50LFxuICAgIHBhZ2U6IHBhZ2VcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZnVuY3Rpb24gdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGFyZ3MpIHtcbiAgdmFyIHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQoJ2RyYWdnYWJsZScpO1xuICB2YXIgZGVzY3JpcHRvciA9IGFyZ3MuZGVzY3JpcHRvcixcbiAgICAgIHJlZ2lzdHJ5ID0gYXJncy5yZWdpc3RyeSxcbiAgICAgIGdldERyYWdnYWJsZVJlZiA9IGFyZ3MuZ2V0RHJhZ2dhYmxlUmVmLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgPSBhcmdzLmNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MgPSBhcmdzLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgaXNFbmFibGVkID0gYXJncy5pc0VuYWJsZWQ7XG4gIHZhciBvcHRpb25zID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGlzRW5hYmxlZDogaXNFbmFibGVkXG4gICAgfTtcbiAgfSwgW2NhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLCBpc0VuYWJsZWQsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzXSk7XG4gIHZhciBnZXREaW1lbnNpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAod2luZG93U2Nyb2xsKSB7XG4gICAgdmFyIGVsID0gZ2V0RHJhZ2dhYmxlUmVmKCk7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGdldCBkaW1lbnNpb24gd2hlbiBubyByZWYgaXMgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBnZXREaW1lbnNpb24kMShkZXNjcmlwdG9yLCBlbCwgd2luZG93U2Nyb2xsKTtcbiAgfSwgW2Rlc2NyaXB0b3IsIGdldERyYWdnYWJsZVJlZl0pO1xuICB2YXIgZW50cnkgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pcXVlSWQ6IHVuaXF1ZUlkLFxuICAgICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBnZXREaW1lbnNpb246IGdldERpbWVuc2lvblxuICAgIH07XG4gIH0sIFtkZXNjcmlwdG9yLCBnZXREaW1lbnNpb24sIG9wdGlvbnMsIHVuaXF1ZUlkXSk7XG4gIHZhciBwdWJsaXNoZWRSZWYgPSB1c2VSZWYoZW50cnkpO1xuICB2YXIgaXNGaXJzdFB1Ymxpc2hSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdHJ5LmRyYWdnYWJsZS5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWdpc3RyeS5kcmFnZ2FibGUudW5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW3JlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCkge1xuICAgICAgaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcHVibGlzaGVkUmVmLmN1cnJlbnQ7XG4gICAgcHVibGlzaGVkUmVmLmN1cnJlbnQgPSBlbnRyeTtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUudXBkYXRlKGVudHJ5LCBsYXN0KTtcbiAgfSwgW2VudHJ5LCByZWdpc3RyeS5kcmFnZ2FibGVdKTtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbiQxKHByb3BzLCBjb250ZXh0SWQsIGdldFJlZikge1xuICB1c2VEZXZTZXR1cFdhcm5pbmcoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHByZWZpeChpZCkge1xuICAgICAgcmV0dXJuIFwiRHJhZ2dhYmxlW2lkOiBcIiArIGlkICsgXCJdOiBcIjtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBwcm9wcy5kcmFnZ2FibGVJZDtcbiAgICAhaWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgcmVxdWlyZXMgYSBkcmFnZ2FibGVJZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkRyYWdnYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyYWdnYWJsZUlkLlxcbiAgICAgIFByb3ZpZGVkOiBbdHlwZTogXCIgKyB0eXBlb2YgaWQgKyBcIl0gKHZhbHVlOiBcIiArIGlkICsgXCIpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhaXNJbnRlZ2VyKHByb3BzLmluZGV4KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgcHJlZml4KGlkKSArIFwiIHJlcXVpcmVzIGFuIGludGVnZXIgaW5kZXggcHJvcFwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvcHMubWFwcGVkLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXRSZWYoKSk7XG5cbiAgICBpZiAocHJvcHMuaXNFbmFibGVkKSB7XG4gICAgICAhZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIHByZWZpeChpZCkgKyBcIiBVbmFibGUgdG8gZmluZCBkcmFnIGhhbmRsZVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUNsb25lUHJvcFZhbGlkYXRpb24oaXNDbG9uZSkge1xuICB1c2VEZXYoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbml0aWFsUmVmID0gdXNlUmVmKGlzQ2xvbmUpO1xuICAgIHVzZURldlNldHVwV2FybmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAhKGlzQ2xvbmUgPT09IGluaXRpYWxSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdEcmFnZ2FibGUgaXNDbG9uZSBwcm9wIHZhbHVlIGNoYW5nZWQgZHVyaW5nIGNvbXBvbmVudCBsaWZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH0sIFtpc0Nsb25lXSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50SHRtbDVEbmQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gRHJhZ2dhYmxlKHByb3BzKSB7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBzZXRSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZWwpIHtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICB9LCBbXSk7XG4gIHZhciBnZXRSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG5cbiAgdmFyIF91c2VSZXF1aXJlZENvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCksXG4gICAgICBjb250ZXh0SWQgPSBfdXNlUmVxdWlyZWRDb250ZXh0LmNvbnRleHRJZCxcbiAgICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkID0gX3VzZVJlcXVpcmVkQ29udGV4dC5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICAgIHJlZ2lzdHJ5ID0gX3VzZVJlcXVpcmVkQ29udGV4dC5yZWdpc3RyeTtcblxuICB2YXIgX3VzZVJlcXVpcmVkQ29udGV4dDIgPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCksXG4gICAgICB0eXBlID0gX3VzZVJlcXVpcmVkQ29udGV4dDIudHlwZSxcbiAgICAgIGRyb3BwYWJsZUlkID0gX3VzZVJlcXVpcmVkQ29udGV4dDIuZHJvcHBhYmxlSWQ7XG5cbiAgdmFyIGRlc2NyaXB0b3IgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHByb3BzLmRyYWdnYWJsZUlkLFxuICAgICAgaW5kZXg6IHByb3BzLmluZGV4LFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGRyb3BwYWJsZUlkOiBkcm9wcGFibGVJZFxuICAgIH07XG4gIH0sIFtwcm9wcy5kcmFnZ2FibGVJZCwgcHJvcHMuaW5kZXgsIHR5cGUsIGRyb3BwYWJsZUlkXSk7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgZHJhZ2dhYmxlSWQgPSBwcm9wcy5kcmFnZ2FibGVJZCxcbiAgICAgIGlzRW5hYmxlZCA9IHByb3BzLmlzRW5hYmxlZCxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzID0gcHJvcHMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyA9IHByb3BzLmNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgICAgaXNDbG9uZSA9IHByb3BzLmlzQ2xvbmUsXG4gICAgICBtYXBwZWQgPSBwcm9wcy5tYXBwZWQsXG4gICAgICBkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24gPSBwcm9wcy5kcm9wQW5pbWF0aW9uRmluaXNoZWQ7XG4gIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpO1xuICB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpO1xuXG4gIGlmICghaXNDbG9uZSkge1xuICAgIHZhciBmb3JQdWJsaXNoZXIgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICAgIHJlZ2lzdHJ5OiByZWdpc3RyeSxcbiAgICAgICAgZ2V0RHJhZ2dhYmxlUmVmOiBnZXRSZWYsXG4gICAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZFxuICAgICAgfTtcbiAgICB9LCBbZGVzY3JpcHRvciwgcmVnaXN0cnksIGdldFJlZiwgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLCBpc0VuYWJsZWRdKTtcbiAgICB1c2VEcmFnZ2FibGVQdWJsaXNoZXIoZm9yUHVibGlzaGVyKTtcbiAgfVxuXG4gIHZhciBkcmFnSGFuZGxlUHJvcHMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNFbmFibGVkID8ge1xuICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgICAnZGF0YS1yYmQtZHJhZy1oYW5kbGUtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgICAnZGF0YS1yYmQtZHJhZy1oYW5kbGUtY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICBvbkRyYWdTdGFydDogcHJldmVudEh0bWw1RG5kXG4gICAgfSA6IG51bGw7XG4gIH0sIFtjb250ZXh0SWQsIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLCBkcmFnZ2FibGVJZCwgaXNFbmFibGVkXSk7XG4gIHZhciBvbk1vdmVFbmQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAobWFwcGVkLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW1hcHBlZC5kcm9wcGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uKCk7XG4gIH0sIFtkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24sIG1hcHBlZF0pO1xuICB2YXIgcHJvdmlkZWQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZSQxKG1hcHBlZCk7XG4gICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnICYmIG1hcHBlZC5kcm9wcGluZyA/IG9uTW92ZUVuZCA6IG51bGw7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGlubmVyUmVmOiBzZXRSZWYsXG4gICAgICBkcmFnZ2FibGVQcm9wczoge1xuICAgICAgICAnZGF0YS1yYmQtZHJhZ2dhYmxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgICAgICdkYXRhLXJiZC1kcmFnZ2FibGUtaWQnOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBvblRyYW5zaXRpb25FbmQ6IG9uVHJhbnNpdGlvbkVuZFxuICAgICAgfSxcbiAgICAgIGRyYWdIYW5kbGVQcm9wczogZHJhZ0hhbmRsZVByb3BzXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbY29udGV4dElkLCBkcmFnSGFuZGxlUHJvcHMsIGRyYWdnYWJsZUlkLCBtYXBwZWQsIG9uTW92ZUVuZCwgc2V0UmVmXSk7XG4gIHZhciBydWJyaWMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGRlc2NyaXB0b3IuaWQsXG4gICAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rlc2NyaXB0b3IuZHJvcHBhYmxlSWQsIGRlc2NyaXB0b3IuaWQsIGRlc2NyaXB0b3IuaW5kZXgsIGRlc2NyaXB0b3IudHlwZV0pO1xuICByZXR1cm4gY2hpbGRyZW4ocHJvdmlkZWQsIG1hcHBlZC5zbmFwc2hvdCwgcnVicmljKTtcbn1cblxudmFyIGlzU3RyaWN0RXF1YWwgPSAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59KTtcblxudmFyIHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCA9IChmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHZhciBjb21iaW5lID0gcmVzdWx0LmNvbWJpbmUsXG4gICAgICBkZXN0aW5hdGlvbiA9IHJlc3VsdC5kZXN0aW5hdGlvbjtcblxuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cblxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBjb21iaW5lLmRyb3BwYWJsZUlkO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59KTtcblxudmFyIGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdCA9IGZ1bmN0aW9uIGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC5jb21iaW5lID8gcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcblxudmFyIGdldENvbWJpbmVXaXRoRnJvbUltcGFjdCA9IGZ1bmN0aW9uIGdldENvbWJpbmVXaXRoRnJvbUltcGFjdChpbXBhY3QpIHtcbiAgcmV0dXJuIGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnID8gaW1wYWN0LmF0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlU2VsZWN0b3IoKSB7XG4gIHZhciBtZW1vaXplZE9mZnNldCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9KTtcbiAgdmFyIGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBkcm9wcGluZykge1xuICAgIHJldHVybiB7XG4gICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgaXNDbG9uZTogaXNDbG9uZSxcbiAgICAgIGlzRHJvcEFuaW1hdGluZzogQm9vbGVhbihkcm9wcGluZyksXG4gICAgICBkcm9wQW5pbWF0aW9uOiBkcm9wcGluZyxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBkcmFnZ2luZ092ZXI6IGRyYWdnaW5nT3ZlcixcbiAgICAgIGNvbWJpbmVXaXRoOiBjb21iaW5lV2l0aCxcbiAgICAgIGNvbWJpbmVUYXJnZXRGb3I6IG51bGxcbiAgICB9O1xuICB9KTtcbiAgdmFyIGdldE1lbW9pemVkUHJvcHMgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChvZmZzZXQsIG1vZGUsIGRpbWVuc2lvbiwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgZm9yY2VTaG91bGRBbmltYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcHBlZDoge1xuICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICBkcm9wcGluZzogbnVsbCxcbiAgICAgICAgZHJhZ2dpbmdPdmVyOiBkcmFnZ2luZ092ZXIsXG4gICAgICAgIGNvbWJpbmVXaXRoOiBjb21iaW5lV2l0aCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uLFxuICAgICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgbnVsbClcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICB2YXIgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHtcbiAgICBpZiAoc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgaWYgKHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCAhPT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSBzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQ7XG4gICAgICB2YXIgZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIHZhciBkcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICAgdmFyIGNvbWJpbmVXaXRoID0gZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0KHN0YXRlLmltcGFjdCk7XG4gICAgICB2YXIgZm9yY2VTaG91bGRBbmltYXRlID0gc3RhdGUuZm9yY2VTaG91bGRBbmltYXRlO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMobWVtb2l6ZWRPZmZzZXQob2Zmc2V0LngsIG9mZnNldC55KSwgc3RhdGUubW92ZW1lbnRNb2RlLCBkaW1lbnNpb24sIG93blByb3BzLmlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICB2YXIgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuXG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCAhPT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0Nsb25lID0gb3duUHJvcHMuaXNDbG9uZTtcbiAgICAgIHZhciBfZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIHZhciByZXN1bHQgPSBjb21wbGV0ZWQucmVzdWx0O1xuICAgICAgdmFyIG1vZGUgPSByZXN1bHQubW9kZTtcblxuICAgICAgdmFyIF9kcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQocmVzdWx0KTtcblxuICAgICAgdmFyIF9jb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdChyZXN1bHQpO1xuXG4gICAgICB2YXIgZHVyYXRpb24gPSBzdGF0ZS5kcm9wRHVyYXRpb247XG4gICAgICB2YXIgZHJvcHBpbmcgPSB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgY3VydmU6IGN1cnZlcy5kcm9wLFxuICAgICAgICBtb3ZlVG86IHN0YXRlLm5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgIG9wYWNpdHk6IF9jb21iaW5lV2l0aCA/IGNvbWJpbmUub3BhY2l0eS5kcm9wIDogbnVsbCxcbiAgICAgICAgc2NhbGU6IF9jb21iaW5lV2l0aCA/IGNvbWJpbmUuc2NhbGUuZHJvcCA6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXBwZWQ6IHtcbiAgICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICAgIG9mZnNldDogc3RhdGUubmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgICBkaW1lbnNpb246IF9kaW1lbnNpb24sXG4gICAgICAgICAgZHJvcHBpbmc6IGRyb3BwaW5nLFxuICAgICAgICAgIGRyYWdnaW5nT3ZlcjogX2RyYWdnaW5nT3ZlcixcbiAgICAgICAgICBjb21iaW5lV2l0aDogX2NvbWJpbmVXaXRoLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsLFxuICAgICAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIF9kcmFnZ2luZ092ZXIsIF9jb21iaW5lV2l0aCwgZHJvcHBpbmcpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTbmFwc2hvdChjb21iaW5lVGFyZ2V0Rm9yKSB7XG4gIHJldHVybiB7XG4gICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgaXNEcm9wQW5pbWF0aW5nOiBmYWxzZSxcbiAgICBpc0Nsb25lOiBmYWxzZSxcbiAgICBkcm9wQW5pbWF0aW9uOiBudWxsLFxuICAgIG1vZGU6IG51bGwsXG4gICAgZHJhZ2dpbmdPdmVyOiBudWxsLFxuICAgIGNvbWJpbmVUYXJnZXRGb3I6IGNvbWJpbmVUYXJnZXRGb3IsXG4gICAgY29tYmluZVdpdGg6IG51bGxcbiAgfTtcbn1cblxudmFyIGF0UmVzdCA9IHtcbiAgbWFwcGVkOiB7XG4gICAgdHlwZTogJ1NFQ09OREFSWScsXG4gICAgb2Zmc2V0OiBvcmlnaW4sXG4gICAgY29tYmluZVRhcmdldEZvcjogbnVsbCxcbiAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50OiB0cnVlLFxuICAgIHNuYXBzaG90OiBnZXRTZWNvbmRhcnlTbmFwc2hvdChudWxsKVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTZWxlY3RvcigpIHtcbiAgdmFyIG1lbW9pemVkT2Zmc2V0ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH0pO1xuICB2YXIgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IG1lbW9pemVPbmUoZ2V0U2Vjb25kYXJ5U25hcHNob3QpO1xuICB2YXIgZ2V0TWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCkge1xuICAgIGlmIChjb21iaW5lVGFyZ2V0Rm9yID09PSB2b2lkIDApIHtcbiAgICAgIGNvbWJpbmVUYXJnZXRGb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtYXBwZWQ6IHtcbiAgICAgICAgdHlwZTogJ1NFQ09OREFSWScsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBjb21iaW5lVGFyZ2V0Rm9yOiBjb21iaW5lVGFyZ2V0Rm9yLFxuICAgICAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50OiBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50LFxuICAgICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChjb21iaW5lVGFyZ2V0Rm9yKVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBnZXRGYWxsYmFjayA9IGZ1bmN0aW9uIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpIHtcbiAgICByZXR1cm4gY29tYmluZVRhcmdldEZvciA/IGdldE1lbW9pemVkUHJvcHMob3JpZ2luLCBjb21iaW5lVGFyZ2V0Rm9yLCB0cnVlKSA6IG51bGw7XG4gIH07XG5cbiAgdmFyIGdldFByb3BzID0gZnVuY3Rpb24gZ2V0UHJvcHMob3duSWQsIGRyYWdnaW5nSWQsIGltcGFjdCwgYWZ0ZXJDcml0aWNhbCkge1xuICAgIHZhciB2aXN1YWxEaXNwbGFjZW1lbnQgPSBpbXBhY3QuZGlzcGxhY2VkLnZpc2libGVbb3duSWRdO1xuICAgIHZhciBpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0ID0gQm9vbGVhbihhZnRlckNyaXRpY2FsLmluVmlydHVhbExpc3QgJiYgYWZ0ZXJDcml0aWNhbC5lZmZlY3RlZFtvd25JZF0pO1xuICAgIHZhciBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAgIHZhciBjb21iaW5lVGFyZ2V0Rm9yID0gY29tYmluZSAmJiBjb21iaW5lLmRyYWdnYWJsZUlkID09PSBvd25JZCA/IGRyYWdnaW5nSWQgOiBudWxsO1xuXG4gICAgaWYgKCF2aXN1YWxEaXNwbGFjZW1lbnQpIHtcbiAgICAgIGlmICghaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCkge1xuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2soY29tYmluZVRhcmdldEZvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbXBhY3QuZGlzcGxhY2VkLmludmlzaWJsZVtvd25JZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2UgPSBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCk7XG5cbiAgICAgIHZhciBfb2Zmc2V0ID0gbWVtb2l6ZWRPZmZzZXQoY2hhbmdlLngsIGNoYW5nZS55KTtcblxuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMoX29mZnNldCwgY29tYmluZVRhcmdldEZvciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKTtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGxhY2VCeSA9IGltcGFjdC5kaXNwbGFjZWRCeS5wb2ludDtcbiAgICB2YXIgb2Zmc2V0ID0gbWVtb2l6ZWRPZmZzZXQoZGlzcGxhY2VCeS54LCBkaXNwbGFjZUJ5LnkpO1xuICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgdmlzdWFsRGlzcGxhY2VtZW50LnNob3VsZEFuaW1hdGUpO1xuICB9O1xuXG4gIHZhciBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIGlmIChzdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICBpZiAoc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkID09PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFByb3BzKG93blByb3BzLmRyYWdnYWJsZUlkLCBzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQsIHN0YXRlLmltcGFjdCwgc3RhdGUuYWZ0ZXJDcml0aWNhbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICB2YXIgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuXG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCwgY29tcGxldGVkLmltcGFjdCwgY29tcGxldGVkLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cblxudmFyIG1ha2VNYXBTdGF0ZVRvUHJvcHMgPSBmdW5jdGlvbiBtYWtlTWFwU3RhdGVUb1Byb3BzKCkge1xuICB2YXIgZHJhZ2dpbmdTZWxlY3RvciA9IGdldERyYWdnYWJsZVNlbGVjdG9yKCk7XG4gIHZhciBzZWNvbmRhcnlTZWxlY3RvciA9IGdldFNlY29uZGFyeVNlbGVjdG9yKCk7XG5cbiAgdmFyIHNlbGVjdG9yID0gZnVuY3Rpb24gc2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBzZWNvbmRhcnlTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHx8IGF0UmVzdDtcbiAgfTtcblxuICByZXR1cm4gc2VsZWN0b3I7XG59O1xudmFyIG1hcERpc3BhdGNoVG9Qcm9wcyA9IHtcbiAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkOiBkcm9wQW5pbWF0aW9uRmluaXNoZWRcbn07XG52YXIgQ29ubmVjdGVkRHJhZ2dhYmxlID0gY29ubmVjdChtYWtlTWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG51bGwsIHtcbiAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICBwdXJlOiB0cnVlLFxuICBhcmVTdGF0ZVByb3BzRXF1YWw6IGlzU3RyaWN0RXF1YWxcbn0pKERyYWdnYWJsZSk7XG5cbmZ1bmN0aW9uIFByaXZhdGVEcmFnZ2FibGUocHJvcHMpIHtcbiAgdmFyIGRyb3BwYWJsZUNvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCk7XG4gIHZhciBpc1VzaW5nQ2xvbmVGb3IgPSBkcm9wcGFibGVDb250ZXh0LmlzVXNpbmdDbG9uZUZvcjtcblxuICBpZiAoaXNVc2luZ0Nsb25lRm9yID09PSBwcm9wcy5kcmFnZ2FibGVJZCAmJiAhcHJvcHMuaXNDbG9uZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGVkRHJhZ2dhYmxlLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBQdWJsaWNEcmFnZ2FibGUocHJvcHMpIHtcbiAgdmFyIGlzRW5hYmxlZCA9IHR5cGVvZiBwcm9wcy5pc0RyYWdEaXNhYmxlZCA9PT0gJ2Jvb2xlYW4nID8gIXByb3BzLmlzRHJhZ0Rpc2FibGVkIDogdHJ1ZTtcbiAgdmFyIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzID0gQm9vbGVhbihwcm9wcy5kaXNhYmxlSW50ZXJhY3RpdmVFbGVtZW50QmxvY2tpbmcpO1xuICB2YXIgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MgPSBCb29sZWFuKHByb3BzLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpdmF0ZURyYWdnYWJsZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgaXNDbG9uZTogZmFsc2UsXG4gICAgaXNFbmFibGVkOiBpc0VuYWJsZWQsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIERyb3BwYWJsZShwcm9wcykge1xuICB2YXIgYXBwQ29udGV4dCA9IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7XG4gICFhcHBDb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgYXBwIGNvbnRleHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBjb250ZXh0SWQgPSBhcHBDb250ZXh0LmNvbnRleHRJZCxcbiAgICAgIGlzTW92ZW1lbnRBbGxvd2VkID0gYXBwQ29udGV4dC5pc01vdmVtZW50QWxsb3dlZDtcbiAgdmFyIGRyb3BwYWJsZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGRyb3BwYWJsZUlkID0gcHJvcHMuZHJvcHBhYmxlSWQsXG4gICAgICB0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIG1vZGUgPSBwcm9wcy5tb2RlLFxuICAgICAgZGlyZWN0aW9uID0gcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcgPSBwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICAgIGlzRHJvcERpc2FibGVkID0gcHJvcHMuaXNEcm9wRGlzYWJsZWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkID0gcHJvcHMuaXNDb21iaW5lRW5hYmxlZCxcbiAgICAgIHNuYXBzaG90ID0gcHJvcHMuc25hcHNob3QsXG4gICAgICB1c2VDbG9uZSA9IHByb3BzLnVzZUNsb25lLFxuICAgICAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwgPSBwcm9wcy51cGRhdGVWaWV3cG9ydE1heFNjcm9sbCxcbiAgICAgIGdldENvbnRhaW5lckZvckNsb25lID0gcHJvcHMuZ2V0Q29udGFpbmVyRm9yQ2xvbmU7XG4gIHZhciBnZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHZhciBzZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBkcm9wcGFibGVSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbXSk7XG4gIHZhciBnZXRQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXJSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB2YXIgc2V0UGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFtdKTtcbiAgdXNlVmFsaWRhdGlvbih7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGdldERyb3BwYWJsZVJlZjogZ2V0RHJvcHBhYmxlUmVmLFxuICAgIGdldFBsYWNlaG9sZGVyUmVmOiBnZXRQbGFjZWhvbGRlclJlZlxuICB9KTtcbiAgdmFyIG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc01vdmVtZW50QWxsb3dlZCgpKSB7XG4gICAgICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCh7XG4gICAgICAgIG1heFNjcm9sbDogZ2V0TWF4V2luZG93U2Nyb2xsKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2lzTW92ZW1lbnRBbGxvd2VkLCB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbF0pO1xuICB1c2VEcm9wcGFibGVQdWJsaXNoZXIoe1xuICAgIGRyb3BwYWJsZUlkOiBkcm9wcGFibGVJZCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIG1vZGU6IG1vZGUsXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgaXNEcm9wRGlzYWJsZWQ6IGlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQ6IGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmc6IGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nLFxuICAgIGdldERyb3BwYWJsZVJlZjogZ2V0RHJvcHBhYmxlUmVmXG4gIH0pO1xuICB2YXIgcGxhY2Vob2xkZXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGVJbk91dCwge1xuICAgIG9uOiBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICBzaG91bGRBbmltYXRlOiBwcm9wcy5zaG91bGRBbmltYXRlUGxhY2Vob2xkZXJcbiAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgb25DbG9zZSA9IF9yZWYub25DbG9zZSxcbiAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgYW5pbWF0ZSA9IF9yZWYuYW5pbWF0ZTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQbGFjZWhvbGRlciQxLCB7XG4gICAgICBwbGFjZWhvbGRlcjogZGF0YSxcbiAgICAgIG9uQ2xvc2U6IG9uQ2xvc2UsXG4gICAgICBpbm5lclJlZjogc2V0UGxhY2Vob2xkZXJSZWYsXG4gICAgICBhbmltYXRlOiBhbmltYXRlLFxuICAgICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgICBvblRyYW5zaXRpb25FbmQ6IG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kXG4gICAgfSk7XG4gIH0pO1xuICB2YXIgcHJvdmlkZWQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5uZXJSZWY6IHNldERyb3BwYWJsZVJlZixcbiAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgIGRyb3BwYWJsZVByb3BzOiB7XG4gICAgICAgICdkYXRhLXJiZC1kcm9wcGFibGUtaWQnOiBkcm9wcGFibGVJZCxcbiAgICAgICAgJ2RhdGEtcmJkLWRyb3BwYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2NvbnRleHRJZCwgZHJvcHBhYmxlSWQsIHBsYWNlaG9sZGVyLCBzZXREcm9wcGFibGVSZWZdKTtcbiAgdmFyIGlzVXNpbmdDbG9uZUZvciA9IHVzZUNsb25lID8gdXNlQ2xvbmUuZHJhZ2dpbmcuZHJhZ2dhYmxlSWQgOiBudWxsO1xuICB2YXIgZHJvcHBhYmxlQ29udGV4dCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkcm9wcGFibGVJZDogZHJvcHBhYmxlSWQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaXNVc2luZ0Nsb25lRm9yOiBpc1VzaW5nQ2xvbmVGb3JcbiAgICB9O1xuICB9LCBbZHJvcHBhYmxlSWQsIGlzVXNpbmdDbG9uZUZvciwgdHlwZV0pO1xuXG4gIGZ1bmN0aW9uIGdldENsb25lKCkge1xuICAgIGlmICghdXNlQ2xvbmUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBkcmFnZ2luZyA9IHVzZUNsb25lLmRyYWdnaW5nLFxuICAgICAgICByZW5kZXIgPSB1c2VDbG9uZS5yZW5kZXI7XG4gICAgdmFyIG5vZGUgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVEcmFnZ2FibGUsIHtcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2luZy5kcmFnZ2FibGVJZCxcbiAgICAgIGluZGV4OiBkcmFnZ2luZy5zb3VyY2UuaW5kZXgsXG4gICAgICBpc0Nsb25lOiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiB0cnVlLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGZhbHNlLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IHRydWVcbiAgICB9LCBmdW5jdGlvbiAoZHJhZ2dhYmxlUHJvdmlkZWQsIGRyYWdnYWJsZVNuYXBzaG90KSB7XG4gICAgICByZXR1cm4gcmVuZGVyKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCwgZHJhZ2dpbmcpO1xuICAgIH0pO1xuICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwobm9kZSwgZ2V0Q29udGFpbmVyRm9yQ2xvbmUoKSk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wcGFibGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRyb3BwYWJsZUNvbnRleHRcbiAgfSwgY2hpbGRyZW4ocHJvdmlkZWQsIHNuYXBzaG90KSwgZ2V0Q2xvbmUoKSk7XG59XG5cbnZhciBpc01hdGNoaW5nVHlwZSA9IGZ1bmN0aW9uIGlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNyaXRpY2FsKSB7XG4gIHJldHVybiB0eXBlID09PSBjcml0aWNhbC5kcm9wcGFibGUudHlwZTtcbn07XG5cbnZhciBnZXREcmFnZ2FibGUgPSBmdW5jdGlvbiBnZXREcmFnZ2FibGUoY3JpdGljYWwsIGRpbWVuc2lvbnMpIHtcbiAgcmV0dXJuIGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tjcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xufTtcblxudmFyIG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSA9IGZ1bmN0aW9uIG1ha2VNYXBTdGF0ZVRvUHJvcHMoKSB7XG4gIHZhciBpZGxlV2l0aEFuaW1hdGlvbiA9IHtcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IHRydWUsXG4gICAgc25hcHNob3Q6IHtcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nT3ZlcldpdGg6IG51bGwsXG4gICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogbnVsbCxcbiAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogZmFsc2VcbiAgICB9LFxuICAgIHVzZUNsb25lOiBudWxsXG4gIH07XG5cbiAgdmFyIGlkbGVXaXRob3V0QW5pbWF0aW9uID0gX2V4dGVuZHMoe30sIGlkbGVXaXRoQW5pbWF0aW9uLCB7XG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZVxuICB9KTtcblxuICB2YXIgZ2V0RHJhZ2dhYmxlUnVicmljID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICAgIHJldHVybiB7XG4gICAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICAgIHR5cGU6IGRlc2NyaXB0b3IudHlwZSxcbiAgICAgIHNvdXJjZToge1xuICAgICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgdmFyIGdldE1hcFByb3BzID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciwgaXNEcmFnZ2luZ092ZXJGb3JJbXBhY3QsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSkge1xuICAgIHZhciBkcmFnZ2FibGVJZCA9IGRyYWdnaW5nLmRlc2NyaXB0b3IuaWQ7XG4gICAgdmFyIGlzSG9tZSA9IGRyYWdnaW5nLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGlkO1xuXG4gICAgaWYgKGlzSG9tZSkge1xuICAgICAgdmFyIHVzZUNsb25lID0gcmVuZGVyQ2xvbmUgPyB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyQ2xvbmUsXG4gICAgICAgIGRyYWdnaW5nOiBnZXREcmFnZ2FibGVSdWJyaWMoZHJhZ2dpbmcuZGVzY3JpcHRvcilcbiAgICAgIH0gOiBudWxsO1xuICAgICAgdmFyIF9zbmFwc2hvdCA9IHtcbiAgICAgICAgaXNEcmFnZ2luZ092ZXI6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsXG4gICAgICAgIGRyYWdnaW5nT3ZlcldpdGg6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIgPyBkcmFnZ2FibGVJZCA6IG51bGwsXG4gICAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGxhY2Vob2xkZXI6IGRyYWdnaW5nLnBsYWNlaG9sZGVyLFxuICAgICAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IGZhbHNlLFxuICAgICAgICBzbmFwc2hvdDogX3NuYXBzaG90LFxuICAgICAgICB1c2VDbG9uZTogdXNlQ2xvbmVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoIWlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0KSB7XG4gICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgfVxuXG4gICAgdmFyIHNuYXBzaG90ID0ge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBkcmFnZ2FibGVJZCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcGxhY2Vob2xkZXI6IGRyYWdnaW5nLnBsYWNlaG9sZGVyLFxuICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgc25hcHNob3Q6IHNuYXBzaG90LFxuICAgICAgdXNlQ2xvbmU6IG51bGxcbiAgICB9O1xuICB9KTtcblxuICB2YXIgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHtcbiAgICB2YXIgaWQgPSBvd25Qcm9wcy5kcm9wcGFibGVJZDtcbiAgICB2YXIgdHlwZSA9IG93blByb3BzLnR5cGU7XG4gICAgdmFyIGlzRW5hYmxlZCA9ICFvd25Qcm9wcy5pc0Ryb3BEaXNhYmxlZDtcbiAgICB2YXIgcmVuZGVyQ2xvbmUgPSBvd25Qcm9wcy5yZW5kZXJDbG9uZTtcblxuICAgIGlmIChzdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICB2YXIgY3JpdGljYWwgPSBzdGF0ZS5jcml0aWNhbDtcblxuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuICAgICAgdmFyIGlzRHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KSA9PT0gaWQ7XG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXIsIGlzRHJhZ2dpbmdPdmVyLCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcblxuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjb21wbGV0ZWQuY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9kcmFnZ2luZyA9IGdldERyYWdnYWJsZShjb21wbGV0ZWQuY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuXG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KGNvbXBsZXRlZC5yZXN1bHQpID09PSBpZCwgd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkLCBfZHJhZ2dpbmcsIHJlbmRlckNsb25lKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyAmJiBzdGF0ZS5jb21wbGV0ZWQgJiYgIXN0YXRlLnNob3VsZEZsdXNoKSB7XG4gICAgICB2YXIgX2NvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcblxuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBfY29tcGxldGVkLmNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciB3YXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoX2NvbXBsZXRlZC5pbXBhY3QpID09PSBpZDtcbiAgICAgIHZhciB3YXNDb21iaW5pbmcgPSBCb29sZWFuKF9jb21wbGV0ZWQuaW1wYWN0LmF0ICYmIF9jb21wbGV0ZWQuaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyk7XG4gICAgICB2YXIgaXNIb21lID0gX2NvbXBsZXRlZC5jcml0aWNhbC5kcm9wcGFibGUuaWQgPT09IGlkO1xuXG4gICAgICBpZiAod2FzT3Zlcikge1xuICAgICAgICByZXR1cm4gd2FzQ29tYmluaW5nID8gaWRsZVdpdGhBbmltYXRpb24gOiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSG9tZSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbnZhciBtYXBEaXNwYXRjaFRvUHJvcHMkMSA9IHtcbiAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGw6IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsXG59O1xuXG5mdW5jdGlvbiBnZXRCb2R5KCkge1xuICAhZG9jdW1lbnQuYm9keSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2RvY3VtZW50LmJvZHkgaXMgbm90IHJlYWR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbn1cblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgbW9kZTogJ3N0YW5kYXJkJyxcbiAgdHlwZTogJ0RFRkFVTFQnLFxuICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGlzRHJvcERpc2FibGVkOiBmYWxzZSxcbiAgaXNDb21iaW5lRW5hYmxlZDogZmFsc2UsXG4gIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nOiBmYWxzZSxcbiAgcmVuZGVyQ2xvbmU6IG51bGwsXG4gIGdldENvbnRhaW5lckZvckNsb25lOiBnZXRCb2R5XG59O1xudmFyIENvbm5lY3RlZERyb3BwYWJsZSA9IGNvbm5lY3QobWFrZU1hcFN0YXRlVG9Qcm9wcyQxLCBtYXBEaXNwYXRjaFRvUHJvcHMkMSwgbnVsbCwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIHB1cmU6IHRydWUsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJvcHBhYmxlKTtcbkNvbm5lY3RlZERyb3BwYWJsZS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbmV4cG9ydCB7IERyYWdEcm9wQ29udGV4dCwgUHVibGljRHJhZ2dhYmxlIGFzIERyYWdnYWJsZSwgQ29ubmVjdGVkRHJvcHBhYmxlIGFzIERyb3BwYWJsZSwgcmVzZXRTZXJ2ZXJDb250ZXh0IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///ngQI\n");

/***/ })

}]);